{"version":3,"sources":["../src/index.ts","../src/core/CoreAdmin.tsx","../src/core/CoreAdminContext.tsx","../src/routing/AdminRouter.tsx","../src/routing/HistoryRouter.tsx","../src/routing/BasenameContextProvider.tsx","../src/routing/BasenameContext.ts","../src/routing/linkToRecord.ts","../src/routing/resolveRedirectTo.ts","../src/routing/useBasename.ts","../src/routing/useCreatePath.ts","../src/routing/useRedirect.ts","../src/routing/useScrollToTop.tsx","../src/auth/AuthContext.tsx","../src/auth/useAuthProvider.ts","../src/auth/useAuthState.ts","../src/auth/useCheckAuth.ts","../src/auth/useLogout.ts","../src/store/localStorageStore.ts","../src/store/memoryStore.tsx","../src/store/StoreContext.tsx","../src/store/StoreContextProvider.tsx","../src/store/StoreSetter.tsx","../src/store/useStoreContext.ts","../src/store/useStore.ts","../src/util/escapePath.ts","../src/util/FieldTitle.tsx","../src/i18n/TestTranslationProvider.tsx","../src/i18n/I18nContextProvider.tsx","../src/i18n/I18nContext.ts","../src/notification/useNotify.ts","../src/notification/useNotificationContext.ts","../src/notification/NotificationContext.ts","../src/notification/NotificationContextProvider.tsx","../src/i18n/TranslatableContext.ts","../src/i18n/TranslatableContextProvider.tsx","../src/i18n/TranslationUtils.ts","../src/i18n/useLocaleState.tsx","../src/i18n/useI18nProvider.ts","../src/i18n/useLocale.tsx","../src/i18n/useSetLocale.tsx","../src/i18n/useTranslatable.ts","../src/i18n/useTranslate.ts","../src/i18n/useTranslatableContext.ts","../src/i18n/index.ts","../src/util/getFieldLabelTranslationArgs.ts","../src/core/useResourceContext.ts","../src/core/ResourceContext.ts","../src/util/ComponentPropType.ts","../src/util/shallowEqual.ts","../src/util/removeEmpty.ts","../src/util/removeKey.ts","../src/util/Ready.tsx","../src/util/warning.ts","../src/util/useWhyDidYouUpdate.ts","../src/util/getMutationMode.ts","../src/util/mergeRefs.ts","../src/util/useEventCallback.ts","../src/util/hooks.ts","../src/store/useRemoveFromStore.ts","../src/store/useResetStore.ts","../src/auth/usePermissions.ts","../src/auth/useGetPermissions.ts","../src/auth/usePermissionsOptimized.ts","../src/auth/WithPermissions.tsx","../src/auth/useAuthenticated.ts","../src/auth/useLogin.ts","../src/auth/useGetIdentity.ts","../src/auth/useLogoutIfAccessDenied.ts","../src/auth/types.ts","../src/auth/convertLegacyAuthProvider.ts","../src/auth/Authenticated.tsx","../src/dataProvider/dataFetchActions.ts","../src/dataProvider/convertLegacyDataProvider.ts","../src/dataProvider/DataProviderContext.ts","../src/dataProvider/HttpError.ts","../src/dataProvider/fetch.ts","../src/dataProvider/undoableEventEmitter.ts","../src/dataProvider/defaultDataProvider.ts","../src/dataProvider/combineDataProviders.ts","../src/dataProvider/testDataProvider.ts","../src/dataProvider/useDataProvider.ts","../src/dataProvider/validateResponseFormat.ts","../src/dataProvider/useIsDataLoaded.ts","../src/dataProvider/useLoading.ts","../src/dataProvider/useRefresh.ts","../src/dataProvider/useGetOne.ts","../src/dataProvider/useGetList.ts","../src/dataProvider/useGetMany.ts","../src/dataProvider/useGetManyAggregate.ts","../src/dataProvider/useGetManyReference.ts","../src/dataProvider/useCreate.ts","../src/dataProvider/useUpdate.ts","../src/dataProvider/useUpdateMany.ts","../src/dataProvider/useDelete.ts","../src/dataProvider/useDeleteMany.ts","../src/core/ResourceDefinitionContext.tsx","../src/core/CoreAdminUI.tsx","../src/core/CoreAdminRoutes.tsx","../src/core/useConfigureAdminRouterFromChildren.tsx","../src/core/useResourceDefinitionContext.ts","../src/core/CustomRoutes.tsx","../src/core/Resource.tsx","../src/core/ResourceContextProvider.tsx","../src/core/useGetResourceLabel.ts","../src/core/useResourceDefinitions.ts","../src/core/useResourceDefinition.ts","../src/export/defaultExporter.ts","../src/export/downloadCSV.ts","../src/export/ExporterContext.ts","../src/export/fetchRelatedRecords.ts","../src/inference/inferElementFromValues.tsx","../src/inference/getValuesFromRecords.ts","../src/inference/InferredElement.ts","../src/inference/assertions.ts","../src/inference/getElementsFromRecords.ts","../src/inference/inferTypeFromValues.ts","../src/controller/useFilterState.ts","../src/controller/useSortState.ts","../src/controller/list/queryReducer.ts","../src/controller/usePaginationState.ts","../src/controller/checkMinimumRequiredProps.tsx","../src/controller/button/useDeleteWithUndoController.tsx","../src/controller/button/useDeleteWithConfirmController.tsx","../src/controller/create/CreateBase.tsx","../src/controller/create/useCreateController.ts","../src/controller/create/CreateContextProvider.tsx","../src/controller/record/RecordContext.tsx","../src/controller/create/CreateContext.tsx","../src/controller/saveContext/SaveContext.ts","../src/controller/saveContext/SaveContextProvider.tsx","../src/controller/saveContext/usePickSaveContext.ts","../src/controller/saveContext/useSaveContext.ts","../src/controller/create/CreateController.tsx","../src/controller/create/useCreateContext.tsx","../src/controller/edit/EditBase.tsx","../src/controller/edit/useEditController.ts","../src/controller/edit/EditContextProvider.tsx","../src/controller/record/useRecordContext.ts","../src/controller/record/WithRecord.tsx","../src/controller/record/OptionalRecordContextProvider.tsx","../src/controller/edit/EditContext.tsx","../src/controller/edit/EditController.tsx","../src/controller/edit/useEditContext.tsx","../src/controller/field/useReferenceArrayFieldController.ts","../src/controller/list/ListBase.tsx","../src/controller/list/useListController.ts","../src/controller/list/useRecordSelection.ts","../src/controller/list/useListParams.ts","../src/controller/list/ListContextProvider.tsx","../src/controller/list/ListContext.tsx","../src/controller/list/ListFilterContext.tsx","../src/controller/list/ListSortContext.tsx","../src/controller/list/ListPaginationContext.tsx","../src/controller/list/ListController.tsx","../src/controller/list/useList.ts","../src/controller/list/useListContext.ts","../src/controller/list/useListFilterContext.ts","../src/controller/list/useListPaginationContext.ts","../src/controller/list/useListSortContext.ts","../src/controller/list/useUnselect.ts","../src/controller/list/useUnselectAll.ts","../src/controller/list/useExpanded.tsx","../src/controller/field/useReferenceManyFieldController.ts","../src/controller/field/useReferenceOneFieldController.tsx","../src/controller/input/referenceDataStatus.ts","../src/controller/input/useReferenceArrayInputController.ts","../src/controller/input/useReferenceParams.ts","../src/controller/input/useReferenceInputController.ts","../src/controller/useReference.ts","../src/controller/show/ShowBase.tsx","../src/controller/show/useShowController.ts","../src/controller/show/ShowContextProvider.tsx","../src/controller/show/ShowContext.tsx","../src/controller/show/ShowController.tsx","../src/controller/show/useShowContext.tsx","../src/form/FormDataConsumer.tsx","../src/form/FormGroupsContext.tsx","../src/form/ValidationError.tsx","../src/form/getSimpleValidationResolver.ts","../src/form/choices/ChoicesContext.ts","../src/form/choices/ChoicesContextProvider.tsx","../src/form/choices/useChoicesContext.ts","../src/form/Form.tsx","../src/form/FormGroupsProvider.tsx","../src/form/useAugmentedForm.ts","../src/form/getFormInitialValues.ts","../src/form/setSubmissionErrors.ts","../src/form/useIsFormInvalid.ts","../src/form/useWarnWhenUnsavedChanges.tsx","../src/form/validate.ts","../src/form/FormGroupContext.ts","../src/form/FormGroupContextProvider.tsx","../src/form/useFormGroups.ts","../src/form/useApplyInputDefaultValues.ts","../src/form/useChoices.tsx","../src/form/useFormGroup.ts","../src/form/useFormGroupContext.ts","../src/form/useGetValidationErrorMessage.ts","../src/form/useInitializeFormWithRecord.ts","../src/form/useInput.ts","../src/form/isRequired.ts","../src/form/useSuggestions.ts","../src/types.ts"],"sourcesContent":["export * from './core';\nexport * from './auth';\nexport * from './dataProvider';\nexport * from './export';\nexport * from './i18n';\nexport * from './inference';\nexport * from './util';\nexport * from './controller';\nexport * from './form';\nexport * from './notification';\nexport * from './store';\nexport * from './routing';\nexport * from './types';\n","import * as React from 'react';\n\nimport { CoreAdminContext, CoreAdminContextProps } from './CoreAdminContext';\nimport { CoreAdminUI, CoreAdminUIProps } from './CoreAdminUI';\n\n/**\n * Main admin component, entry point to the application.\n *\n * Initializes the various contexts (auth, data, i18n, router)\n * and defines the main routes.\n *\n * Expects a list of resources as children, or a function returning a list of\n * resources based on the permissions.\n *\n * @example\n *\n * // static list of resources\n *\n * import {\n *     CoreAdmin,\n *     Resource,\n *     ListGuesser,\n *     useDataProvider,\n * } from 'ra-core';\n *\n * const App = () => (\n *     <CoreAdmin dataProvider={myDataProvider}>\n *         <Resource name=\"posts\" list={ListGuesser} />\n *     </CoreAdmin>\n * );\n *\n * // dynamic list of resources based on permissions\n *\n * import {\n *     CoreAdmin,\n *     Resource,\n *     ListGuesser,\n *     useDataProvider,\n * } from 'ra-core';\n *\n * const App = () => (\n *     <CoreAdmin dataProvider={myDataProvider}>\n *         {permissions => [\n *             <Resource name=\"posts\" key=\"posts\" list={ListGuesser} />,\n *         ]}\n *     </CoreAdmin>\n * );\n *\n * // If you have to build a dynamic list of resources using a side effect,\n * // you can't use <CoreAdmin>. But as it delegates to sub components,\n * // it's relatively straightforward to replace it:\n *\n * import * as React from 'react';\n * import { useEffect, useState } from 'react';\n * import {\n *     CoreAdminContext,\n *     CoreAdminUI,\n *     Resource,\n *     ListGuesser,\n *     useDataProvider,\n * } from 'ra-core';\n *\n * const App = () => (\n *     <CoreAdminContext dataProvider={myDataProvider}>\n *         <UI />\n *     </CoreAdminContext>\n * );\n *\n * const UI = () => {\n *     const [resources, setResources] = useState([]);\n *     const dataProvider = useDataProvider();\n *     useEffect(() => {\n *         dataProvider.introspect().then(r => setResources(r));\n *     }, []);\n *\n *     return (\n *         <CoreAdminUI>\n *             {resources.map(resource => (\n *                 <Resource name={resource.name} key={resource.key} list={ListGuesser} />\n *             ))}\n *         </CoreAdminUI>\n *     );\n * };\n */\nexport const CoreAdmin = (props: CoreAdminProps) => {\n    const {\n        authProvider,\n        basename,\n        catchAll,\n        children,\n        dashboard,\n        dataProvider,\n        disableTelemetry,\n        history,\n        i18nProvider,\n        queryClient,\n        layout,\n        loading,\n        loginPage,\n        menu, // deprecated, use a custom layout instead\n        ready,\n        requireAuth,\n        title = 'React Admin',\n    } = props;\n    return (\n        <CoreAdminContext\n            authProvider={authProvider}\n            basename={basename}\n            dataProvider={dataProvider}\n            i18nProvider={i18nProvider}\n            queryClient={queryClient}\n            history={history}\n        >\n            <CoreAdminUI\n                layout={layout}\n                dashboard={dashboard}\n                disableTelemetry={disableTelemetry}\n                menu={menu}\n                catchAll={catchAll}\n                title={title}\n                loading={loading}\n                loginPage={loginPage}\n                requireAuth={requireAuth}\n                ready={ready}\n            >\n                {children}\n            </CoreAdminUI>\n        </CoreAdminContext>\n    );\n};\n\nexport type CoreAdminProps = CoreAdminContextProps & CoreAdminUIProps;\n","import * as React from 'react';\nimport { useMemo } from 'react';\nimport { QueryClientProvider, QueryClient } from 'react-query';\nimport { History } from 'history';\n\nimport { AdminRouter } from '../routing';\nimport { AuthContext, convertLegacyAuthProvider } from '../auth';\nimport {\n    DataProviderContext,\n    convertLegacyDataProvider,\n    defaultDataProvider,\n} from '../dataProvider';\nimport { StoreContextProvider, Store, memoryStore } from '../store';\nimport { I18nContextProvider } from '../i18n';\nimport { ResourceDefinitionContextProvider } from './ResourceDefinitionContext';\nimport { NotificationContextProvider } from '../notification';\nimport {\n    AuthProvider,\n    LegacyAuthProvider,\n    I18nProvider,\n    DataProvider,\n    AdminChildren,\n    DashboardComponent,\n    LegacyDataProvider,\n} from '../types';\n\nexport interface CoreAdminContextProps {\n    authProvider?: AuthProvider | LegacyAuthProvider;\n    basename?: string;\n    children?: AdminChildren;\n    dashboard?: DashboardComponent;\n    dataProvider?: DataProvider | LegacyDataProvider;\n    store?: Store;\n    queryClient?: QueryClient;\n    /**\n     * @deprecated Wrap your Admin inside a Router to change the routing strategy\n     */\n    history?: History;\n    i18nProvider?: I18nProvider;\n    theme?: object;\n}\n\nexport const CoreAdminContext = (props: CoreAdminContextProps) => {\n    const {\n        authProvider,\n        basename,\n        dataProvider,\n        i18nProvider,\n        store,\n        children,\n        history,\n        queryClient,\n    } = props;\n\n    if (!dataProvider) {\n        throw new Error(`Missing dataProvider prop.\nReact-admin requires a valid dataProvider function to work.`);\n    }\n\n    const finalQueryClient = useMemo(() => queryClient || new QueryClient(), [\n        queryClient,\n    ]);\n\n    const finalAuthProvider = useMemo(\n        () =>\n            authProvider instanceof Function\n                ? convertLegacyAuthProvider(authProvider)\n                : authProvider,\n        [authProvider]\n    );\n\n    const finalDataProvider = useMemo(\n        () =>\n            dataProvider instanceof Function\n                ? convertLegacyDataProvider(dataProvider)\n                : dataProvider,\n        [dataProvider]\n    );\n\n    return (\n        <AuthContext.Provider value={finalAuthProvider}>\n            <DataProviderContext.Provider value={finalDataProvider}>\n                <StoreContextProvider value={store}>\n                    <QueryClientProvider client={finalQueryClient}>\n                        <AdminRouter history={history} basename={basename}>\n                            <I18nContextProvider value={i18nProvider}>\n                                <NotificationContextProvider>\n                                    <ResourceDefinitionContextProvider>\n                                        {children}\n                                    </ResourceDefinitionContextProvider>\n                                </NotificationContextProvider>\n                            </I18nContextProvider>\n                        </AdminRouter>\n                    </QueryClientProvider>\n                </StoreContextProvider>\n            </DataProviderContext.Provider>\n        </AuthContext.Provider>\n    );\n};\n\nCoreAdminContext.defaultProps = {\n    dataProvider: defaultDataProvider,\n    store: memoryStore(),\n};\n","import * as React from 'react';\nimport { ReactNode, useMemo } from 'react';\nimport { useInRouterContext } from 'react-router-dom';\nimport { createHashHistory, History } from 'history';\n\nimport { HistoryRouter, HistoryRouterProps } from './HistoryRouter';\nimport { BasenameContextProvider } from './BasenameContextProvider';\n\n/**\n * Creates a react-router Router unless the app is already inside existing router.\n * Also creates a BasenameContext with the basename prop\n */\nexport const AdminRouter = ({\n    history,\n    basename = '',\n    children,\n}: AdminRouterProps) => {\n    const isInRouter = useInRouterContext();\n    const Router = isInRouter ? DummyRouter : InternalRouter;\n\n    return (\n        <BasenameContextProvider basename={isInRouter ? basename : ''}>\n            <Router basename={basename} history={history}>\n                {children}\n            </Router>\n        </BasenameContextProvider>\n    );\n};\n\nexport interface AdminRouterProps {\n    history?: History;\n    basename?: string;\n    children: React.ReactNode;\n}\n\nconst DummyRouter = ({ children }: { children: ReactNode }) => <>{children}</>;\n\nconst InternalRouter = ({\n    children,\n    history,\n}: {\n    history?: History;\n} & Omit<HistoryRouterProps, 'history'>) => {\n    const finalHistory = useMemo(() => history || createHashHistory(), [\n        history,\n    ]);\n\n    return <HistoryRouter history={finalHistory}>{children}</HistoryRouter>;\n};\n","import * as React from 'react';\nimport { useLayoutEffect, useState } from 'react';\nimport { History } from 'history';\nimport { Router } from 'react-router';\n\n/**\n * A router that accepts a custom history.\n * To remove once https://github.com/remix-run/react-router/pull/7586 is merged.\n */\nexport function HistoryRouter({\n    basename,\n    children,\n    history,\n}: HistoryRouterProps) {\n    const [state, setState] = useState({\n        action: history.action,\n        location: history.location,\n    });\n\n    useLayoutEffect(() => history.listen(setState), [history]);\n\n    return (\n        <Router\n            basename={basename}\n            children={children}\n            location={state.location}\n            navigationType={state.action}\n            navigator={history}\n        />\n    );\n}\n\nexport interface HistoryRouterProps {\n    basename?: string;\n    children?: React.ReactNode;\n    history: History;\n}\n","import * as React from 'react';\nimport { BasenameContext } from './BasenameContext';\n\n/**\n * Set the string to append to all links to the admin app.\n *\n * Useful when the app is mounted on a sub path, e.g. '/admin'.\n * Used internally by the `<Admin>` component.\n *\n * @see useBasename\n */\nexport const BasenameContextProvider = ({ children, basename }) => (\n    <BasenameContext.Provider value={basename}>\n        {children}\n    </BasenameContext.Provider>\n);\n","import { createContext } from 'react';\n\nexport const BasenameContext = createContext('');\n","/**\n * @deprecated use useCreatePath instead\n */\nexport const linkToRecord = (resource, id, linkType = 'edit') => {\n    const link = `${resource}/${encodeURIComponent(id)}`;\n\n    if (linkType === 'show') {\n        return `${link}/show`;\n    }\n\n    return link;\n};\n","import { To } from 'react-router-dom';\n\n/**\n * @deprecated use useCreatePath instead\n */\nexport const resolveRedirectTo = (\n    redirectTo,\n    resource: string,\n    id?,\n    data?,\n    basename: string = ''\n): To => {\n    if (typeof redirectTo === 'function') {\n        const target: To = redirectTo(resource, id, data);\n        return typeof target === 'string'\n            ? removeDoubleSlashes(`${basename}/${target}`)\n            : {\n                  pathname: removeDoubleSlashes(\n                      `${basename}/${target.pathname}`\n                  ),\n                  ...target,\n              };\n    }\n    switch (redirectTo) {\n        case 'list':\n            return removeDoubleSlashes(`${basename}/${resource}`);\n        case 'create':\n            return removeDoubleSlashes(`${basename}/${resource}/create`);\n        case 'edit':\n            return removeDoubleSlashes(\n                `${basename}/${resource}/${encodeURIComponent(id)}`\n            );\n        case 'show':\n            return removeDoubleSlashes(\n                `${basename}/${resource}/${encodeURIComponent(id)}/show`\n            );\n        default:\n            return redirectTo;\n    }\n};\n\nconst removeDoubleSlashes = (path: string) => path.replace('//', '/');\n","import { useContext } from 'react';\n\nimport { BasenameContext } from './BasenameContext';\n\n/**\n * Get the string to append to all links to the admin app.\n *\n * Useful when the app is mounted on a sub path, e.g. '/admin'.\n *\n * This hook is used internally by all react-admin components that\n * contain a link, and requires that the basename is set via the\n * `<BasenameContextProvider>` component (or via the `<Admin>` component,\n * which calls BasenameContextProvider internally).\n *\n * @see BasenameContextProvider\n *\n * @example\n * import { useBasename } from 'react-admin';\n *\n * const ArticleLink = ({ title, id }) => {\n *    const basename = useBasename();\n *    return <a href={`${basename}/articles/${id}`}>{title}</a>;\n * };\n */\nexport const useBasename = () => useContext(BasenameContext);\n","import { useCallback } from 'react';\n\nimport { Identifier } from '../types';\nimport { useBasename } from './useBasename';\n\n/**\n * Get a callback to create a link to a given page in the admin app.\n *\n * The callback expects an object as parameter, containing the following properties:\n *   - type: 'list', 'edit', 'show' or 'create'\n *   - resource\n *   - id (optional), for 'edit' or 'show' pages\n *\n * This is used internally by react-admin to allow default components to work\n * in applications that are mounted on a sub path, e.g. '/admin'. If your app\n * is mounted in the root path, you don't need it, and you can create links by\n * hand, e.g. '/articles/1/show'.\n *\n * @example\n * import { useCreatePath, useRecordContext } from 'react-admin';\n * import { useNavigate } from 'react-router-dom';\n *\n * const PostEditButton = () => {\n *     const createPath = useCreatePath();\n *     const record = useRecordContext();\n *     const navigate = useNavigate();\n *\n *     const handleClick = () => {\n *         const link = createPath({\n *            type: 'edit',\n *            resource: 'posts',\n *            id: record.id\n *         });\n *         navigate(link);\n *     };\n *\n *    return <button onClick={handleClick}>Edit Post</button>;\n * };\n */\nexport const useCreatePath = () => {\n    const basename = useBasename();\n    return useCallback(\n        ({ resource, id, type }: CreatePathParams): string => {\n            switch (type) {\n                case 'list':\n                    return removeDoubleSlashes(`${basename}/${resource}`);\n                case 'create':\n                    return removeDoubleSlashes(\n                        `${basename}/${resource}/create`\n                    );\n                case 'edit':\n                    return removeDoubleSlashes(\n                        `${basename}/${resource}/${encodeURIComponent(id)}`\n                    );\n                case 'show':\n                    return removeDoubleSlashes(\n                        `${basename}/${resource}/${encodeURIComponent(id)}/show`\n                    );\n                default:\n                    return type;\n            }\n        },\n        [basename]\n    );\n};\n\nexport interface CreatePathParams {\n    type: string;\n    resource: string;\n    id?: Identifier;\n}\n\nexport const removeDoubleSlashes = (path: string) => path.replace('//', '/');\n","import { useCallback } from 'react';\nimport { useNavigate, To } from 'react-router-dom';\nimport { parsePath } from 'history';\n\nimport { Identifier, RaRecord } from '../types';\nimport { useBasename } from './useBasename';\nimport { useCreatePath } from './useCreatePath';\n\ntype RedirectToFunction = (\n    resource?: string,\n    id?: Identifier,\n    data?: Partial<RaRecord>,\n    state?: object\n) => To;\n\nexport type RedirectionSideEffect = string | false | RedirectToFunction;\n\n/**\n * Hook for Redirection Side Effect\n *\n * @example\n *\n * const redirect = useRedirect();\n * // redirect to list view\n * redirect('list', 'posts');\n * // redirect to edit view\n * redirect('edit', 'posts', 123);\n * // redirect to edit view with state data\n * redirect('edit', 'comments', 123, {}, { record: { post_id: record.id } });\n * // do not redirect\n * redirect(false);\n * // redirect to the result of a function\n * redirect((resource, id, data) => ...)\n */\nexport const useRedirect = () => {\n    const navigate = useNavigate();\n    const basename = useBasename();\n    const createPath = useCreatePath();\n\n    return useCallback(\n        (\n            redirectTo: RedirectionSideEffect,\n            resource: string = '',\n            id?: Identifier,\n            data?: Partial<RaRecord>,\n            state: object = {}\n        ) => {\n            if (!redirectTo) {\n                return;\n            } else if (typeof redirectTo === 'function') {\n                const target: To = redirectTo(resource, id, data);\n                const absoluteTarget =\n                    typeof target === 'string'\n                        ? `${basename}/${target}`\n                        : {\n                              pathname: `${basename}/${target.pathname}`,\n                              ...target,\n                          };\n                navigate(\n                    typeof absoluteTarget === 'string'\n                        ? parsePath(absoluteTarget)\n                        : absoluteTarget,\n                    {\n                        state: { _scrollToTop: true, ...state },\n                    }\n                );\n                return;\n            } else if (\n                typeof redirectTo === 'string' &&\n                redirectTo.startsWith('http') &&\n                window\n            ) {\n                // redirection to an absolute url\n                // history doesn't handle that case, so we handle it by hand\n                window.location.href = redirectTo;\n                return;\n            } else {\n                // redirection to an internal link\n                navigate(createPath({ resource, id, type: redirectTo }), {\n                    state: { _scrollToTop: true, ...state },\n                });\n                return;\n            }\n        },\n        [navigate, basename, createPath]\n    );\n};\n","import { useEffect } from 'react';\nimport { useLocation } from 'react-router-dom';\n\n/**\n * Scroll the window to top when the target location contains the _scrollToTop state\n *\n * @see CoreAdminRouter where it's enabled by default\n *\n * @example // usage in buttons\n * import { Link } from 'react-router-dom';\n * import { Button } from '@mui/material';\n *\n * const FooButton = () => (\n *     <Button\n *         component={Link}\n *         to={{\n *             pathname: '/foo',\n *             state: { _scrollToTop: true },\n *         }}\n *     >\n *         Go to foo\n *     </Button>\n * );\n */\nexport const useScrollToTop = () => {\n    const location = useLocation();\n    useEffect(() => {\n        if (\n            (location.state as any)?._scrollToTop &&\n            typeof window != 'undefined'\n        ) {\n            window.scrollTo(0, 0);\n        }\n    }, [location]);\n};\n","import { createContext } from 'react';\n\nimport { AuthProvider, UserIdentity } from '../types';\n\nconst defaultIdentity: UserIdentity = { id: '' };\n\nconst defaultProvider: AuthProvider = {\n    login: () => Promise.resolve(),\n    logout: () => Promise.resolve(),\n    checkAuth: () => Promise.resolve(),\n    checkError: () => Promise.resolve(),\n    getPermissions: () => Promise.resolve(),\n    getIdentity: () => Promise.resolve(defaultIdentity),\n};\n\nconst AuthContext = createContext<AuthProvider>(defaultProvider);\n\nAuthContext.displayName = 'AuthContext';\n\nexport default AuthContext;\n","import { useContext } from 'react';\n\nimport { AuthProvider } from '../types';\nimport AuthContext from './AuthContext';\n\nexport const defaultAuthParams = {\n    loginUrl: '/login',\n    afterLoginUrl: '/',\n};\n\n/**\n * Get the authProvider stored in the context\n */\nconst useAuthProvider = (): AuthProvider => useContext(AuthContext);\n\nexport default useAuthProvider;\n","import { useEffect } from 'react';\n\nimport { useCheckAuth } from './useCheckAuth';\nimport { useSafeSetState } from '../util/hooks';\n\ninterface State {\n    isLoading: boolean;\n    authenticated?: boolean;\n}\n\nconst emptyParams = {};\n\n/**\n * Hook for getting the authentication status\n *\n * Calls the authProvider.checkAuth() method asynchronously.\n *\n * The return value updates according to the authProvider request state:\n *\n * - isLoading: true just after mount, while the authProvider is being called. false once the authProvider has answered.\n * - authenticated: true while loading. then true or false depending on the authProvider response.\n *\n * To avoid rendering a component and force waiting for the authProvider response, use the useAuthState() hook\n * instead of the useAuthenticated() hook.\n *\n * You can render different content depending on the authenticated status.\n *\n * @see useAuthenticated()\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @returns The current auth check state. Destructure as { authenticated, error, isLoading }.\n *\n * @example\n * import { useAuthState, Loading } from 'react-admin';\n *\n * const MyPage = () => {\n *     const { isLoading, authenticated } = useAuthState();\n *     if (isLoading) {\n *         return <Loading />;\n *     }\n *     if (authenticated) {\n *        return <AuthenticatedContent />;\n *     }\n *     return <AnonymousContent />;\n * };\n */\nconst useAuthState = (params: any = emptyParams): State => {\n    const [state, setState] = useSafeSetState({\n        isLoading: true,\n        authenticated: true, // optimistic\n    });\n    const checkAuth = useCheckAuth();\n    useEffect(() => {\n        checkAuth(params, false)\n            .then(() => setState({ isLoading: false, authenticated: true }))\n            .catch(() => setState({ isLoading: false, authenticated: false }));\n    }, [checkAuth, params, setState]);\n    return state;\n};\n\nexport default useAuthState;\n","import { useCallback } from 'react';\n\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport useLogout from './useLogout';\nimport { useNotify } from '../notification';\nimport { useBasename } from '../routing';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n\n/**\n * Get a callback for calling the authProvider.checkAuth() method.\n * In case of rejection, redirects to the login page, displays a notification,\n * and throws an error.\n *\n * This is a low level hook. See those more specialized hooks\n * for common authentication tasks, based on useCheckAuth.\n *\n * @see useAuthenticated\n * @see useAuthState\n *\n * @returns {Function} checkAuth callback\n *\n * @example\n *\n * import { useCheckAuth } from 'react-admin';\n *\n * const MyProtectedPage = () => {\n *     const checkAuth = useCheckAuth();\n *     useEffect(() => {\n *         checkAuth().catch(() => {});\n *     }, []);\n *     return <p>Private content: EZAEZEZAET</p>\n * } // tip: use useAuthenticated() hook instead\n *\n * const MyPage = () => {\n *     const checkAuth = useCheckAuth();\n *     const [authenticated, setAuthenticated] = useState(true); // optimistic auth\n *     useEffect(() => {\n *         checkAuth({}, false)\n *              .then(() => setAuthenticated(true))\n *              .catch(() => setAuthenticated(false));\n *     }, []);\n *     return authenticated ? <Bar /> : <BarNotAuthenticated />;\n * } // tip: use useAuthState() hook instead\n */\nexport const useCheckAuth = (): CheckAuth => {\n    const authProvider = useAuthProvider();\n    const notify = useNotify();\n    const logout = useLogout();\n    const basename = useBasename();\n    const loginUrl = removeDoubleSlashes(\n        `${basename}/${defaultAuthParams.loginUrl}`\n    );\n\n    const checkAuth = useCallback(\n        (\n            params: any = {},\n            logoutOnFailure = true,\n            redirectTo = loginUrl,\n            disableNotification = false\n        ) =>\n            authProvider.checkAuth(params).catch(error => {\n                if (logoutOnFailure) {\n                    logout(\n                        {},\n                        error && error.redirectTo\n                            ? error.redirectTo\n                            : redirectTo\n                    );\n                    const shouldSkipNotify =\n                        disableNotification ||\n                        (error && error.message === false);\n                    !shouldSkipNotify &&\n                        notify(\n                            getErrorMessage(error, 'ra.auth.auth_check_error'),\n                            { type: 'warning' }\n                        );\n                }\n                throw error;\n            }),\n        [authProvider, logout, notify, loginUrl]\n    );\n\n    return authProvider ? checkAuth : checkAuthWithoutAuthProvider;\n};\n\nconst checkAuthWithoutAuthProvider = () => Promise.resolve();\n\n/**\n * Check if the current user is authenticated by calling authProvider.checkAuth().\n * Logs the user out on failure.\n *\n * @param {Object} params The parameters to pass to the authProvider\n * @param {boolean} logoutOnFailure Whether the user should be logged out if the authProvider fails to authenticate them. True by default.\n * @param {string} redirectTo The login form url. Defaults to '/login'\n * @param {boolean} disableNotification Avoid showing a notification after the user is logged out. false by default.\n *\n * @return {Promise} Resolved to the authProvider response if the user passes the check, or rejected with an error otherwise\n */\nexport type CheckAuth = (\n    params?: any,\n    logoutOnFailure?: boolean,\n    redirectTo?: string,\n    /** @deprecated to disable the notification, authProvider.checkAuth() should return an object with an error property set to true */\n    disableNotification?: boolean\n) => Promise<any>;\n\nconst getErrorMessage = (error, defaultMessage) =>\n    typeof error === 'string'\n        ? error\n        : typeof error === 'undefined' || !error.message\n        ? defaultMessage\n        : error.message;\n","import { useCallback, useEffect, useRef } from 'react';\nimport { useLocation, useNavigate, Path } from 'react-router-dom';\n\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { useResetStore } from '../store';\nimport { useBasename } from '../routing';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n\n/**\n * Get a callback for calling the authProvider.logout() method,\n * redirect to the login page, and clear the store.\n *\n * @see useAuthProvider\n *\n * @returns {Function} logout callback\n *\n * @example\n *\n * import { useLogout } from 'react-admin';\n *\n * const LogoutButton = () => {\n *     const logout = useLogout();\n *     const handleClick = () => logout();\n *     return <button onClick={handleClick}>Logout</button>;\n * }\n */\nconst useLogout = (): Logout => {\n    const authProvider = useAuthProvider();\n    const resetStore = useResetStore();\n    const navigate = useNavigate();\n    // useNavigate forces rerenders on every navigation, even if we don't use the result\n    // see https://github.com/remix-run/react-router/issues/7634\n    // so we use a ref to bail out of rerenders when we don't need to\n    const navigateRef = useRef(navigate);\n    const location = useLocation();\n    const locationRef = useRef(location);\n    const basename = useBasename();\n    const loginUrl = removeDoubleSlashes(\n        `${basename}/${defaultAuthParams.loginUrl}`\n    );\n\n    /*\n     * We need the current location to pass in the router state\n     * so that the login hook knows where to redirect to as next route after login.\n     *\n     * But if we used the location from useLocation as a dependency of the logout\n     * function, it would be rebuilt each time the user changes location.\n     * Consequently, that would force a rerender of all components using this hook\n     * upon navigation (CoreAdminRouter for example).\n     *\n     * To avoid that, we store the location in a ref.\n     */\n    useEffect(() => {\n        locationRef.current = location;\n        navigateRef.current = navigate;\n    }, [location, navigate]);\n\n    const logout = useCallback(\n        (\n            params = {},\n            redirectTo = loginUrl,\n            redirectToCurrentLocationAfterLogin = true\n        ) =>\n            authProvider.logout(params).then(redirectToFromProvider => {\n                if (redirectToFromProvider === false) {\n                    resetStore();\n                    // do not redirect\n                    return;\n                }\n                // redirectTo can contain a query string, e.g. '/login?foo=bar'\n                // we must split the redirectTo to pass a structured location to navigate()\n                const redirectToParts = (\n                    redirectToFromProvider || redirectTo\n                ).split('?');\n                const newLocation: Partial<Path> = {\n                    pathname: redirectToParts[0],\n                };\n                let newLocationOptions = {};\n\n                if (\n                    redirectToCurrentLocationAfterLogin &&\n                    locationRef.current &&\n                    locationRef.current.pathname\n                ) {\n                    newLocationOptions = {\n                        state: {\n                            nextPathname: locationRef.current.pathname,\n                            nextSearch: locationRef.current.search,\n                        },\n                    };\n                }\n                if (redirectToParts[1]) {\n                    newLocation.search = redirectToParts[1];\n                }\n                navigateRef.current(newLocation, newLocationOptions);\n                resetStore();\n\n                return redirectToFromProvider;\n            }),\n        [authProvider, resetStore, loginUrl]\n    );\n\n    const logoutWithoutProvider = useCallback(\n        _ => {\n            navigate(\n                {\n                    pathname: loginUrl,\n                },\n                {\n                    state: {\n                        nextPathname: location && location.pathname,\n                    },\n                }\n            );\n            resetStore();\n            return Promise.resolve();\n        },\n        [resetStore, location, navigate, loginUrl]\n    );\n\n    return authProvider ? logout : logoutWithoutProvider;\n};\n\n/**\n * Log the current user out by calling the authProvider.logout() method,\n * and redirect them to the login screen.\n *\n * @param {Object} params The parameters to pass to the authProvider\n * @param {string} redirectTo The path name to redirect the user to (optional, defaults to login)\n * @param {boolean} redirectToCurrentLocationAfterLogin Whether the button shall record the current location to redirect to it after login. true by default.\n *\n * @return {Promise} The authProvider response\n */\ntype Logout = (\n    params?: any,\n    redirectTo?: string,\n    redirectToCurrentLocationAfterLogin?: boolean\n) => Promise<any>;\n\nexport default useLogout;\n","import { Store } from './types';\n\ntype Subscription = {\n    key: string;\n    callback: (value: any) => void;\n};\n\nconst RA_STORE = 'RaStore';\nconst prefixLength = RA_STORE.length;\n\n// localStorage isn't available in incognito mode. We need to detect it\nconst testLocalStorage = () => {\n    // eslint-disable-next-line eqeqeq\n    if (typeof window === 'undefined' || window.localStorage == undefined) {\n        return false;\n    }\n\n    try {\n        window.localStorage.setItem('test', 'test');\n        window.localStorage.removeItem('test');\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\nlet localStorageAvailable = testLocalStorage();\n\n/**\n * Store using localStorage, or memory storage in incognito mode\n *\n * @example\n *\n * import { localStorageProvider } from 'react-admin';\n *\n * const App = () => (\n *    <Admin store={localStorageProvider()}>\n *       ...\n *   </Admin>\n * );\n */\nexport const localStorageStore = (version: string = '1'): Store => {\n    const subscriptions: { [key: string]: Subscription } = {};\n    const publish = (key: string, value: any) => {\n        Object.keys(subscriptions).forEach(id => {\n            if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n            if (subscriptions[id].key === key) {\n                subscriptions[id].callback(value);\n            }\n        });\n    };\n\n    // Whenever the local storage changes in another document, look for matching subscribers.\n    // This allows to synchronize state across tabs\n    const onLocalStorageChange = (event: StorageEvent): void => {\n        if (event.key.substring(0, prefixLength) !== RA_STORE) {\n            return;\n        }\n        const key = event.key.substring(prefixLength + 1);\n        const value = tryParse(event.newValue);\n        Object.keys(subscriptions).forEach(id => {\n            if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n            if (subscriptions[id].key === key) {\n                if (value === null) {\n                    // an event with a null value is sent when the key is deleted.\n                    // to enable default value, we need to call setValue(undefined) instead of setValue(null)\n                    subscriptions[id].callback(undefined);\n                } else {\n                    subscriptions[id].callback(\n                        value == null ? undefined : value\n                    );\n                }\n            }\n        });\n    };\n\n    return {\n        setup: () => {\n            if (localStorageAvailable) {\n                const storedVersion = getStorage().getItem(\n                    `${RA_STORE}.version`\n                );\n                if (storedVersion && storedVersion !== version) {\n                    getStorage().clear();\n                }\n                getStorage().setItem(`${RA_STORE}.version`, version);\n                window.addEventListener('storage', onLocalStorageChange);\n            }\n        },\n        teardown: () => {\n            if (localStorageAvailable) {\n                window.removeEventListener('storage', onLocalStorageChange);\n            }\n        },\n        getItem<T = any>(key: string, defaultValue?: T): T {\n            const valueFromStorage = tryParse(\n                getStorage().getItem(`${RA_STORE}.${key}`)\n            );\n            // eslint-disable-next-line eqeqeq\n            return valueFromStorage == null ? defaultValue : valueFromStorage;\n        },\n        setItem<T = any>(key: string, value: T): void {\n            if (value === undefined) {\n                getStorage().removeItem(`${RA_STORE}.${key}`);\n            } else {\n                getStorage().setItem(\n                    `${RA_STORE}.${key}`,\n                    JSON.stringify(value)\n                );\n            }\n            publish(key, value);\n        },\n        removeItem(key: string): void {\n            getStorage().removeItem(`${RA_STORE}.${key}`);\n            publish(key, undefined);\n        },\n        reset(): void {\n            const storage = getStorage();\n            for (let i = 0; i < storage.length; i++) {\n                if (storage.key(i).substring(0, prefixLength) === RA_STORE) {\n                    const key = storage.key(i).substring(prefixLength + 1);\n                    storage.removeItem(storage.key(i));\n                    publish(key, undefined);\n                }\n            }\n        },\n        subscribe: (key: string, callback: (value: string) => void) => {\n            const id = Math.random().toString();\n            subscriptions[id] = {\n                key,\n                callback,\n            };\n            return () => {\n                delete subscriptions[id];\n            };\n        },\n    };\n};\n\nconst tryParse = (value: string): any => {\n    try {\n        return JSON.parse(value);\n    } catch (e) {\n        return value;\n    }\n};\nclass LocalStorageShim {\n    valuesMap: any = new Map();\n\n    getItem(key: string) {\n        if (this.valuesMap.has(key)) {\n            return String(this.valuesMap.get(key));\n        }\n        return null;\n    }\n\n    setItem(key: string, value: string) {\n        this.valuesMap.set(key, value);\n    }\n\n    removeItem(key: string) {\n        this.valuesMap.delete(key);\n    }\n\n    clear() {\n        this.valuesMap.clear();\n    }\n\n    key(i): string {\n        if (arguments.length === 0) {\n            throw new TypeError(\n                \"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"\n            ); // this is a TypeError implemented on Chrome, Firefox throws Not enough arguments to Storage.key.\n        }\n        const arr = Array.from(this.valuesMap.keys()) as string[];\n        return arr[i];\n    }\n\n    get length() {\n        return this.valuesMap.size;\n    }\n}\nconst memoryStorage = new LocalStorageShim();\n\nexport const getStorage = () => {\n    return localStorageAvailable ? window.localStorage : memoryStorage;\n};\n","import set from 'lodash/set';\nimport unset from 'lodash/unset';\nimport get from 'lodash/get';\nimport { Store } from './types';\n\ntype Subscription = {\n    key: string;\n    callback: (value: any) => void;\n};\n\n/**\n * Store using memory\n *\n * @example\n *\n * import { memoryStore } from 'react-admin';\n *\n * const App = () => (\n *    <Admin store={memoryStore()}>\n *       ...\n *   </Admin>\n * );\n */\nexport const memoryStore = (storage: any = {}): Store => {\n    const subscriptions: { [key: string]: Subscription } = {};\n    const publish = (key: string, value: any) => {\n        Object.keys(subscriptions).forEach(id => {\n            if (!subscriptions[id]) return; // may happen if a component unmounts after a first subscriber was notified\n            if (subscriptions[id].key === key) {\n                subscriptions[id].callback(value);\n            }\n        });\n    };\n    return {\n        setup: () => {},\n        teardown: () => {\n            Object.keys(storage).forEach(key => delete storage[key]);\n        },\n        getItem<T = any>(key: string, defaultValue?: T): T {\n            return get(storage, key, defaultValue);\n        },\n        setItem<T = any>(key: string, value: T): void {\n            set(storage, key, value);\n            publish(key, value);\n        },\n        removeItem(key: string): void {\n            unset(storage, key);\n            publish(key, undefined);\n        },\n        reset(): void {\n            Object.keys(storage).forEach(key => {\n                unset(storage, key);\n                publish(key, undefined);\n            });\n        },\n        subscribe: (key: string, callback: (value: string) => void) => {\n            const id = Math.random().toString();\n            subscriptions[id] = {\n                key,\n                callback,\n            };\n            return () => {\n                delete subscriptions[id];\n            };\n        },\n    };\n};\n","import { createContext } from 'react';\n\nimport { Store } from './types';\nimport { memoryStore } from './memoryStore';\n\nconst defaultStore = memoryStore();\n\nexport const StoreContext = createContext<Store>(defaultStore);\n","import * as React from 'react';\nimport { useEffect } from 'react';\nimport { StoreContext } from './StoreContext';\nimport { Store } from './types';\n\nexport const StoreContextProvider = ({\n    value: Store,\n    children,\n}: StoreContextProviderProps) => {\n    useEffect(() => {\n        Store.setup();\n        return () => {\n            Store.teardown();\n        };\n    }, [Store]);\n\n    return (\n        <StoreContext.Provider value={Store}>{children}</StoreContext.Provider>\n    );\n};\n\nexport interface StoreContextProviderProps {\n    value: Store;\n    children: React.ReactNode;\n}\n","import * as React from 'react';\nimport { useEffect, ReactNode } from 'react';\nimport { useStoreContext } from './useStoreContext';\n\n/**\n * A component to set store state for a key on mount declaratively\n *\n * To use it, just wrap any component that need to use the corresponding\n * store item with <StoreSetter name=\"my.key\" value=\"myvalue\">.\n * This wrapping needs to be done to ensure that the corresponding store item\n * is set before rendering the wrapped component.\n *\n * Tip: <StoreSetter> is a great helper for mocking the store in\n * unit tests. Prefer it to calling the Store manually.\n *\n * @example\n *\n *     <StoreSetter name=\"list.density\" value=\"small\">\n *         <MyStoreDependentComponent />\n *     </StoreSetter>\n *\n * @example // Using <StoreSetter> is equivalent to using `useStoreContext` and setting its value directly.\n *\n * const [, setDensity] = useStore('list.density');\n *\n * useEffect(() => {\n *     setDensity('small');\n * }, []);\n *\n * @param {Props}    props\n * @param {string}   props.name Store item key. Required. Separate with dots to namespace, e.g. 'posts.list.columns'\n * @param {any}      props.value Store item value. Required.\n * @param {children} props.children Children are rendered as is, on mount\n */\nexport const StoreSetter = ({ value, name, children }: StoreSetterProps) => {\n    const { setItem } = useStoreContext();\n\n    useEffect(() => {\n        setItem(name, value);\n    }, [name, setItem, value]);\n\n    return <>{children}</>;\n};\n\nexport interface StoreSetterProps {\n    name: string;\n    value: any;\n    children: ReactNode;\n}\n","import { useContext } from 'react';\n\nimport { StoreContext } from './StoreContext';\n\n/**\n * Get the Store stored in the StoreContext\n */\nexport const useStoreContext = () => useContext(StoreContext);\n","import { useState, useEffect } from 'react';\n\nimport { useEventCallback } from '../util';\nimport { useStoreContext } from './useStoreContext';\n\n/**\n * Read and write a value from the Store\n *\n * useState-like hook using the global Store for persistence.\n * Each time a store value is changed, all components using this value will be re-rendered.\n *\n * @param {string} key Name of the store key. Separate with dots to namespace, e.g. 'posts.list.columns'.\n * @param {any} defaultValue Default value\n *\n * @return {Object} A value and a setter for the value, in an array - just like for useState()\n *\n * @example\n * import { useStore } from 'react-admin';\n *\n * const PostList = props => {\n *     const [density] = useStore('posts.list.density', 'small');\n *\n *     return (\n *         <List {...props}>\n *             <Datagrid size={density}>\n *                 ...\n *             </Datagrid>\n *         </List>\n *     );\n * }\n *\n * // Clicking on this button will trigger a rerender of the PostList!\n * const ChangeDensity: FC<any> = () => {\n *     const [density, setDensity] = useStore('posts.list.density', 'small');\n *\n *     const changeDensity = (): void => {\n *         setDensity(density === 'small' ? 'medium' : 'small');\n *     };\n *\n *     return (\n *         <Button onClick={changeDensity}>\n *             {`Change density (current ${density})`}\n *         </Button>\n *     );\n * };\n */\nexport const useStore = <T = any>(\n    key: string,\n    defaultValue?: T\n): useStoreResult<T> => {\n    const { getItem, setItem, subscribe } = useStoreContext();\n    const [value, setValue] = useState(() => getItem(key, defaultValue));\n\n    // subscribe to changes on this key, and change the state when they happen\n    useEffect(() => {\n        const unsubscribe = subscribe(key, newValue => {\n            setValue(typeof newValue === 'undefined' ? defaultValue : newValue);\n        });\n        return () => unsubscribe();\n    }, [key, subscribe, defaultValue]);\n\n    const set = useEventCallback(\n        (valueParam: T, runtimeDefaultValue: T) => {\n            const newValue =\n                typeof valueParam === 'function'\n                    ? valueParam(value)\n                    : valueParam;\n            // we only set the value in the Store;\n            // the value in the local state will be updated\n            // by the useEffect during the next render\n            setItem(\n                key,\n                typeof newValue === 'undefined'\n                    ? typeof runtimeDefaultValue === 'undefined'\n                        ? defaultValue\n                        : runtimeDefaultValue\n                    : newValue\n            );\n        },\n        [key, setItem, defaultValue, value]\n    );\n    return [value, set];\n};\n\nexport type useStoreResult<T = any> = [\n    T,\n    (value: T | ((value: T) => void), defaultValue?: T) => void\n];\n","/**\n * Escape special characters in path so that react-router Route does not do any special treatment\n *\n * @see https://github.com/ReactTraining/react-router/blob/v3/docs/guides/RouteMatching.md#path-syntax\n *\n * @example\n *\n * escapePath('/foo(bar)') => 'foo\\(bar\\)'\n */\nexport default url => url.replace(/(\\(|\\))/g, '\\\\$1');\n","import * as React from 'react';\nimport { ReactElement, memo } from 'react';\n\nimport { useTranslate } from '../i18n';\nimport getFieldLabelTranslationArgs from './getFieldLabelTranslationArgs';\nimport { useResourceContext } from '../core/useResourceContext';\n\nexport interface FieldTitleProps {\n    isRequired?: boolean;\n    resource?: string;\n    source?: string;\n    label?: string | ReactElement | false;\n}\n\nexport const FieldTitle = (props: FieldTitleProps) => {\n    const { source, label, isRequired } = props;\n    const resource = useResourceContext(props);\n    const translate = useTranslate();\n\n    if (label === false || label === '') {\n        return null;\n    }\n\n    if (label && typeof label !== 'string') {\n        return label;\n    }\n\n    return (\n        <span>\n            {translate(\n                ...getFieldLabelTranslationArgs({\n                    label: label as string,\n                    resource,\n                    source,\n                })\n            )}\n            {isRequired && <span aria-hidden=\"true\">&thinsp;*</span>}\n        </span>\n    );\n};\n\n// What? TypeScript loses the displayName if we don't set it explicitly\nFieldTitle.displayName = 'FieldTitle';\n\nexport default memo(FieldTitle);\n","import * as React from 'react';\nimport lodashGet from 'lodash/get';\n\nimport { I18nContextProvider } from './I18nContextProvider';\n\nexport const TestTranslationProvider = ({\n    translate,\n    messages,\n    children,\n}: any) => (\n    <I18nContextProvider\n        value={{\n            translate: messages\n                ? (key: string, options?: any) => {\n                      const message = lodashGet(messages, key);\n                      return message\n                          ? typeof message === 'function'\n                              ? message(options)\n                              : message\n                          : options._;\n                  }\n                : translate,\n            changeLocale: () => Promise.resolve(),\n            getLocale: () => 'en',\n        }}\n    >\n        {children}\n    </I18nContextProvider>\n);\n","import * as React from 'react';\nimport { useEffect, useState, ReactNode } from 'react';\n\nimport { I18nContext } from './I18nContext';\nimport { useStore } from '../store/useStore';\nimport { useNotify } from '../notification';\nimport { I18nProvider } from '../types';\n\n/**\n * Store the i18nProvider in a context, and rerender children when the locale changes\n */\nexport const I18nContextProvider = ({\n    value = defaulti18nContext,\n    children,\n}: I18nContextProviderProps) => {\n    const [locale] = useStore('locale');\n    const notify = useNotify();\n    const [key, setKey] = useState(0);\n    // to avoid blinking effect, delay first render if the user has a non-default locale\n    const [isInitialized, setInitialized] = useState(\n        locale === value.getLocale()\n    );\n\n    // watch store for locale changes\n    useEffect(() => {\n        if (locale && value.getLocale() !== locale) {\n            new Promise(resolve => {\n                // so we systematically return a Promise for the messages\n                // i18nProvider may return a Promise for language changes,\n                resolve(value.changeLocale(locale));\n            })\n                .then(() => {\n                    // Force full page re-render.\n                    // This is slow on locale change, but it's a good way\n                    // to avoid having one subscription to the locale\n                    // for each call to translate()\n                    setKey(key => key + 1);\n                    setInitialized(true);\n                })\n                .catch(error => {\n                    setInitialized(true);\n                    notify('ra.notification.i18n_error', { type: 'warning' });\n                    console.error(error);\n                });\n        } else {\n            setInitialized(true);\n        }\n    }, [value, locale, notify]);\n\n    return isInitialized ? (\n        <I18nContext.Provider value={value} key={key}>\n            {children}\n        </I18nContext.Provider>\n    ) : null;\n};\n\nexport interface I18nContextProviderProps {\n    value: I18nProvider;\n    children: ReactNode;\n}\n\nconst defaulti18nContext = {\n    translate: x => x,\n    changeLocale: () => Promise.resolve(),\n    getLocale: () => 'en',\n};\n","import { createContext } from 'react';\nimport { I18nProvider } from '../types';\n\nexport type I18nContextProps = I18nProvider;\n\nexport const I18nContext = createContext<I18nProvider>({\n    translate: x => x,\n    changeLocale: () => Promise.resolve(),\n    getLocale: () => 'en',\n});\n\nI18nContext.displayName = 'I18nContext';\n","import { useCallback } from 'react';\n\nimport { useNotificationContext } from './useNotificationContext';\nimport { NotificationType, NotificationOptions } from './types';\n\n/**\n * Hook for Notification Side Effect\n *\n * @example\n *\n * const notify = useNotify();\n * // simple message (info level)\n * notify('Level complete');\n * // specify level\n * notify('A problem occurred', { type: 'warning' })\n * // pass arguments to the translation function\n * notify('Deleted %{count} elements', { type: 'info', messageArgs: { smart_count: 23 } })\n * // show the action as undoable in the notification\n * notify('Post renamed', { type: 'info', undoable: true })\n */\nexport const useNotify = () => {\n    const { addNotification } = useNotificationContext();\n    return useCallback(\n        (\n            message: string,\n            options: NotificationOptions & { type?: NotificationType } = {}\n        ) => {\n            const {\n                type: messageType = 'info',\n                ...notificationOptions\n            } = options;\n            addNotification({\n                message,\n                type: messageType,\n                notificationOptions,\n            });\n        },\n        [addNotification]\n    );\n};\n","import { useContext } from 'react';\nimport { NotificationContext } from './NotificationContext';\n\nexport const useNotificationContext = () => useContext(NotificationContext);\n","import { createContext } from 'react';\n\nimport { NotificationPayload } from './types';\n\nexport type NotificationContextType = {\n    notifications: NotificationPayload[];\n    addNotification: (notification: NotificationPayload) => void;\n    takeNotification: () => NotificationPayload | void;\n    resetNotifications: () => void;\n};\n\n/**\n * Context for the notification state and modifiers\n *\n * @example // display notifications\n * import { useNotificationContext } from 'react-admin';\n *\n * const App = () => {\n *    const { notifications } = useNotificationContext();\n *    return (\n *        <ul>\n *            {notifications.map(({ message }) => (\n *                <li key={index}>{ message }</li>\n *            ))}\n *        </ul>\n *    );\n * };\n *\n * @example // reset notifications\n * import { useNotificationContext } from 'react-admin';\n *\n * const ResetNotificationsButton = () => {\n *    const { resetNotifications } = useNotificationContext();\n *    return (\n *        <button onClick={() => resetNotifications()}>Reset notifications</button>\n *    );\n * };\n */\nexport const NotificationContext = createContext<NotificationContextType>({\n    notifications: [],\n    addNotification: () => {},\n    takeNotification: () => {},\n    resetNotifications: () => {},\n});\n","import * as React from 'react';\nimport { useState, useCallback, useMemo } from 'react';\n\nimport { NotificationPayload } from './types';\nimport { NotificationContext } from './NotificationContext';\n\nexport const NotificationContextProvider = ({ children }) => {\n    const [notifications, setNotifications] = useState<NotificationPayload[]>(\n        []\n    );\n\n    const addNotification = useCallback((notification: NotificationPayload) => {\n        setNotifications(notifications => [...notifications, notification]);\n    }, []);\n\n    const takeNotification = useCallback(() => {\n        const [notification, ...rest] = notifications;\n        setNotifications(rest);\n        return notification;\n    }, [notifications]);\n\n    const resetNotifications = useCallback(() => {\n        setNotifications([]);\n    }, []);\n\n    const contextValue = useMemo(\n        () => ({\n            notifications,\n            addNotification,\n            takeNotification,\n            resetNotifications,\n        }),\n        [notifications] // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    return (\n        <NotificationContext.Provider value={contextValue}>\n            {children}\n        </NotificationContext.Provider>\n    );\n};\n","import { createContext } from 'react';\n\nexport const TranslatableContext = createContext<TranslatableContextValue>(\n    undefined\n);\n\nexport interface TranslatableContextValue {\n    getLabel: GetTranslatableLabel;\n    getSource: GetTranslatableSource;\n    locales: string[];\n    selectedLocale: string;\n    selectLocale: SelectTranslatableLocale;\n}\n\nexport type GetTranslatableSource = (field: string, locale?: string) => string;\nexport type GetTranslatableLabel = (field: string, label?: string) => string;\nexport type SelectTranslatableLocale = (locale: string) => void;\n","import * as React from 'react';\nimport { ReactElement, ReactNode } from 'react';\nimport {\n    TranslatableContext,\n    TranslatableContextValue,\n} from './TranslatableContext';\n\nexport const TranslatableContextProvider = ({\n    children,\n    value,\n}: {\n    children: ReactNode;\n    value: TranslatableContextValue;\n}): ReactElement => {\n    return (\n        <TranslatableContext.Provider value={value}>\n            {children}\n        </TranslatableContext.Provider>\n    );\n};\n","import merge from 'lodash/merge';\nimport { DEFAULT_LOCALE } from './index';\n\ninterface AllNavigatorLanguage extends NavigatorLanguage {\n    browserLanguage?: string;\n    userLanguage?: string;\n}\n\n/**\n * Resolve the browser locale according to the value of the global window.navigator\n *\n * Use it to determine the <Admin> locale at runtime.\n *\n * @example\n *    import * as React from \"react\";\n *    import { Admin, Resource, resolveBrowserLocale } from 'react-admin';\n *    import polyglotI18nProvider from 'ra-i18n-polyglot';\n *    import englishMessages from 'ra-language-english';\n *    import frenchMessages from 'ra-language-french';\n *\n *    const messages = {\n *        fr: frenchMessages,\n *        en: englishMessages,\n *    };\n *    const i18nProvider = polyglotI18nProvider(\n *        locale => messages[locale] ? messages[locale] : messages.en,\n *        resolveBrowserLocale()\n *    );\n *\n *    const App = () => (\n *        <Admin i18nProvider={i18nProvider}>\n *            ...\n *        </Admin>\n *    );\n *\n * @param {string} defaultLocale Defaults to 'en'\n * @param options\n * @param {boolean} options.fullLocale Defaults to false\n */\nexport const resolveBrowserLocale = (\n    defaultLocale?: string,\n    options?: { fullLocale?: boolean }\n): string => {\n    // from http://blog.ksol.fr/user-locale-detection-browser-javascript/\n    // Rely on the window.navigator object to determine user locale\n    const {\n        language,\n        browserLanguage,\n        userLanguage,\n    } = window.navigator as AllNavigatorLanguage;\n\n    const locale =\n        language ||\n        browserLanguage ||\n        userLanguage ||\n        defaultLocale ||\n        DEFAULT_LOCALE;\n\n    return options?.fullLocale ? locale : locale.split('-')[0];\n};\n\n/**\n * Compose translations from multiple packages for a single language (eg: 'english').\n *\n * Use it to merge translations from addons with the main react-admin translations.\n *\n * @example\n *     import * as React from \"react\";\n *     import { Admin, Resource, mergeTranslations } from 'react-admin';\n *     import polyglotI18nProvider from 'ra-i18n-polyglot';\n *     import englishMessages from 'ra-language-english';\n *     import englishTreeMessages from 'ra-tree-language-english';\n *\n *     const messages = {\n *        en: mergeTranslations(englishMessages, englishTreeMessages),\n *     };\n *     const i18nProvider = polyglotI18nProvider(\n *        locale => messages[locale] ? messages[locale] : messages.en\n *    );\n *\n *    const App = () => (\n *        <Admin i18nProvider={i18nProvider}>\n *            ...\n *        </Admin>\n *    );\n */\nexport const mergeTranslations = (...translationsModules: object[]) =>\n    merge({}, ...translationsModules);\n","import { useMemo } from 'react';\nimport { useI18nProvider } from './useI18nProvider';\nimport { useStore } from '../store/useStore';\n\n/**\n * Get the current locale and the ability to change it\n *\n * @example\n *\n * import { useLocaleState } from 'react-admin';\n *\n * const availableLanguages = {\n *     en: 'English',\n *     fr: 'Franais',\n * }\n * const LocaleSwitcher = () => {\n *     const [locale, setLocale] = useLocaleState();\n *     return (\n *         <div>\n *             <div>Language</div>\n *             <Button disabled={locale === 'fr'} onClick={() => setLocale('fr')}>\n *                 English\n *             </Button>\n *             <Button disabled={locale === 'en'} onClick={() => setLocale('en')}>\n *                 French\n *             </Button>\n *         </div>\n *     );\n * };\n */\nexport const useLocaleState = () => {\n    const i18nProvider = useI18nProvider();\n    const defaultLocale = useMemo(() => i18nProvider.getLocale(), [\n        i18nProvider,\n    ]);\n    return useStore<string>('locale', defaultLocale);\n};\n","import { useContext } from 'react';\n\nimport { I18nContext } from './I18nContext';\n\n/**\n * Get the i18nProvider instance declared in the <Admin> component\n *\n * @example\n *\n * const CurrentLanguage = () => {\n *    const i18nProvider = useI18nProvider();\n *    const locale = i18nProvider.getLocale();\n *    return <span>{locale}</span>;\n * };\n */\nexport const useI18nProvider = () => useContext(I18nContext);\n","import { useLocaleState } from './useLocaleState';\n\n/**\n * Get the current locale\n *\n * @example\n *\n * import { useLocale } from 'react-admin';\n *\n * const availableLanguages = {\n *     en: 'English',\n *     fr: 'Franais',\n * }\n * const CurrentLanguage = () => {\n *     const locale = useLocale();\n *     return <span>{availableLanguages[locale]}</span>;\n * }\n *\n * @deprecated use useLocaleState instead\n */\nexport const useLocale = () => {\n    const [locale] = useLocaleState();\n    return locale;\n};\n","import { useLocaleState } from './useLocaleState';\n\n/**\n * Set the current locale in the I18nContext and re-render the app when the locale changes.\n *\n * @example\n *\n * import { useSetLocale } from 'react-admin';\n *\n * const availableLanguages = {\n *     en: 'English',\n *     fr: 'Franais',\n * }\n * const LanguageSwitcher = () => {\n *     const setLocale = useSetLocale();\n *     return (\n *         <ul>{\n *             Object.keys(availableLanguages).map(locale => {\n *                  <li key={locale} onClick={() => setLocale(locale)}>\n *                      {availableLanguages[locale]}\n *                  </li>\n *              })\n *         }</ul>\n *     );\n * }\n *\n * @deprecated use useLocaleState instead\n */\nexport const useSetLocale = () => {\n    const [, setLocale] = useLocaleState();\n    return setLocale;\n};\n","import { useState, useMemo } from 'react';\nimport { useResourceContext } from '../core';\nimport { getFieldLabelTranslationArgs } from '../util';\nimport { TranslatableContextValue } from './TranslatableContext';\nimport { useLocaleState } from './useLocaleState';\nimport { useTranslate } from './useTranslate';\n\n/**\n * Hook supplying the logic to translate a field value in multiple languages.\n *\n * @param options The hook options\n * @param {string} options.defaultLocale The locale of the default selected locale. Defaults to 'en'.\n * @param {string[]} options.locales An array of the supported locales. Each is an object with a locale and a name property. For example { locale: 'en', name: 'English' }.\n *\n * @returns\n * An object with following properties and methods:\n * - selectedLocale: The locale of the currently selected locale\n * - locales: An array of the supported locales\n * - getLabel: A function which returns the translated label for the given field\n * - getSource: A function which returns the source for the given field\n * - selectLocale: A function which set the selected locale\n */\nexport const useTranslatable = (\n    options: UseTranslatableOptions\n): TranslatableContextValue => {\n    const [localeFromUI] = useLocaleState();\n    const { defaultLocale = localeFromUI, locales } = options;\n    const [selectedLocale, setSelectedLocale] = useState(defaultLocale);\n    const resource = useResourceContext({});\n    const translate = useTranslate();\n\n    const context = useMemo<TranslatableContextValue>(\n        () => ({\n            getSource: (source: string, locale: string = selectedLocale) =>\n                `${source}.${locale}`,\n            getLabel: (source: string, label?: string) => {\n                return translate(\n                    ...getFieldLabelTranslationArgs({\n                        source,\n                        resource,\n                        label,\n                    })\n                );\n            },\n            locales,\n            selectedLocale,\n            selectLocale: setSelectedLocale,\n        }),\n        [locales, resource, selectedLocale, translate]\n    );\n\n    return context;\n};\n\nexport type UseTranslatableOptions = {\n    defaultLocale?: string;\n    locales: string[];\n};\n","import { useCallback } from 'react';\n\nimport { Translate } from '../types';\nimport { useI18nProvider } from './useI18nProvider';\n\n/**\n * Translate a string using the current locale and the translations from the i18nProvider\n *\n * @see Polyglot.t()\n * @link https://airbnb.io/polyglot.js/#polyglotprototypetkey-interpolationoptions\n *\n * @return {Function} A translation function, accepting two arguments\n *   - a string used as key in the translations\n *   - an interpolationOptions object\n *\n * @example\n *\n * import { useTranslate } from 'react-admin';\n *\n * const SettingsMenu = () => {\n *     const translate = useTranslate();\n *     return <MenuItem>{translate('settings')}</MenuItem>;\n * }\n */\nexport const useTranslate = (): Translate => {\n    const i18nProvider = useI18nProvider();\n    const translate = useCallback(\n        (key: string, options?: any) =>\n            i18nProvider.translate(key, options) as string,\n        // update the hook each time the locale changes\n        [i18nProvider] // eslint-disable-line react-hooks/exhaustive-deps\n    );\n    return i18nProvider ? translate : identity;\n};\n\nconst identity = key => key;\n","import { useContext } from 'react';\nimport {\n    TranslatableContext,\n    TranslatableContextValue,\n} from './TranslatableContext';\n\n/**\n * Gives access to the current TranslatableContext.\n *\n * @example\n * <TranslatableFields\n *     selector={<MyLanguageSelector />}\n *     locales={['en', 'fr']}\n * >\n *     <TextField source={getSource('title')} />\n * <TranslatableFields>\n *\n * const MyLanguageSelector = () => {\n *     const {\n *         locales,\n *         selectedLocale,\n *         selectLocale,\n *     } = useTranslatableContext();\n *\n *     return (\n *         <select onChange={selectLocale}>\n *             {locales.map((locale) => (\n *                 <option selected={locale.locale === selectedLocale}>\n *                     {locale.name}\n *                 </option>\n *             ))}\n *        </select>\n *     );\n * }\n */\nexport const useTranslatableContext = (): TranslatableContextValue => {\n    const context = useContext(TranslatableContext);\n\n    if (!context) {\n        throw new Error(\n            'useTranslatableContext must be used inside a TranslatableContextProvider'\n        );\n    }\n\n    return context;\n};\n","export const DEFAULT_LOCALE = 'en';\n\nexport * from './TestTranslationProvider';\nexport * from './I18nContext';\nexport * from './I18nContextProvider';\nexport * from './TranslationMessages';\nexport * from './TranslatableContext';\nexport * from './TranslatableContextProvider';\nexport * from './TranslationUtils';\nexport * from './useLocaleState';\nexport * from './useLocale';\nexport * from './useSetLocale';\nexport * from './useTranslatable';\nexport * from './useTranslatableContext';\nexport * from './useTranslate';\nexport * from './useI18nProvider';\n","import inflection from 'inflection';\n\ninterface Args {\n    label?: string;\n    parentSource?: string;\n    resource?: string;\n    source?: string;\n}\n\ntype TranslationArguments = [string, any?];\n\n/**\n * Returns an array of arguments to use with the translate function for the label of a field.\n * The label will be the one specified by the label prop or one computed from the resource and source props.\n *\n * Usage:\n *  <span>\n *      {translate(...getFieldLabelTranslationArgs({ label, resource, source }))}\n *  </span>\n */\nexport default (options?: Args): TranslationArguments => {\n    if (!options) {\n        return [''];\n    }\n\n    const { label, parentSource, resource, source } = options;\n    return typeof label !== 'undefined'\n        ? [label, { _: label }]\n        : typeof source !== 'undefined'\n        ? [\n              `resources.${resource}.fields.${\n                  parentSource ? `${parentSource}.${source}` : source\n              }`,\n              {\n                  _: inflection.transform(source, ['underscore', 'humanize']),\n              },\n          ]\n        : [''];\n};\n","import { useContext } from 'react';\nimport { ResourceContext, ResourceContextValue } from './ResourceContext';\n\n/**\n * Hook to read the resource from the ResourceContext.\n *\n * Must be used within a <ResourceContextProvider> (e.g. as a descendent of <Resource>\n * or any reference related components), or called with a resource prop.\n *\n * @example\n *\n * const ResourceName = (props) => {\n *   const resource = useResourceContext(props);\n *   const getResourceLabel = useGetResourceLabel();\n *   return <>{getResourceLabel(resource, 1)}</>;\n * }\n *\n * // use it in a resource context\n * const MyComponent = () => (\n *   <ResourceContextProvider value=\"posts\">\n *     <ResourceName />\n *     ...\n *   </ResourceContextProvider>\n * );\n *\n * // override resource via props\n * const MyComponent = () => (\n *   <>\n *     <ResourceName resource=\"posts\"/>\n *     ...\n *   </>\n * );\n *\n * @returns {ResourceContextValue} The resource name, e.g. 'posts'\n */\nexport const useResourceContext = <\n    ResourceInformationsType extends Partial<{ resource: string }>\n>(\n    props?: ResourceInformationsType\n): ResourceContextValue => {\n    const context = useContext(ResourceContext);\n    return (props && props.resource) || context;\n};\n","import { createContext } from 'react';\n\n/**\n * Context to store the current resource name.\n *\n * Use the useResource() hook to read the context. That's what most components do in react-admin.\n *\n * @example\n *\n * import { useResourceContext, useTranslate } from 'ra-core';\n *\n * const MyCustomEditTitle = props => {\n *     const name = useResourceContext(props);\n *\n *     return (\n *         <h1>{translate(`${name}.name`)}</h1>\n *     );\n * };\n */\nexport const ResourceContext = createContext<ResourceContextValue>(undefined);\n\nexport type ResourceContextValue = string;\n","import { isValidElementType } from 'react-is';\n\nexport default (props, propName, componentName) => {\n    if (props[propName] && !isValidElementType(props[propName])) {\n        return new Error(\n            `Invalid prop '${propName}' supplied to '${componentName}': the prop is not a valid React component`\n        );\n    }\n};\n","function is(x: unknown, y: unknown) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        // eslint-disable-next-line no-self-compare\n        return x !== x && y !== y;\n    }\n}\n\nexport const shallowEqual = (objA: any, objB: any) => {\n    if (is(objA, objB)) return true;\n\n    if (\n        typeof objA !== 'object' ||\n        objA === null ||\n        typeof objB !== 'object' ||\n        objB === null\n    ) {\n        return false;\n    }\n\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n\n    if (keysA.length !== keysB.length) return false;\n\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n};\n","import { shallowEqual } from './shallowEqual';\n\nconst isObject = obj =>\n    obj && Object.prototype.toString.call(obj) === '[object Object]';\n\nconst isEmpty = obj =>\n    obj instanceof Date\n        ? false\n        : obj === '' ||\n          obj === null ||\n          obj === undefined ||\n          shallowEqual(obj, {});\n\nconst removeEmpty = object =>\n    Object.keys(object).reduce((acc, key) => {\n        let child = object[key];\n\n        if (isObject(object[key])) {\n            child = removeEmpty(object[key]);\n        }\n\n        return isEmpty(child) ? acc : { ...acc, [key]: child };\n    }, {});\n\nexport default removeEmpty;\n","const removeKey = (target, path) =>\n    Object.keys(target).reduce((acc, key) => {\n        if (key !== path) {\n            return Object.assign({}, acc, { [key]: target[key] });\n        }\n\n        return acc;\n    }, {});\n\nconst deepRemoveKey = (target, path) => {\n    const paths = path.split('.');\n\n    if (paths.length === 1) {\n        return removeKey(target, path);\n    }\n\n    const deepKey = paths[0];\n    if (target[deepKey] === undefined) {\n        return target;\n    }\n    const deep = deepRemoveKey(target[deepKey], paths.slice(1).join('.'));\n\n    if (Object.keys(deep).length === 0) {\n        return removeKey(target, deepKey);\n    }\n\n    return Object.assign({}, target, { [deepKey]: deep });\n};\n\nexport default deepRemoveKey;\n","import * as React from 'react';\nimport { useState } from 'react';\n\nconst styles = {\n    root: {\n        width: '100vw',\n        height: '100vh',\n        display: 'flex',\n        flexDirection: 'column' as 'column',\n        fontFamily: '\"Roboto\", sans-serif',\n    },\n    main: {\n        flex: 1,\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        textAlign: 'center' as 'center',\n        flexDirection: 'column' as 'column',\n        background:\n            'linear-gradient(135deg, #00023b 0%, #00023b 50%, #313264 100%)',\n        color: 'white',\n        fontSize: '1.5em',\n        fontWeight: 'bold' as 'bold',\n    },\n    secondary: {\n        height: '20vh',\n        background: '#e8e8e8',\n        color: 'black',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-evenly',\n    },\n    link: {\n        textAlign: 'center' as 'center',\n        width: 150,\n        display: 'block',\n        textDecoration: 'none',\n        color: 'black',\n        opacity: 0.7,\n    },\n    linkHovered: {\n        opacity: 1,\n    },\n    image: {\n        width: 50,\n    },\n    logo: {\n        height: 100,\n    },\n};\n\nconst Button = ({ img, label, href }) => {\n    const [hovered, setHovered] = useState(false);\n    return (\n        <div>\n            <a\n                href={href}\n                style={\n                    hovered\n                        ? { ...styles.link, ...styles.linkHovered }\n                        : styles.link\n                }\n                onMouseEnter={() => setHovered(true)}\n                onMouseLeave={() => setHovered(false)}\n            >\n                <img src={img} alt={label} style={styles.image} />\n                <br />\n                {label}\n            </a>\n        </div>\n    );\n};\n\nexport default () =>\n    process.env.NODE_ENV === 'production' ? (\n        <span />\n    ) : (\n        <div style={styles.root}>\n            <div style={styles.main}>\n                <img\n                    style={styles.logo}\n                    src=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhbHF1ZV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgMTMxIDEzMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTMxIDEzMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiMyMjI0NTg7fQoJLnN0MXtmaWxsOiM1MTUzN0Q7fQoJLnN0MntmaWxsOiNBM0E0Qjk7fQoJLnN0M3tmaWxsOiMwMDAyM0I7fQoJLnN0NHtmaWxsOiNGRkZGRkY7fQoJLnN0NXtlbmFibGUtYmFja2dyb3VuZDpuZXcgICAgO30KPC9zdHlsZT4KPHRpdGxlPkxvZ29fc29tYnJlX2FpPC90aXRsZT4KPGcgaWQ9IlJlY3RhbmdsZV81NiI+Cgk8Zz4KCQk8cmVjdCB4PSIxOS4xIiB5PSIxOSIgdHJhbnNmb3JtPSJtYXRyaXgoMC41IC0wLjg2NiAwLjg2NiAwLjUgLTIzLjkyMjYgODkuNTQ2KSIgY2xhc3M9InN0MCIgd2lkdGg9IjkyLjkiIGhlaWdodD0iOTIuOSIvPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik04MywxMzAuM0wwLjgsODIuOUw0OC4yLDAuN2w4Mi4yLDQ3LjVMODMsMTMwLjN6IE0zLjUsODIuMWw3OC43LDQ1LjVsNDUuNS03OC43TDQ5LDMuNEwzLjUsODIuMXoiLz4KCTwvZz4KPC9nPgo8ZyBpZD0iUmVjdGFuZ2xlXzU2LTIiPgoJPGc+CgkJPHJlY3QgeD0iMTkiIHk9IjE5LjEiIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2IC0wLjUgMC41IDAuODY2IC0yMy45Nzc3IDQxLjUyNykiIGNsYXNzPSJzdDAiIHdpZHRoPSI5Mi45IiBoZWlnaHQ9IjkyLjkiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNDcuOSwxMzFMMCw0OEw4My4xLDBsNDgsODMuMUw0Ny45LDEzMXogTTQuMSw0OS4xbDQ1LDc3LjlsNzcuOS00NUw4Miw0LjFMNC4xLDQ5LjF6Ii8+Cgk8L2c+CjwvZz4KPGcgaWQ9IlJlY3RhbmdsZV81Ni0zIj4KCTxnPgoJCTxyZWN0IHg9IjE5LjEiIHk9IjE5IiBjbGFzcz0ic3QzIiB3aWR0aD0iOTIuOSIgaGVpZ2h0PSI5Mi45Ii8+CgkJPHBhdGggY2xhc3M9InN0NCIgZD0iTTExNC41LDExNC41SDE2LjZWMTYuNWg5Ny45VjExNC41eiBNMjEuNiwxMDkuNWg4Ny45VjIxLjVIMjEuNlYxMDkuNXoiLz4KCTwvZz4KPC9nPgo8ZyBpZD0iUmEiPgoJPGcgY2xhc3M9InN0NSI+CgkJPHBhdGggY2xhc3M9InN0NCIgZD0iTTU5LDg2LjdsLTYuNy0xOS4yaC0xLjJIMzguOXYxOS4yaC01LjZWMzguNWgxOC41YzMuNiwwLDYuMywwLjYsOC4xLDEuOGMxLjgsMS4yLDMsMi44LDMuNSw0LjgKCQkJYzAuNSwyLDAuOCw0LjYsMC44LDcuOGMwLDMuNS0wLjQsNi40LTEuMyw4LjdjLTAuOCwyLjMtMi42LDMuOS01LjMsNC44TDY1LDg2LjdINTl6IE01NS43LDYxLjZjMS4yLTAuNywyLTEuNywyLjQtMwoJCQljMC40LTEuMywwLjYtMy4yLDAuNi01LjZjMC0yLjUtMC4yLTQuMy0wLjUtNS42Yy0wLjMtMS4zLTEuMS0yLjItMi4zLTIuOWMtMS4yLTAuNy0zLTEtNS41LTFIMzguOXYxOS4xSDUwCgkJCUM1Mi41LDYyLjYsNTQuNCw2Mi4zLDU1LjcsNjEuNnoiLz4KCQk8cGF0aCBjbGFzcz0ic3Q0IiBkPSJNNzQuMyw4NWMtMS42LTEuNS0yLjUtNC4yLTIuNS04LjJjMC0yLjcsMC4zLTQuOCwwLjktNi4zYzAuNi0xLjUsMS42LTIuNiwzLTMuM2MxLjQtMC43LDMuNC0xLDYtMQoJCQljMS4zLDAsNS4xLDAuMSwxMS40LDAuM3YtMi40YzAtMi45LTAuMi01LTAuNy02LjJjLTAuNS0xLjItMS4zLTItMi42LTIuNGMtMS4yLTAuMy0zLjMtMC41LTYuMy0wLjVjLTEuMywwLTMsMC4xLTQuOSwwLjIKCQkJYy0yLDAuMS0zLjYsMC4zLTQuOCwwLjV2LTQuM2MzLjMtMC43LDcuMS0xLDExLjQtMWMzLjcsMCw2LjUsMC40LDguNCwxLjJjMS44LDAuOCwzLjEsMi4yLDMuOCw0LjFjMC43LDEuOSwxLDQuNywxLDguNHYyMi41aC00LjgKCQkJbC0wLjMtNWgtMC4zYy0wLjgsMi4yLTIuMiwzLjctNC4xLDQuNGMtMS45LDAuNy00LjEsMS4xLTYuNiwxLjFDNzguNiw4Ny4yLDc2LDg2LjUsNzQuMyw4NXogTTg5LjEsODJjMS4yLTAuNCwyLjItMS4yLDIuOC0yLjQKCQkJYzAuOS0xLjgsMS4zLTQuMywxLjMtNy4zdi0yaC0xMGMtMS43LDAtMywwLjItMy44LDAuNWMtMC44LDAuMy0xLjQsMC45LTEuNywxLjhjLTAuMywwLjktMC41LDIuMi0wLjUsNGMwLDEuOCwwLjIsMy4xLDAuNiwzLjkKCQkJYzAuNCwwLjgsMS4xLDEuNCwyLDEuOGMxLDAuMywyLjUsMC41LDQuNSwwLjVDODYuMiw4Mi42LDg3LjgsODIuNCw4OS4xLDgyeiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=\"\n                    alt=\"react-admin logo\"\n                />\n                <h1>Welcome to React-admin</h1>\n                <div>\n                    Your application is properly configured.\n                    <br />\n                    Now you can add a &lt;Resource&gt; as child of\n                    &lt;Admin&gt;.\n                </div>\n            </div>\n            <div style={styles.secondary}>\n                <Button\n                    href=\"https://marmelab.com/react-admin/Readme.html\"\n                    img=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNHB4IgoJIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyNCAyNCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnIGlkPSJCb3VuZGluZ19Cb3giPgoJPHJlY3QgZmlsbD0ibm9uZSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ii8+CjwvZz4KPGcgaWQ9IkZsYXQiPgoJPGcgaWQ9InVpX3g1Rl9zcGVjX3g1Rl9oZWFkZXJfY29weV8yIj4KCTwvZz4KCTxnPgoJCTxwYXRoIGQ9Ik0yMSw1Yy0xLjExLTAuMzUtMi4zMy0wLjUtMy41LTAuNWMtMS45NSwwLTQuMDUsMC40LTUuNSwxLjVjLTEuNDUtMS4xLTMuNTUtMS41LTUuNS0xLjVTMi40NSw0LjksMSw2djE0LjY1CgkJCWMwLDAuMjUsMC4yNSwwLjUsMC41LDAuNWMwLjEsMCwwLjE1LTAuMDUsMC4yNS0wLjA1QzMuMSwyMC40NSw1LjA1LDIwLDYuNSwyMGMxLjk1LDAsNC4wNSwwLjQsNS41LDEuNWMxLjM1LTAuODUsMy44LTEuNSw1LjUtMS41CgkJCWMxLjY1LDAsMy4zNSwwLjMsNC43NSwxLjA1YzAuMSwwLjA1LDAuMTUsMC4wNSwwLjI1LDAuMDVjMC4yNSwwLDAuNS0wLjI1LDAuNS0wLjVWNkMyMi40LDUuNTUsMjEuNzUsNS4yNSwyMSw1eiBNMywxOC41VjcKCQkJYzEuMS0wLjM1LDIuMy0wLjUsMy41LTAuNWMxLjM0LDAsMy4xMywwLjQxLDQuNSwwLjk5djExLjVDOS42MywxOC40MSw3Ljg0LDE4LDYuNSwxOEM1LjMsMTgsNC4xLDE4LjE1LDMsMTguNXogTTIxLDE4LjUKCQkJYy0xLjEtMC4zNS0yLjMtMC41LTMuNS0wLjVjLTEuMzQsMC0zLjEzLDAuNDEtNC41LDAuOTlWNy40OWMxLjM3LTAuNTksMy4xNi0wLjk5LDQuNS0wLjk5YzEuMiwwLDIuNCwwLjE1LDMuNSwwLjVWMTguNXoiLz4KCQk8cGF0aCBvcGFjaXR5PSIwLjMiIGQ9Ik0xMSw3LjQ5QzkuNjMsNi45MSw3Ljg0LDYuNSw2LjUsNi41QzUuMyw2LjUsNC4xLDYuNjUsMyw3djExLjVDNC4xLDE4LjE1LDUuMywxOCw2LjUsMTgKCQkJYzEuMzQsMCwzLjEzLDAuNDEsNC41LDAuOTlWNy40OXoiLz4KCTwvZz4KCTxnPgoJCTxwYXRoIGQ9Ik0xNy41LDEwLjVjMC44OCwwLDEuNzMsMC4wOSwyLjUsMC4yNlY5LjI0QzE5LjIxLDkuMDksMTguMzYsOSwxNy41LDljLTEuMjgsMC0yLjQ2LDAuMTYtMy41LDAuNDd2MS41NwoJCQlDMTQuOTksMTAuNjksMTYuMTgsMTAuNSwxNy41LDEwLjV6Ii8+CgkJPHBhdGggZD0iTTE3LjUsMTMuMTZjMC44OCwwLDEuNzMsMC4wOSwyLjUsMC4yNlYxMS45Yy0wLjc5LTAuMTUtMS42NC0wLjI0LTIuNS0wLjI0Yy0xLjI4LDAtMi40NiwwLjE2LTMuNSwwLjQ3djEuNTcKCQkJQzE0Ljk5LDEzLjM2LDE2LjE4LDEzLjE2LDE3LjUsMTMuMTZ6Ii8+CgkJPHBhdGggZD0iTTE3LjUsMTUuODNjMC44OCwwLDEuNzMsMC4wOSwyLjUsMC4yNnYtMS41MmMtMC43OS0wLjE1LTEuNjQtMC4yNC0yLjUtMC4yNGMtMS4yOCwwLTIuNDYsMC4xNi0zLjUsMC40N3YxLjU3CgkJCUMxNC45OSwxNi4wMiwxNi4xOCwxNS44MywxNy41LDE1LjgzeiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=\"\n                    label=\"Documentation\"\n                />\n                <Button\n                    href=\"https://github.com/marmelab/react-admin/tree/master/examples\"\n                    img=\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDBWMHoiLz48cGF0aCBkPSJNOS40IDE2LjZMNC44IDEybDQuNi00LjZMOCA2bC02IDYgNiA2IDEuNC0xLjR6bTUuMiAwbDQuNi00LjYtNC42LTQuNkwxNiA2bDYgNi02IDYtMS40LTEuNHoiLz48L3N2Zz4=\"\n                    label=\"Examples\"\n                />\n                <Button\n                    href=\"https://stackoverflow.com/questions/tagged/react-admin\"\n                    img=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNHB4IgoJIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyNCAyNCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnIGlkPSJCb3VuZGluZ19Cb3giPgoJPHJlY3QgZmlsbD0ibm9uZSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ii8+CjwvZz4KPGcgaWQ9IkZsYXQiPgoJPGcgaWQ9InVpX3g1Rl9zcGVjX3g1Rl9oZWFkZXJfY29weV8yIj4KCTwvZz4KCTxnPgoJCTxjaXJjbGUgb3BhY2l0eT0iMC4zIiBjeD0iOSIgY3k9IjgiIHI9IjIiLz4KCQk8cGF0aCBvcGFjaXR5PSIwLjMiIGQ9Ik05LDE1Yy0yLjcsMC01LjgsMS4yOS02LDIuMDFMMywxOGgxMnYtMUMxNC44LDE2LjI5LDExLjcsMTUsOSwxNXoiLz4KCQk8cGF0aCBkPSJNMTYuNjcsMTMuMTNDMTguMDQsMTQuMDYsMTksMTUuMzIsMTksMTd2M2g0di0zQzIzLDE0LjgyLDE5LjQzLDEzLjUzLDE2LjY3LDEzLjEzeiIvPgoJCTxwYXRoIGQ9Ik0xNSwxMmMyLjIxLDAsNC0xLjc5LDQtNGMwLTIuMjEtMS43OS00LTQtNGMtMC40NywwLTAuOTEsMC4xLTEuMzMsMC4yNEMxNC41LDUuMjcsMTUsNi41OCwxNSw4cy0wLjUsMi43My0xLjMzLDMuNzYKCQkJQzE0LjA5LDExLjksMTQuNTMsMTIsMTUsMTJ6Ii8+CgkJPHBhdGggZD0iTTksMTJjMi4yMSwwLDQtMS43OSw0LTRjMC0yLjIxLTEuNzktNC00LTRTNSw1Ljc5LDUsOEM1LDEwLjIxLDYuNzksMTIsOSwxMnogTTksNmMxLjEsMCwyLDAuOSwyLDJjMCwxLjEtMC45LDItMiwyCgkJCVM3LDkuMSw3LDhDNyw2LjksNy45LDYsOSw2eiIvPgoJCTxwYXRoIGQ9Ik05LDEzYy0yLjY3LDAtOCwxLjM0LTgsNHYzaDE2di0zQzE3LDE0LjM0LDExLjY3LDEzLDksMTN6IE0xNSwxOEgzbDAtMC45OUMzLjIsMTYuMjksNi4zLDE1LDksMTVzNS44LDEuMjksNiwyVjE4eiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=\"\n                    label=\"Community\"\n                />\n            </div>\n        </div>\n    );\n","export default (condition: any, message: string) => {\n    if (condition && process.env.NODE_ENV !== 'production') {\n        console.warn(message); // eslint-disable-line\n    }\n};\n","import { useRef, useEffect } from 'react';\n\n/**\n * Debug hook showing which props updated between two renders\n * @example\n *\n * const MyComponent = React.memo(props => {\n *   useWhyDidYouUpdate('MyComponent', props);\n *   return <div...;\n * });\n *\n * @link https://usehooks.com/useWhyDidYouUpdate/\n */\nexport default function useWhyDidYouUpdate(name, props) {\n    // Get a mutable ref object where we can store props ...\n    // ... for comparison next time this hook runs.\n    const previousProps = useRef() as any;\n\n    useEffect(() => {\n        if (previousProps.current) {\n            // Get all keys from previous and current props\n            const allKeys = Object.keys({ ...previousProps.current, ...props });\n            // Use this object to keep track of changed props\n            const changesObj = {};\n            // Iterate through keys\n            allKeys.forEach(key => {\n                // If previous is different from current\n                if (previousProps.current[key] !== props[key]) {\n                    // Add to changesObj\n                    changesObj[key] = {\n                        from: previousProps.current[key],\n                        to: props[key],\n                    };\n                }\n            });\n\n            // If changesObj not empty then output to console\n            if (Object.keys(changesObj).length) {\n                console.log('[why-did-you-update]', name, changesObj);\n            }\n        }\n\n        // Finally update previousProps with current props for next hook call\n        previousProps.current = props;\n    });\n}\n","export const getMutationMode = (mutationMode, undoable) => {\n    if (mutationMode) {\n        return mutationMode;\n    }\n    switch (undoable) {\n        case true:\n            return 'undoable';\n        case false:\n            return 'pessimistic';\n        default:\n            return 'undoable';\n    }\n};\n","import { LegacyRef, MutableRefObject, RefCallback } from 'react';\n\n// https://github.com/gregberge/react-merge-refs\nexport function mergeRefs<T = any>(\n    refs: Array<MutableRefObject<T> | LegacyRef<T>>\n): RefCallback<T> {\n    return value => {\n        refs.forEach(ref => {\n            if (typeof ref === 'function') {\n                ref(value);\n            } else if (ref != null) {\n                (ref as MutableRefObject<T | null>).current = value;\n            }\n        });\n    };\n}\n","import * as React from 'react';\nimport { useCallback } from 'react';\n\n// allow the hook to work in SSR\nconst useLayoutEffect =\n    typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\n/**\n * Alternative to useCallback that doesn't update the callback when dependencies change\n *\n * @see https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n * @see https://github.com/facebook/react/issues/14099#issuecomment-440013892\n */\nexport const useEventCallback = <Args extends unknown[], Return>(\n    fn: (...args: Args) => Return,\n    dependencies: any[]\n): ((...args: Args) => Return) => {\n    const ref = React.useRef<(...args: Args) => Return>(() => {\n        throw new Error('Cannot call an event handler while rendering.');\n    });\n\n    useLayoutEffect(() => {\n        ref.current = fn;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [fn, ...dependencies]);\n\n    return useCallback((...args: Args) => ref.current(...args), []);\n};\n","import * as React from 'react';\nimport { useState, useRef, useEffect, useCallback } from 'react';\nimport isEqual from 'lodash/isEqual';\n\n// thanks Kent C Dodds for the following helpers\n\nexport function useSafeSetState<T>(\n    initialState?: T | (() => T)\n): [T, React.Dispatch<React.SetStateAction<T>>] {\n    const [state, setState] = useState(initialState);\n\n    const mountedRef = useRef(false);\n    useEffect(() => {\n        mountedRef.current = true;\n        return () => {\n            mountedRef.current = false;\n        };\n    }, []);\n    const safeSetState = useCallback(\n        args => {\n            if (mountedRef.current) {\n                return setState(args);\n            }\n        },\n        [mountedRef, setState]\n    );\n\n    return [state, safeSetState];\n}\n\nexport function usePrevious(value) {\n    const ref = useRef();\n    useEffect(() => {\n        ref.current = value;\n    });\n    return ref.current;\n}\n\nexport function useDeepCompareEffect(callback, inputs) {\n    const cleanupRef = useRef();\n    useEffect(() => {\n        if (!isEqual(previousInputs, inputs)) {\n            cleanupRef.current = callback();\n        }\n        return cleanupRef.current;\n    });\n    const previousInputs = usePrevious(inputs);\n}\n\n/**\n * A hook that returns true once a delay has expired.\n * @param ms The delay in milliseconds\n * @param key A key that can be used to reset the timer\n * @returns true if the delay has expired, false otherwise\n */\nexport function useTimeout(ms = 0, key = '') {\n    const [ready, setReady] = useSafeSetState(false);\n\n    useEffect(() => {\n        setReady(false);\n        let timer = setTimeout(() => {\n            setReady(true);\n        }, ms);\n\n        return () => {\n            clearTimeout(timer);\n        };\n    }, [key, ms, setReady]);\n\n    return ready;\n}\n\nexport function useIsMounted() {\n    const isMounted = useRef(true);\n    useEffect(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n","import { useCallback } from 'react';\n\nimport { useStoreContext } from './useStoreContext';\n\n/**\n * Get a callback to remove an item from the store\n *\n * @example\n * import { useRemoveFromStore } from 'react-admin';\n *\n * const ResetDatagridPrefs = () {\n *    const removeItem = useRemoveFromStore();\n *\n *    const hancleClick = () => {\n *        removeItem('datagrid.prefs');\n *    };\n *\n *    return <Button onClick={hancleClick}>Reset datagrid preferences</Button>;\n * }\n */\nexport const useRemoveFromStore = (hookTimeKey?: string) => {\n    const { removeItem } = useStoreContext();\n    return useCallback(\n        (key?: string) =>\n            removeItem(typeof key === 'undefined' ? hookTimeKey : key),\n        [removeItem, hookTimeKey]\n    );\n};\n","import { useStoreContext } from './useStoreContext';\n\n/**\n * Get a callback to remove all items from the store\n *\n * @example\n * import { useResetStore } from 'react-admin';\n *\n * const ResetPrefs = () {\n *    const reset = useResetStore();\n *\n *    const handleClick = () => {\n *        reset();\n *    };\n *\n *    return <Button onClick={handleClick}>Reset preferences</Button>;\n * }\n */\nexport const useResetStore = () => {\n    const { reset } = useStoreContext();\n    return reset;\n};\n","import { useEffect } from 'react';\n\nimport useGetPermissions from './useGetPermissions';\nimport { useSafeSetState } from '../util/hooks';\n\ninterface State<Permissions, Error> {\n    isLoading: boolean;\n    permissions?: Permissions;\n    error?: Error;\n}\n\nconst emptyParams = {};\n\n/**\n * Hook for getting user permissions\n *\n * Calls the authProvider.getPermissions() method asynchronously.\n * If the authProvider returns a rejected promise, returns empty permissions.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true }\n * - success: { permissions: [any], isLoading: false }\n * - error: { error: [error from provider], isLoading: false }\n *\n * Useful to enable features based on user permissions\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @returns The current auth check state. Destructure as { permissions, error, isLoading }.\n *\n * @example\n *     import { usePermissions } from 'react-admin';\n *\n *     const PostDetail = props => {\n *         const { isLoading, permissions } = usePermissions();\n *         if (!isLoading && permissions == 'editor') {\n *             return <PostEdit {...props} />\n *         } else {\n *             return <PostShow {...props} />\n *         }\n *     };\n */\nconst usePermissions = <Permissions = any, Error = any>(\n    params = emptyParams\n): State<Permissions, Error> => {\n    const [state, setState] = useSafeSetState<State<Permissions, Error>>({\n        isLoading: true,\n    });\n    const getPermissions = useGetPermissions();\n    useEffect(() => {\n        getPermissions(params)\n            .then(permissions => {\n                setState({ isLoading: false, permissions });\n            })\n            .catch(error => {\n                setState({\n                    isLoading: false,\n                    error,\n                });\n            });\n    }, [getPermissions, params, setState]);\n    return state;\n};\n\nexport default usePermissions;\n","import { useCallback } from 'react';\n\nimport useAuthProvider from './useAuthProvider';\n\nconst getPermissionsWithoutProvider = () => Promise.resolve([]);\n\n/**\n * Get a callback for calling the authProvider.getPermissions() method.\n *\n * @see useAuthProvider\n *\n * @returns {Function} getPermissions callback\n *\n * This is a low level hook. See those more specialized hooks\n * offering state handling.\n *\n * @see usePermissions\n *\n * @example\n *\n * import { useGetPermissions } from 'react-admin';\n *\n * const Roles = () => {\n *     const [permissions, setPermissions] = useState([]);\n *     const getPermissions = useGetPermissions();\n *     useEffect(() => {\n *         getPermissions().then(permissions => setPermissions(permissions))\n *     }, [])\n *     return (\n *         <ul>\n *             {permissions.map((permission, key) => (\n *                 <li key={key}>{permission}</li>\n *             ))}\n *         </ul>\n *     );\n * }\n */\nconst useGetPermissions = (): GetPermissions => {\n    const authProvider = useAuthProvider();\n    const getPermissions = useCallback(\n        (params: any = {}) => authProvider.getPermissions(params),\n        [authProvider]\n    );\n\n    return authProvider ? getPermissions : getPermissionsWithoutProvider;\n};\n\n/**\n * Proxy for calling authProvider.getPermissions()\n *\n * @param {Object} params The parameters to pass to the authProvider\n *\n * @return {Promise} The authProvider response\n */\ntype GetPermissions = (params?: any) => Promise<any>;\n\nexport default useGetPermissions;\n","import { useEffect } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nimport useGetPermissions from './useGetPermissions';\nimport { useSafeSetState } from '../util/hooks';\n\ninterface State {\n    permissions?: any;\n    error?: any;\n}\n\nconst emptyParams = {};\n\n// keep a cache of already fetched permissions to initialize state for new\n// components and avoid a useless rerender if the permissions haven't changed\nconst alreadyFetchedPermissions = { '{}': undefined };\n\n/**\n * Hook for getting user permissions without the loading state.\n *\n * When compared to usePermissions, this hook doesn't cause a re-render\n * when the permissions haven't changed since the last call.\n *\n * This hook doesn't handle the loading state.\n *\n * @see usePermissions\n *\n * Calls the authProvider.getPermissions() method asynchronously.\n * If the authProvider returns a rejected promise, returns empty permissions.\n *\n * The return value updates according to the request state:\n *\n * - start:   { permissions: [previously fetched permissions for these params] }\n * - success: { permissions: [permissions returned by the authProvider (usually the same as on start)] }\n * - error:   { error: [error from provider] }\n *\n * Useful to enable features based on user permissions\n *\n * @param {Object} params Any params you want to pass to the authProvider\n *\n * @returns The current auth check state. Destructure as { permissions, error }.\n *\n * @example\n *     import { usePermissionsOptimized } from 'react-admin';\n *\n *     const PostDetail = props => {\n *         const { permissions } = usePermissionsOptimized();\n *         if (permissions !== 'editor') {\n *             return <Redirect to={`posts/${props.id}/show`} />\n *         } else {\n *             return <PostEdit {...props} />\n *         }\n *     };\n */\nconst usePermissionsOptimized = (params = emptyParams) => {\n    const key = JSON.stringify(params);\n    const [state, setState] = useSafeSetState<State>({\n        permissions: alreadyFetchedPermissions[key],\n    });\n    const getPermissions = useGetPermissions();\n    useEffect(() => {\n        getPermissions(params)\n            .then(permissions => {\n                if (!isEqual(permissions, state.permissions)) {\n                    alreadyFetchedPermissions[key] = permissions;\n                    setState({ permissions });\n                }\n            })\n            .catch(error => {\n                setState({\n                    error,\n                });\n            });\n    }, [getPermissions, key]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return state;\n};\n\nexport default usePermissionsOptimized;\n","import { Children, ReactElement, ComponentType, createElement } from 'react';\nimport { Location } from 'react-router-dom';\n\nimport warning from '../util/warning';\nimport { useAuthenticated } from './useAuthenticated';\nimport usePermissionsOptimized from './usePermissionsOptimized';\n\nexport interface WithPermissionsChildrenParams {\n    permissions: any;\n}\n\ntype WithPermissionsChildren = (\n    params: WithPermissionsChildrenParams\n) => ReactElement;\n\nexport interface WithPermissionsProps {\n    authParams?: object;\n    children?: WithPermissionsChildren;\n    component?: ComponentType<any>;\n    location?: Location;\n    render?: WithPermissionsChildren;\n    staticContext?: object;\n    [key: string]: any;\n}\n\nconst isEmptyChildren = children => Children.count(children) === 0;\n\n/**\n * After checking that the user is authenticated,\n * retrieves the user's permissions for a specific context.\n *\n * Useful for Route components ; used internally by Resource.\n * Use it to decorate your custom page components to require\n * a custom role. It will pass the permissions as a prop to your\n * component.\n *\n * You can set additional `authParams` at will if your authProvider\n * requires it.\n *\n * @example\n *     import { WithPermissions } from 'react-admin';\n *\n *     const Foo = ({ permissions }) => (\n *         {permissions === 'admin' ? <p>Sensitive data</p> : null}\n *         <p>Not sensitive data</p>\n *     );\n *\n *     const customRoutes = [\n *         <Route path=\"/foo\" render={() =>\n *             <WithPermissions\n *                  authParams={{ foo: 'bar' }}\n *                  render={({ permissions, ...props }) => <Foo permissions={permissions} {...props} />}\n *              />\n *         } />\n *     ];\n *     const App = () => (\n *         <Admin customRoutes={customRoutes}>\n *             ...\n *         </Admin>\n *     );\n */\nconst WithPermissions = (props: WithPermissionsProps) => {\n    const {\n        authParams,\n        children,\n        render,\n        component,\n        staticContext,\n        ...rest\n    } = props;\n    warning(\n        (render && children && !isEmptyChildren(children)) ||\n            (render && component) ||\n            (component && children && !isEmptyChildren(children)),\n        'You should only use one of the `component`, `render` and `children` props in <WithPermissions>'\n    );\n\n    useAuthenticated(authParams);\n    const { permissions } = usePermissionsOptimized(authParams);\n    // render even though the usePermissions() call isn't finished (optimistic rendering)\n    if (component) {\n        return createElement(component, { permissions, ...rest });\n    }\n    // @deprecated\n    if (render) {\n        return render({ permissions, ...rest });\n    }\n    // @deprecated\n    if (children) {\n        return children({ permissions, ...rest });\n    }\n};\n\nexport default WithPermissions as ComponentType<WithPermissionsProps>;\n","import { useEffect } from 'react';\nimport { useCheckAuth } from './useCheckAuth';\n\n/**\n * Restrict access to authenticated users.\n * Redirect anonymous users to the login page.\n *\n * Use it in your custom page components to require\n * authentication.\n *\n * You can set additional `authParams` at will if your authProvider\n * requires it.\n *\n * @example\n *     import { useAuthenticated } from 'react-admin';\n *     const FooPage = () => {\n *         useAuthenticated();\n *         return <Foo />;\n *     }\n *     const CustomRoutes = [\n *         <Route path=\"/foo\" render={() => <FooPage />} />\n *     ];\n *     const App = () => (\n *         <Admin customRoutes={customRoutes}>\n *             ...\n *         </Admin>\n *     );\n */\nexport const useAuthenticated = <ParamsType = any>(\n    options: UseAuthenticatedOptions<ParamsType> = {}\n) => {\n    const { enabled = true, params = emptyParams } = options;\n    const checkAuth = useCheckAuth();\n    useEffect(() => {\n        if (enabled) {\n            checkAuth(params).catch(() => {});\n        }\n    }, [checkAuth, enabled, params]);\n};\n\nexport type UseAuthenticatedOptions<ParamsType> = {\n    enabled?: boolean;\n    params?: ParamsType;\n};\n\nconst emptyParams = {};\n","import { useCallback } from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\n\nimport { useNotificationContext } from '../notification';\nimport { useBasename } from '../routing';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n\n/**\n * Get a callback for calling the authProvider.login() method\n * and redirect to the previous authenticated page (or the home page) on success.\n *\n * @see useAuthProvider\n *\n * @returns {Function} login callback\n *\n * @example\n *\n * import { useLogin } from 'react-admin';\n *\n * const LoginButton = () => {\n *     const [loading, setLoading] = useState(false);\n *     const login = useLogin();\n *     const handleClick = {\n *         setLoading(true);\n *         login({ username: 'john', password: 'p@ssw0rd' }, '/posts')\n *             .then(() => setLoading(false));\n *     }\n *     return <button onClick={handleClick}>Login</button>;\n * }\n */\nconst useLogin = (): Login => {\n    const authProvider = useAuthProvider();\n    const location = useLocation();\n    const locationState = location.state as any;\n    const navigate = useNavigate();\n    const basename = useBasename();\n    const { resetNotifications } = useNotificationContext();\n    const nextPathName = locationState && locationState.nextPathname;\n    const nextSearch = locationState && locationState.nextSearch;\n    const afterLoginUrl = removeDoubleSlashes(\n        `${basename}/${defaultAuthParams.afterLoginUrl}`\n    );\n\n    const login = useCallback(\n        (params: any = {}, pathName) =>\n            authProvider.login(params).then(ret => {\n                resetNotifications();\n                const redirectUrl = pathName\n                    ? pathName\n                    : nextPathName + nextSearch || afterLoginUrl;\n                navigate(redirectUrl);\n                return ret;\n            }),\n        [\n            authProvider,\n            navigate,\n            nextPathName,\n            nextSearch,\n            resetNotifications,\n            afterLoginUrl,\n        ]\n    );\n\n    const loginWithoutProvider = useCallback(\n        (_, __) => {\n            resetNotifications();\n            navigate(afterLoginUrl);\n            return Promise.resolve();\n        },\n        [navigate, resetNotifications, afterLoginUrl]\n    );\n\n    return authProvider ? login : loginWithoutProvider;\n};\n\n/**\n * Log a user in by calling the authProvider.login() method\n *\n * @param {Object} params Login parameters to pass to the authProvider. May contain username/email, password, etc\n * @param {string} pathName The path to redirect to after login. By default, redirects to the home page, or to the last page visited after disconnection.\n *\n * @return {Promise} The authProvider response\n */\ntype Login = (params: any, pathName?: string) => Promise<any>;\n\nexport default useLogin;\n","import { useEffect } from 'react';\nimport useAuthProvider from './useAuthProvider';\nimport { UserIdentity } from '../types';\nimport { useSafeSetState } from '../util/hooks';\n\nconst defaultIdentity = {\n    id: '',\n    fullName: null,\n};\n\n/**\n * Return the current user identity by calling authProvider.getIdentity() on mount\n *\n * The return value updates according to the call state:\n *\n * - mount: { isLoading: true }\n * - success: { identity: Identity, isLoading: false }\n * - error: { error: Error, isLoading: false }\n *\n * The implementation is left to the authProvider.\n *\n * @returns The current user identity. Destructure as { identity, error, isLoading }.\n *\n * @example\n *\n * import { useGetIdentity, useGetOne } from 'react-admin';\n *\n * const PostDetail = ({ id }) => {\n *     const { data: post, isLoading: postLoading } = useGetOne('posts', { id });\n *     const { identity, isLoading: identityLoading } = useGetIdentity();\n *     if (postLoading || identityLoading) return <>Loading...</>;\n *     if (!post.lockedBy || post.lockedBy === identity.id) {\n *         // post isn't locked, or is locked by me\n *         return <PostEdit post={post} />\n *     } else {\n *         // post is locked by someone else and cannot be edited\n *         return <PostShow post={post} />\n *     }\n * }\n */\nconst useGetIdentity = () => {\n    const [state, setState] = useSafeSetState<State>({\n        isLoading: true,\n    });\n    const authProvider = useAuthProvider();\n    useEffect(() => {\n        if (authProvider && typeof authProvider.getIdentity === 'function') {\n            const callAuthProvider = async () => {\n                try {\n                    const identity = await authProvider.getIdentity();\n                    setState({\n                        isLoading: false,\n                        identity: identity || defaultIdentity,\n                    });\n                } catch (error) {\n                    setState({\n                        isLoading: false,\n                        error,\n                    });\n                }\n            };\n            callAuthProvider();\n        } else {\n            setState({\n                isLoading: false,\n                identity: defaultIdentity,\n            });\n        }\n    }, [authProvider, setState]);\n    return state;\n};\n\ninterface State {\n    isLoading: boolean;\n    identity?: UserIdentity;\n    error?: any;\n}\n\nexport default useGetIdentity;\n","import { useCallback } from 'react';\n\nimport useAuthProvider from './useAuthProvider';\nimport useLogout from './useLogout';\nimport { useNotify } from '../notification';\nimport { useNavigate } from 'react-router';\n\nlet timer;\n\n/**\n * Returns a callback used to call the authProvider.checkError() method\n * and an error from the dataProvider. If the authProvider rejects the call,\n * the hook logs the user out and shows a logged out notification.\n *\n * Used in the useDataProvider hook to check for access denied responses\n * (e.g. 401 or 403 responses) and trigger a logout.\n *\n * @see useLogout\n * @see useDataProvider\n *\n * @returns {Function} logoutIfAccessDenied callback\n *\n * @example\n *\n * import { useLogoutIfAccessDenied, useNotify, DataProviderContext } from 'react-admin';\n *\n * const FetchRestrictedResource = () => {\n *     const dataProvider = useContext(DataProviderContext);\n *     const logoutIfAccessDenied = useLogoutIfAccessDenied();\n *     const notify = useNotify()\n *     useEffect(() => {\n *         dataProvider.getOne('secret', { id: 123 })\n *             .catch(error => {\n *                  logoutIfAccessDenied(error);\n *                  notify('server error', 'warning');\n *              })\n *     }, []);\n *     // ...\n * }\n */\nconst useLogoutIfAccessDenied = (): LogoutIfAccessDenied => {\n    const authProvider = useAuthProvider();\n    const logout = useLogout();\n    const notify = useNotify();\n    const navigate = useNavigate();\n    const logoutIfAccessDenied = useCallback(\n        (error?: any, disableNotification?: boolean) =>\n            authProvider\n                .checkError(error)\n                .then(() => false)\n                .catch(async e => {\n                    const logoutUser = e?.logoutUser ?? true;\n\n                    //manual debounce\n                    if (timer) {\n                        // side effects already triggered in this tick, exit\n                        return true;\n                    }\n                    timer = setTimeout(() => {\n                        timer = undefined;\n                    }, 0);\n\n                    const shouldNotify = !(\n                        disableNotification ||\n                        (e && e.message === false) ||\n                        (error && error.message === false)\n                    );\n                    if (shouldNotify) {\n                        // notify only if not yet logged out\n                        authProvider\n                            .checkAuth({})\n                            .then(() => {\n                                if (logoutUser) {\n                                    notify(\n                                        getErrorMessage(\n                                            e,\n                                            'ra.notification.logged_out'\n                                        ),\n                                        { type: 'warning' }\n                                    );\n                                } else {\n                                    notify(\n                                        getErrorMessage(\n                                            e,\n                                            'ra.notification.not_authorized'\n                                        ),\n                                        { type: 'warning' }\n                                    );\n                                }\n                            })\n                            .catch(() => {});\n                    }\n                    const redirectTo =\n                        e && e.redirectTo\n                            ? e.redirectTo\n                            : error && error.redirectTo\n                            ? error.redirectTo\n                            : undefined;\n\n                    if (logoutUser) {\n                        logout({}, redirectTo);\n                    } else {\n                        navigate(redirectTo);\n                    }\n\n                    return true;\n                }),\n        [authProvider, logout, notify, navigate]\n    );\n    return authProvider\n        ? logoutIfAccessDenied\n        : logoutIfAccessDeniedWithoutProvider;\n};\n\nconst logoutIfAccessDeniedWithoutProvider = () => Promise.resolve(false);\n\n/**\n * Call the authProvider.authError() method, using the error passed as argument.\n * If the authProvider rejects the call, logs the user out and shows a logged out notification.\n *\n * @param {Error} error An Error object (usually returned by the dataProvider)\n * @param {boolean} disableNotification Avoid showing a notification after the user is logged out. false by default.\n *\n * @return {Promise} Resolved to true if there was a logout, false otherwise\n */\ntype LogoutIfAccessDenied = (\n    error?: any,\n    /** @deprecated to disable the notification, authProvider.checkAuth() should return an object with an error property set to true */\n    disableNotification?: boolean\n) => Promise<boolean>;\n\nconst getErrorMessage = (error, defaultMessage) =>\n    typeof error === 'string'\n        ? error\n        : typeof error === 'undefined' || !error.message\n        ? defaultMessage\n        : error.message;\n\nexport default useLogoutIfAccessDenied;\n","export type UserCheck = (\n    payload: object,\n    pathName: string,\n    routeParams?: object\n) => void;\n\nexport const AUTH_LOGIN = 'AUTH_LOGIN';\nexport const AUTH_CHECK = 'AUTH_CHECK';\nexport const AUTH_ERROR = 'AUTH_ERROR';\nexport const AUTH_LOGOUT = 'AUTH_LOGOUT';\nexport const AUTH_GET_PERMISSIONS = 'AUTH_GET_PERMISSIONS';\n\nexport type AuthActionType =\n    | typeof AUTH_LOGIN\n    | typeof AUTH_LOGOUT\n    | typeof AUTH_ERROR\n    | typeof AUTH_CHECK\n    | typeof AUTH_GET_PERMISSIONS;\n","import {\n    AUTH_LOGIN,\n    AUTH_LOGOUT,\n    AUTH_CHECK,\n    AUTH_ERROR,\n    AUTH_GET_PERMISSIONS,\n} from './types';\nimport { AuthProvider, LegacyAuthProvider } from '../types';\n\n/**\n * Turn a function-based authProvider to an object-based one\n *\n * Allows using legacy authProviders transparently.\n *\n * @param {Function} legacyAuthProvider A legacy authProvider (type, params) => Promise<any>\n *\n * @returns {Object} An authProvider that react-admin can use\n */\nexport default (legacyAuthProvider: LegacyAuthProvider): AuthProvider => {\n    const authProvider = (...args) => legacyAuthProvider.apply(null, args);\n    authProvider.login = params => legacyAuthProvider(AUTH_LOGIN, params);\n    authProvider.logout = params => legacyAuthProvider(AUTH_LOGOUT, params);\n    authProvider.checkAuth = params => legacyAuthProvider(AUTH_CHECK, params);\n    authProvider.checkError = error => legacyAuthProvider(AUTH_ERROR, error);\n    authProvider.getPermissions = params =>\n        legacyAuthProvider(AUTH_GET_PERMISSIONS, params);\n    return authProvider;\n};\n","import * as React from 'react';\nimport { ReactNode } from 'react';\n\nimport { useAuthenticated } from './useAuthenticated';\n\n/**\n * Restrict access to children to authenticated users.\n * Redirects anonymous users to the login page.\n *\n * Use it to decorate your custom page components to require\n * authentication.\n *\n * You can set additional `authParams` at will if your authProvider\n * requires it.\n *\n * @see useAuthenticated\n *\n * @example\n *     import { Authenticated } from 'react-admin';\n *\n *     const CustomRoutes = [\n *         <Route path=\"/foo\" render={() =>\n *             <Authenticated authParams={{ foo: 'bar' }}>\n *                 <Foo />\n *             </Authenticated>\n *         } />\n *     ];\n *     const App = () => (\n *         <Admin customRoutes={customRoutes}>\n *             ...\n *         </Admin>\n *     );\n */\nexport const Authenticated = (props: AuthenticatedProps) => {\n    const { authParams, children } = props;\n    useAuthenticated({ params: authParams });\n    // render the child even though the useAuthenticated() call isn't finished (optimistic rendering)\n    // the above hook will log out if the authProvider doesn't validate that the user is authenticated\n    return <>{children}</>;\n};\n\nexport interface AuthenticatedProps {\n    children: ReactNode;\n    authParams?: object;\n}\n","export const GET_LIST = 'GET_LIST';\nexport const GET_ONE = 'GET_ONE';\nexport const GET_MANY = 'GET_MANY';\nexport const GET_MANY_REFERENCE = 'GET_MANY_REFERENCE';\nexport const CREATE = 'CREATE';\nexport const UPDATE = 'UPDATE';\nexport const UPDATE_MANY = 'UPDATE_MANY';\nexport const DELETE = 'DELETE';\nexport const DELETE_MANY = 'DELETE_MANY';\n\nexport const fetchActionsWithRecordResponse = ['getOne', 'create', 'update'];\nexport const fetchActionsWithArrayOfIdentifiedRecordsResponse = [\n    'getList',\n    'getMany',\n    'getManyReference',\n];\nexport const fetchActionsWithArrayOfRecordsResponse = [\n    ...fetchActionsWithArrayOfIdentifiedRecordsResponse,\n    'updateMany',\n    'deleteMany',\n];\nexport const fetchActionsWithTotalResponse = ['getList', 'getManyReference'];\n\nexport const sanitizeFetchType = (fetchType: string) => {\n    switch (fetchType) {\n        case GET_LIST:\n            return 'getList';\n        case GET_ONE:\n            return 'getOne';\n        case GET_MANY:\n            return 'getMany';\n        case GET_MANY_REFERENCE:\n            return 'getManyReference';\n        case CREATE:\n            return 'create';\n        case UPDATE:\n            return 'update';\n        case UPDATE_MANY:\n            return 'updateMany';\n        case DELETE:\n            return 'delete';\n        case DELETE_MANY:\n            return 'deleteMany';\n        default:\n            return fetchType;\n    }\n};\n","import {\n    CREATE,\n    DELETE,\n    DELETE_MANY,\n    GET_LIST,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    GET_ONE,\n    UPDATE,\n    UPDATE_MANY,\n} from './dataFetchActions';\nimport { LegacyDataProvider, DataProvider } from '../types';\n\nconst defaultDataProvider = () => Promise.resolve();\ndefaultDataProvider.create = () => Promise.resolve(null);\ndefaultDataProvider.delete = () => Promise.resolve(null);\ndefaultDataProvider.deleteMany = () => Promise.resolve(null);\ndefaultDataProvider.getList = () => Promise.resolve(null);\ndefaultDataProvider.getMany = () => Promise.resolve(null);\ndefaultDataProvider.getManyReference = () => Promise.resolve(null);\ndefaultDataProvider.getOne = () => Promise.resolve(null);\ndefaultDataProvider.update = () => Promise.resolve(null);\ndefaultDataProvider.updateMany = () => Promise.resolve(null);\n\nconst fetchMap = {\n    create: CREATE,\n    delete: DELETE,\n    deleteMany: DELETE_MANY,\n    getList: GET_LIST,\n    getMany: GET_MANY,\n    getManyReference: GET_MANY_REFERENCE,\n    getOne: GET_ONE,\n    update: UPDATE,\n    updateMany: UPDATE_MANY,\n};\n\ninterface ConvertedDataProvider extends DataProvider {\n    (type: string, resource: string, params: any): Promise<any>;\n}\n/**\n * Turn a function-based dataProvider to an object-based one\n *\n * Allows using legacy dataProviders transparently.\n *\n * @param {Function} legacyDataProvider A legacy dataProvider (type, resource, params) => Promise<any>\n *\n * @returns {Object} A dataProvider that react-admin can use\n */\nconst convertLegacyDataProvider = (\n    legacyDataProvider: LegacyDataProvider\n): ConvertedDataProvider => {\n    const proxy = new Proxy(defaultDataProvider, {\n        get(_, name) {\n            return (resource, params) => {\n                if (Object.keys(fetchMap).includes(name.toString())) {\n                    const fetchType = fetchMap[name.toString()];\n                    return legacyDataProvider(fetchType, resource, params);\n                }\n\n                return legacyDataProvider(name.toString(), resource, params);\n            };\n        },\n        apply(_, __, args) {\n            return legacyDataProvider.apply(legacyDataProvider, args);\n        },\n    });\n\n    return proxy;\n};\n\nexport default convertLegacyDataProvider;\n","import { createContext } from 'react';\n\nimport { DataProvider } from '../types';\n\nconst DataProviderContext = createContext<DataProvider>(null);\n\nDataProviderContext.displayName = 'DataProviderContext';\n\nexport default DataProviderContext;\n","class HttpError extends Error {\n    constructor(\n        public readonly message,\n        public readonly status,\n        public readonly body = null\n    ) {\n        super(message);\n        Object.setPrototypeOf(this, HttpError.prototype);\n        this.name = this.constructor.name;\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            this.stack = new Error(message).stack;\n        }\n        this.stack = new Error().stack;\n    }\n}\n\nexport default HttpError;\n","import HttpError from './HttpError';\nimport { stringify } from 'query-string';\n\nexport interface Options extends RequestInit {\n    user?: {\n        authenticated?: boolean;\n        token?: string;\n    };\n}\n\nexport const createHeadersFromOptions = (options: Options): Headers => {\n    const requestHeaders = (options.headers ||\n        new Headers({\n            Accept: 'application/json',\n        })) as Headers;\n    if (\n        !requestHeaders.has('Content-Type') &&\n        !(options && (!options.method || options.method === 'GET')) &&\n        !(options && options.body && options.body instanceof FormData)\n    ) {\n        requestHeaders.set('Content-Type', 'application/json');\n    }\n    if (options.user && options.user.authenticated && options.user.token) {\n        requestHeaders.set('Authorization', options.user.token);\n    }\n\n    return requestHeaders;\n};\n\nexport const fetchJson = (url, options: Options = {}) => {\n    const requestHeaders = createHeadersFromOptions(options);\n\n    return fetch(url, { ...options, headers: requestHeaders })\n        .then(response =>\n            response.text().then(text => ({\n                status: response.status,\n                statusText: response.statusText,\n                headers: response.headers,\n                body: text,\n            }))\n        )\n        .then(({ status, statusText, headers, body }) => {\n            let json;\n            try {\n                json = JSON.parse(body);\n            } catch (e) {\n                // not json, no big deal\n            }\n            if (status < 200 || status >= 300) {\n                return Promise.reject(\n                    new HttpError(\n                        (json && json.message) || statusText,\n                        status,\n                        json\n                    )\n                );\n            }\n            return Promise.resolve({ status, headers, body, json });\n        });\n};\n\nexport const queryParameters = stringify;\n\nconst isValidObject = value => {\n    if (!value) {\n        return false;\n    }\n\n    const isArray = Array.isArray(value);\n    const isBuffer = typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n    const isObject =\n        Object.prototype.toString.call(value) === '[object Object]';\n    const hasKeys = !!Object.keys(value).length;\n\n    return !isArray && !isBuffer && isObject && hasKeys;\n};\n\nexport const flattenObject = (value, path = []) => {\n    if (isValidObject(value)) {\n        return Object.assign(\n            {},\n            ...Object.keys(value).map(key =>\n                flattenObject(value[key], path.concat([key]))\n            )\n        );\n    } else {\n        return path.length ? { [path.join('.')]: value } : value;\n    }\n};\n","import EventEmitter from 'eventemitter3';\n\nexport default new EventEmitter();\n","export const defaultDataProvider = {\n    create: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    delete: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    deleteMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getList: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getManyReference: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getOne: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    update: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    updateMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n};\n","import { DataProvider } from '../types';\nimport { defaultDataProvider } from './defaultDataProvider';\n\nexport type DataProviderMatcher = (resource: string) => DataProvider;\n\n/**\n * Combine multiple data providers into one.\n *\n * @param dataProviderMatcher A function that returns a data provider for a given resource.\n *\n * @example\n * const dataProvider = combineDataProviders(resource => {\n *    switch(resource) {\n *       case 'posts':\n *       case 'comments':\n *          return dataProvider1;\n *       case 'users':\n *          return dataProvider2;\n *       default:\n *         throw new Error('Unknown resource');\n *    }\n * });\n */\nexport const combineDataProviders = (\n    dataProviderMatcher: DataProviderMatcher\n): DataProvider =>\n    new Proxy(defaultDataProvider, {\n        get: (target, name) => {\n            return (resource, params) => {\n                if (typeof name === 'symbol' || name === 'then') {\n                    return;\n                }\n                return dataProviderMatcher(resource)[name](resource, params);\n            };\n        },\n    });\n","import { DataProvider } from '../types';\n\n/**\n * A dataProvider meant to be used in tests only. You can override any of its methods by passing a partial dataProvider.\n */\nexport const testDataProvider = (\n    overrides?: Partial<DataProvider>\n): DataProvider => {\n    return {\n        getList: () => Promise.resolve({ data: [], total: 0 }),\n        getOne: () => Promise.resolve({ data: undefined }),\n        getMany: () => Promise.resolve({ data: [] }),\n        getManyReference: () => Promise.resolve({ data: [], total: 0 }),\n        create: () => Promise.resolve({ data: undefined }),\n        update: () => Promise.resolve({ data: undefined }),\n        updateMany: () => Promise.resolve({ data: [] }),\n        delete: () => Promise.resolve({ data: undefined }),\n        deleteMany: () => Promise.resolve({ data: [] }),\n        ...overrides,\n    };\n};\n","import { useContext, useMemo } from 'react';\n\nimport DataProviderContext from './DataProviderContext';\nimport { defaultDataProvider } from './defaultDataProvider';\nimport validateResponseFormat from './validateResponseFormat';\nimport { DataProvider } from '../types';\nimport useLogoutIfAccessDenied from '../auth/useLogoutIfAccessDenied';\n\n/**\n * Hook for getting a dataProvider\n *\n * Gets a dataProvider object, which behaves just like the real dataProvider\n * (same methods returning a Promise). But it's actually a Proxy object,\n * which validates the response format, and logs the user out upon error\n * if authProvider.checkError() rejects.\n *\n * @return dataProvider\n *\n * @example Basic usage\n *\n * import * as React from 'react';\n * import { useState } from 'react';\n * import { useDataProvider } from 'react-admin';\n *\n * const PostList = () => {\n *      const [posts, setPosts] = useState([])\n *      const dataProvider = useDataProvider();\n *      useEffect(() => {\n *          dataProvider.getList('posts', { filter: { status: 'pending' }})\n *            .then(({ data }) => setPosts(data));\n *      }, [])\n *\n *      return (\n *          <Fragment>\n *              {posts.map((post, key) => <PostDetail post={post} key={key} />)}\n *          </Fragment>\n *     );\n * }\n *\n * @example Handling all states (loading, error, success)\n *\n * import { useState, useEffect } from 'react';\n * import { useDataProvider } from 'react-admin';\n *\n * const UserProfile = ({ userId }) => {\n *     const dataProvider = useDataProvider();\n *     const [user, setUser] = useState();\n *     const [loading, setLoading] = useState(true);\n *     const [error, setError] = useState();\n *     useEffect(() => {\n *         dataProvider.getOne('users', { id: userId })\n *             .then(({ data }) => {\n *                 setUser(data);\n *                 setLoading(false);\n *             })\n *             .catch(error => {\n *                 setError(error);\n *                 setLoading(false);\n *             })\n *     }, []);\n *\n *     if (loading) return <Loading />;\n *     if (error) return <Error />\n *     if (!user) return null;\n *\n *     return (\n *         <ul>\n *             <li>Name: {user.name}</li>\n *             <li>Email: {user.email}</li>\n *         </ul>\n *     )\n * }\n */\nexport const useDataProvider = <\n    TDataProvider extends DataProvider = DataProvider\n>(): TDataProvider => {\n    const dataProvider = ((useContext(DataProviderContext) ||\n        defaultDataProvider) as unknown) as TDataProvider;\n\n    const logoutIfAccessDenied = useLogoutIfAccessDenied();\n\n    const dataProviderProxy = useMemo(() => {\n        return new Proxy(dataProvider, {\n            get: (target, name) => {\n                if (typeof name === 'symbol' || name === 'then') {\n                    return;\n                }\n                return (...args) => {\n                    const type = name.toString();\n\n                    if (typeof dataProvider[type] !== 'function') {\n                        throw new Error(\n                            `Unknown dataProvider function: ${type}`\n                        );\n                    }\n\n                    try {\n                        return dataProvider[type]\n                            .apply(dataProvider, args)\n                            .then(response => {\n                                if (process.env.NODE_ENV !== 'production') {\n                                    validateResponseFormat(response, type);\n                                }\n                                return response;\n                            })\n                            .catch(error => {\n                                if (process.env.NODE_ENV !== 'production') {\n                                    console.error(error);\n                                }\n                                return logoutIfAccessDenied(error).then(\n                                    loggedOut => {\n                                        if (loggedOut) return;\n                                        throw error;\n                                    }\n                                );\n                            });\n                    } catch (e) {\n                        if (process.env.NODE_ENV !== 'production') {\n                            console.error(e);\n                        }\n                        throw new Error(\n                            'The dataProvider threw an error. It should return a rejected Promise instead.'\n                        );\n                    }\n                };\n            },\n        });\n    }, [dataProvider, logoutIfAccessDenied]);\n\n    return dataProviderProxy;\n};\n","import {\n    fetchActionsWithRecordResponse,\n    fetchActionsWithArrayOfIdentifiedRecordsResponse,\n    fetchActionsWithArrayOfRecordsResponse,\n    fetchActionsWithTotalResponse,\n} from './dataFetchActions';\n\nfunction validateResponseFormat(\n    response,\n    type,\n    logger = console.error // eslint-disable-line no-console\n) {\n    if (!response) {\n        logger(`The dataProvider returned an empty response for '${type}'.`);\n        throw new Error('ra.notification.data_provider_error');\n    }\n    if (!response.hasOwnProperty('data')) {\n        logger(\n            `The response to '${type}' must be like { data: ... }, but the received response does not have a 'data' key. The dataProvider is probably wrong for '${type}'.`\n        );\n        throw new Error('ra.notification.data_provider_error');\n    }\n    if (\n        fetchActionsWithArrayOfRecordsResponse.includes(type) &&\n        !Array.isArray(response.data)\n    ) {\n        logger(\n            `The response to '${type}' must be like { data : [...] }, but the received data is not an array. The dataProvider is probably wrong for '${type}'`\n        );\n        throw new Error('ra.notification.data_provider_error');\n    }\n    if (\n        fetchActionsWithArrayOfIdentifiedRecordsResponse.includes(type) &&\n        Array.isArray(response.data) &&\n        response.data.length > 0 &&\n        !response.data[0].hasOwnProperty('id')\n    ) {\n        logger(\n            `The response to '${type}' must be like { data : [{ id: 123, ...}, ...] }, but the received data items do not have an 'id' key. The dataProvider is probably wrong for '${type}'`\n        );\n        throw new Error('ra.notification.data_provider_error');\n    }\n    if (\n        fetchActionsWithRecordResponse.includes(type) &&\n        !response.data.hasOwnProperty('id')\n    ) {\n        logger(\n            `The response to '${type}' must be like { data: { id: 123, ... } }, but the received data does not have an 'id' key. The dataProvider is probably wrong for '${type}'`\n        );\n        throw new Error('ra.notification.data_provider_error');\n    }\n    if (\n        fetchActionsWithTotalResponse.includes(type) &&\n        !response.hasOwnProperty('total') &&\n        !response.hasOwnProperty('pageInfo')\n    ) {\n        logger(\n            `The response to '${type}' must be like  { data: [...], total: 123 }, but the received response does not have a 'total' key. The dataProvider is probably wrong for '${type}'`\n        );\n        throw new Error('ra.notification.data_provider_error');\n    }\n}\n\nexport default validateResponseFormat;\n","import { useEffect, useState } from 'react';\nimport { useQueryClient, QueryObserver } from 'react-query';\n\n/**\n * Check if react-query has already fetched data for a query key.\n *\n * This hook is reactive.\n *\n * @example\n * const isCustomerLoaded = useIsDataLoaded(['customers', 'getOne', { id: customerId }]);\n *\n * @returns {boolean} true if the data is loaded, false otherwise\n */\nexport const useIsDataLoaded = (\n    queryKey: any,\n    options: { enabled?: boolean } = {}\n) => {\n    const { enabled = true } = options;\n    const queryClient = useQueryClient();\n    const [isDataLoaded, setDataLoaded] = useState<boolean>(() => {\n        if (!enabled) {\n            return false;\n        }\n        return queryClient.getQueryData(queryKey) !== undefined;\n    });\n\n    useEffect(() => {\n        if (!enabled) return;\n        if (queryClient.getQueryData(queryKey) === undefined) {\n            const observer = new QueryObserver(queryClient, { queryKey });\n            const unsubscribe = observer.subscribe(result => {\n                setDataLoaded(!result.isLoading);\n                unsubscribe();\n            });\n            return unsubscribe;\n        }\n    }, [enabled, queryKey, queryClient]);\n\n    return isDataLoaded;\n};\n","import React from 'react';\n\nimport { notifyManager, useQueryClient } from 'react-query';\n\n/**\n * Get the state of the dataProvider connection.\n *\n * Returns true if a query or a mutation is pending.\n *\n * Custom implementation because react-query's useIsFetching and useIsMutating\n * render each time the number of active queries changes, which is too often.\n *\n * @see useIsFetching\n * @see useIsMutating\n */\nexport const useLoading = (): boolean => {\n    const client = useQueryClient();\n    const mountedRef = React.useRef(false);\n    const isFetchingRef = React.useRef(client.isFetching() > 0);\n    const isMutatingRef = React.useRef(client.isMutating() > 0);\n\n    const [isLoading, setIsLoading] = React.useState<boolean>(\n        isFetchingRef.current || isMutatingRef.current\n    );\n\n    React.useEffect(() => {\n        mountedRef.current = true;\n\n        const unsubscribeQueryCache = client.getQueryCache().subscribe(\n            notifyManager.batchCalls(() => {\n                if (mountedRef.current) {\n                    isFetchingRef.current = client.isFetching() > 0;\n                    setIsLoading(\n                        isFetchingRef.current || isMutatingRef.current\n                    );\n                }\n            })\n        );\n\n        const unsubscribeMutationCache = client.getMutationCache().subscribe(\n            notifyManager.batchCalls(() => {\n                if (mountedRef.current) {\n                    isMutatingRef.current = client.isMutating() > 0;\n                    setIsLoading(\n                        isFetchingRef.current || isMutatingRef.current\n                    );\n                }\n            })\n        );\n\n        return () => {\n            mountedRef.current = false;\n            unsubscribeQueryCache();\n            unsubscribeMutationCache();\n        };\n    }, [client]);\n\n    return isLoading;\n};\n","import { useCallback } from 'react';\nimport { useQueryClient } from 'react-query';\n\n/**\n * Hook for triggering a page refresh. Returns a callback function.\n *\n * The callback invalidates all queries and refetches the active ones.\n * Any component depending on react-query data will be re-rendered.\n *\n * @example\n *\n * const refresh = useRefresh();\n * const handleClick = () => {\n *     refresh();\n * };\n */\nexport const useRefresh = () => {\n    const queryClient = useQueryClient();\n    return useCallback(() => {\n        queryClient.invalidateQueries();\n    }, [queryClient]);\n};\n","import { RaRecord, GetOneParams } from '../types';\nimport { useQuery, UseQueryOptions, UseQueryResult } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetOne } from 'react-admin';\n *\n * const UserProfile = ({ record }) => {\n *     const { data, isLoading, error } = useGetOne('users', { id: record.id });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport const useGetOne = <RecordType extends RaRecord = any>(\n    resource: string,\n    { id, meta }: GetOneParams<RecordType>,\n    options?: UseQueryOptions<RecordType>\n): UseGetOneHookValue<RecordType> => {\n    const dataProvider = useDataProvider();\n    return useQuery<RecordType, unknown, RecordType>(\n        // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n        // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n        // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n        [resource, 'getOne', { id: String(id), meta }],\n        () =>\n            dataProvider\n                .getOne<RecordType>(resource, { id, meta })\n                .then(({ data }) => data),\n        options\n    );\n};\n\nexport type UseGetOneHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType>;\n","import {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n} from 'react-query';\n\nimport { RaRecord, GetListParams, GetListResult } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isLoading, error } = useGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(item =>\n *         <li key={item.id}>{item.title}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetList = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetListParams> = {},\n    options?: UseQueryOptions<GetListResult<RecordType>, Error>\n): UseGetListHookValue<RecordType> => {\n    const {\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const result = useQuery<\n        GetListResult<RecordType>,\n        Error,\n        GetListResult<RecordType>\n    >(\n        [resource, 'getList', { pagination, sort, filter, meta }],\n        () =>\n            dataProvider\n                .getList<RecordType>(resource, {\n                    pagination,\n                    sort,\n                    filter,\n                    meta,\n                })\n                .then(({ data, total, pageInfo }) => ({\n                    data,\n                    total,\n                    pageInfo,\n                })),\n        {\n            onSuccess: ({ data }) => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            ...options,\n        }\n    );\n\n    return (result.data\n        ? {\n              ...result,\n              data: result.data?.data,\n              total: result.data?.total,\n              pageInfo: result.data?.pageInfo,\n          }\n        : result) as UseQueryResult<RecordType[], Error> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n};\n\nexport type UseGetListHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error> & {\n    total?: number;\n    pageInfo?: {\n        hasNextPage?: boolean;\n        hasPreviousPage?: boolean;\n    };\n};\n","import {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n    hashQueryKey,\n} from 'react-query';\n\nimport { RaRecord, GetManyParams } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetMany = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyParams> = {},\n    options?: UseQueryOptions<RecordType[], Error>\n): UseGetManyHookValue<RecordType> => {\n    const { ids, meta } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n\n    return useQuery<RecordType[], Error, RecordType[]>(\n        [resource, 'getMany', { ids: ids.map(id => String(id)), meta }],\n        () => {\n            if (!ids || ids.length === 0) {\n                // no need to call the dataProvider\n                return Promise.resolve([]);\n            }\n            return dataProvider\n                .getMany<RecordType>(resource, { ids, meta })\n                .then(({ data }) => data);\n        },\n        {\n            placeholderData: () => {\n                const records = ids.map(id => {\n                    const queryHash = hashQueryKey([\n                        resource,\n                        'getOne',\n                        { id: String(id), meta },\n                    ]);\n                    return queryCache.get<RecordType>(queryHash)?.state?.data;\n                });\n                if (records.some(record => record === undefined)) {\n                    return undefined;\n                } else {\n                    return records;\n                }\n            },\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            retry: false,\n            ...options,\n        }\n    );\n};\n\nexport type UseGetManyHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error>;\n","import { useMemo } from 'react';\nimport {\n    QueryClient,\n    useQueryClient,\n    useQuery,\n    UseQueryOptions,\n    hashQueryKey,\n} from 'react-query';\nimport union from 'lodash/union';\n\nimport { UseGetManyHookValue } from './useGetMany';\nimport { Identifier, RaRecord, GetManyParams, DataProvider } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, isFetching: false, refetch }\n * - error: { error: [error from response], isLoading: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isLoading, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, isLoading, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nexport const useGetManyAggregate = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: GetManyParams,\n    options: UseQueryOptions<RecordType[], Error> = {}\n): UseGetManyHookValue<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n    const { ids, meta } = params;\n    const placeholderData = useMemo(() => {\n        const records = ids.map(id => {\n            const queryHash = hashQueryKey([\n                resource,\n                'getOne',\n                { id: String(id), meta },\n            ]);\n            return queryCache.get<RecordType>(queryHash)?.state?.data;\n        });\n        if (records.some(record => record === undefined)) {\n            return undefined;\n        } else {\n            return records;\n        }\n    }, [ids, queryCache, resource, meta]);\n\n    return useQuery<RecordType[], Error, RecordType[]>(\n        [resource, 'getMany', { ids: ids.map(id => String(id)), meta }],\n        () =>\n            new Promise((resolve, reject) => {\n                if (!ids || ids.length === 0) {\n                    // no need to call the dataProvider\n                    return resolve([]);\n                }\n                // debounced / batched fetch\n                return callGetManyQueries({\n                    resource,\n                    ids,\n                    meta,\n                    resolve,\n                    reject,\n                    dataProvider,\n                    queryClient,\n                });\n            }),\n        {\n            placeholderData,\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            retry: false,\n            ...options,\n        }\n    );\n};\n\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\nconst batch = fn => {\n    let capturedArgs = [];\n    let timeout = null;\n    return arg => {\n        capturedArgs.push(arg);\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            timeout = null;\n            fn([...capturedArgs]);\n            capturedArgs = [];\n        }, 0);\n    };\n};\n\ninterface GetManyCallArgs {\n    resource: string;\n    ids: Identifier[];\n    meta?: any;\n    resolve: (data: any[]) => void;\n    reject: (error?: any) => void;\n    dataProvider: DataProvider;\n    queryClient: QueryClient;\n}\n\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\nconst callGetManyQueries = batch((calls: GetManyCallArgs[]) => {\n    const dataProvider = calls[0].dataProvider;\n    const queryClient = calls[0].queryClient;\n\n    /**\n     * Aggregate calls by resource\n     *\n     * callsByResource will look like:\n     * {\n     *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     * }\n     */\n    const callsByResource = calls.reduce((acc, callArgs) => {\n        if (!acc[callArgs.resource]) {\n            acc[callArgs.resource] = [];\n        }\n        acc[callArgs.resource].push(callArgs);\n        return acc;\n    }, {} as { [resource: string]: GetManyCallArgs[] });\n\n    /**\n     * For each resource, aggregate ids and call dataProvider.getMany() once\n     */\n    Object.keys(callsByResource).forEach(resource => {\n        const callsForResource = callsByResource[resource];\n\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        const aggregatedIds = callsForResource\n            .reduce((acc, { ids }) => union(acc, ids), []) // concat + unique\n            .filter(v => v != null && v !== ''); // remove null values\n        const uniqueMeta = callsForResource.reduce(\n            (acc, { meta }) => meta || acc,\n            undefined\n        );\n\n        if (aggregatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            callsForResource.forEach(({ resolve }) => {\n                resolve([]);\n            });\n            return;\n        }\n\n        if (\n            callsForResource.find(\n                ({ ids }) =>\n                    JSON.stringify(ids) === JSON.stringify(aggregatedIds)\n            )\n        ) {\n            // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n            // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n            // Therefore, we reply with the dataProvider\n            const {\n                dataProvider,\n                resource,\n                ids,\n                meta,\n                resolve,\n                reject,\n            } = callsForResource[0];\n            dataProvider\n                .getMany<any>(resource, { ids, meta })\n                .then(({ data }) => data)\n                .then(resolve, reject);\n            return;\n        }\n\n        /**\n         * Call dataProvider.getMany() with the aggregatedIds,\n         * and resolve each of the promises using the results\n         */\n        queryClient\n            .fetchQuery<any[], Error, any[]>(\n                [\n                    resource,\n                    'getMany',\n                    {\n                        ids: aggregatedIds.map(id => String(id)),\n                        meta: uniqueMeta,\n                    },\n                ],\n                () =>\n                    dataProvider\n                        .getMany<any>(resource, {\n                            ids: aggregatedIds,\n                            meta: uniqueMeta,\n                        })\n                        .then(({ data }) => data)\n            )\n            .then(data => {\n                callsForResource.forEach(({ ids, resolve }) => {\n                    resolve(data.filter(record => ids.includes(record.id)));\n                });\n            })\n            .catch(error =>\n                callsForResource.forEach(({ reject }) => reject(error))\n            );\n    });\n});\n","import {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n} from 'react-query';\n\nimport {\n    RaRecord,\n    GetManyReferenceParams,\n    GetManyReferenceResult,\n} from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getManyReference() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getManyReference parameters { target, id, pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.target The target resource key, e.g. 'post_id'\n * @prop params.id The identifier of the record to look for in target, e.g. '123'\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetManyReference } from 'react-admin';\n *\n * const PostComments = ({ record }) => {\n *     // fetch all comments related to the current record\n *     const { data, isLoading, error } = useGetManyReference(\n *         'comments',\n *         { target: 'post_id', id: record.id, pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(comment =>\n *         <li key={comment.id}>{comment.body}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetManyReference = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyReferenceParams> = {},\n    options?: UseQueryOptions<{ data: RecordType[]; total: number }, Error>\n): UseGetManyReferenceHookValue<RecordType> => {\n    const {\n        target,\n        id,\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const result = useQuery<\n        GetManyReferenceResult<RecordType>,\n        Error,\n        GetManyReferenceResult<RecordType>\n    >(\n        [\n            resource,\n            'getManyReference',\n            { target, id, pagination, sort, filter, meta },\n        ],\n        () =>\n            dataProvider\n                .getManyReference<RecordType>(resource, {\n                    target,\n                    id,\n                    pagination,\n                    sort,\n                    filter,\n                    meta,\n                })\n                .then(({ data, total, pageInfo }) => ({\n                    data,\n                    total,\n                    pageInfo,\n                })),\n        {\n            onSuccess: ({ data }) => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            ...options,\n        }\n    );\n\n    return (result.data\n        ? {\n              ...result,\n              data: result.data?.data,\n              total: result.data?.total,\n              pageInfo: result.data?.pageInfo,\n          }\n        : result) as UseQueryResult<RecordType[], Error> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n};\n\nexport type UseGetManyReferenceHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error> & {\n    total?: number;\n    pageInfo?: {\n        hasNextPage?: boolean;\n        hasPreviousPage?: boolean;\n    };\n};\n","import { useRef } from 'react';\nimport {\n    useMutation,\n    UseMutationOptions,\n    UseMutationResult,\n    useQueryClient,\n    MutateOptions,\n} from 'react-query';\n\nimport { useDataProvider } from './useDataProvider';\nimport { RaRecord, CreateParams } from '../types';\n\n/**\n * Get a callback to call the dataProvider.create() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The create parameters { data }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.data The record to create, e.g. { title: 'hello, world' }\n *\n * @returns The current mutation state. Destructure as [create, { data, error, isLoading }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [create, { isLoading: false, isIdle: true }]\n * - start:   [create, { isLoading: true }]\n * - success: [create, { data: [data from response], isLoading: false, isSuccess: true }]\n * - error:   [create, { error: [error from response], isLoading: false, isError: true }]\n *\n * The create() function must be called with a resource and a parameter object: create(resource, { data, meta }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://react-query.tanstack.com/reference/useMutation\n *\n * @example // set params when calling the create callback\n *\n * import { useCreate } from 'react-admin';\n *\n * const LikeButton = ({ record }) => {\n *     const like = { postId: record.id };\n *     const [create, { isLoading, error }] = useCreate();\n *     const handleClick = () => {\n *         create('likes', { data: like })\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={handleClick}>Like</button>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useCreate } from 'react-admin';\n *\n * const LikeButton = ({ record }) => {\n *     const like = { postId: record.id };\n *     const [create, { isLoading, error }] = useCreate('likes', { data: like });\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={() => create()}>Like</button>;\n * };\n *\n * @example // TypeScript\n * const [create, { data }] = useCreate<Product>('products', { data: product });\n *                    \\-- data is Product\n */\nexport const useCreate = <RecordType extends RaRecord = any>(\n    resource?: string,\n    params: Partial<CreateParams<Partial<RecordType>>> = {},\n    options: UseCreateOptions<RecordType> = {}\n): UseCreateResult<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const paramsRef = useRef<Partial<CreateParams<Partial<RecordType>>>>(\n        params\n    );\n\n    const mutation = useMutation<\n        RecordType,\n        unknown,\n        Partial<UseCreateMutateParams<RecordType>>\n    >(\n        ({\n            resource: callTimeResource = resource,\n            data: callTimeData = paramsRef.current.data,\n            meta: callTimeMeta = paramsRef.current.meta,\n        } = {}) =>\n            dataProvider\n                .create<RecordType>(callTimeResource, {\n                    data: callTimeData,\n                    meta: callTimeMeta,\n                })\n                .then(({ data }) => data),\n        {\n            ...options,\n            onSuccess: (\n                data: RecordType,\n                variables: Partial<UseCreateMutateParams<RecordType>> = {},\n                context: unknown\n            ) => {\n                const { resource: callTimeResource = resource } = variables;\n                queryClient.setQueryData(\n                    [callTimeResource, 'getOne', { id: String(data.id) }],\n                    data\n                );\n\n                if (options.onSuccess) {\n                    options.onSuccess(data, variables, context);\n                }\n                // call-time success callback is executed by react-query\n            },\n        }\n    );\n\n    const create = (\n        callTimeResource: string = resource,\n        callTimeParams: Partial<CreateParams<RecordType>> = {},\n        createOptions: MutateOptions<\n            RecordType,\n            unknown,\n            Partial<UseCreateMutateParams<RecordType>>,\n            unknown\n        > & { returnPromise?: boolean } = {}\n    ) => {\n        const { returnPromise, ...reactCreateOptions } = createOptions;\n        if (returnPromise) {\n            return mutation.mutateAsync(\n                { resource: callTimeResource, ...callTimeParams },\n                createOptions\n            );\n        }\n        mutation.mutate(\n            { resource: callTimeResource, ...callTimeParams },\n            reactCreateOptions\n        );\n    };\n\n    return [create, mutation];\n};\n\nexport interface UseCreateMutateParams<RecordType extends RaRecord = any> {\n    resource?: string;\n    data?: Partial<RecordType>;\n    meta?: any;\n}\n\nexport type UseCreateOptions<\n    RecordType extends RaRecord = any\n> = UseMutationOptions<\n    RecordType,\n    unknown,\n    Partial<UseCreateMutateParams<RecordType>>\n>;\n\nexport type UseCreateResult<\n    RecordType extends RaRecord = any,\n    TReturnPromise extends boolean = boolean\n> = [\n    (\n        resource?: string,\n        params?: Partial<CreateParams<Partial<RecordType>>>,\n        options?: MutateOptions<\n            RecordType,\n            unknown,\n            Partial<UseCreateMutateParams<RecordType>>,\n            unknown\n        > & { returnPromise?: TReturnPromise }\n    ) => Promise<TReturnPromise extends true ? RecordType : void>,\n    UseMutationResult<\n        RecordType,\n        unknown,\n        Partial<UseCreateMutateParams<RecordType>>,\n        unknown\n    >\n];\n","import { useRef } from 'react';\nimport {\n    useMutation,\n    useQueryClient,\n    UseMutationOptions,\n    UseMutationResult,\n    MutateOptions,\n    QueryKey,\n} from 'react-query';\n\nimport { useDataProvider } from './useDataProvider';\nimport undoableEventEmitter from './undoableEventEmitter';\nimport { RaRecord, UpdateParams, MutationMode } from '../types';\n\n/**\n * Get a callback to call the dataProvider.update() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The update parameters { id, data, previousData, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }\n *\n * @typedef Params\n * @prop params.id The resource identifier, e.g. 123\n * @prop params.data The updates to merge into the record, e.g. { views: 10 }\n * @prop params.previousData The record before the update is applied\n * @prop params.meta Optional meta data\n *\n * @returns The current mutation state. Destructure as [update, { data, error, isLoading }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [update, { isLoading: false, isIdle: true }]\n * - start:   [update, { isLoading: true }]\n * - success: [update, { data: [data from response], isLoading: false, isSuccess: true }]\n * - error:   [update, { error: [error from response], isLoading: false, isError: true }]\n *\n * The update() function must be called with a resource and a parameter object: update(resource, { id, data, previousData }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://react-query.tanstack.com/reference/useMutation\n *\n * @example // set params when calling the update callback\n *\n * import { useUpdate } from 'react-admin';\n *\n * const IncreaseLikeButton = ({ record }) => {\n *     const diff = { likes: record.likes + 1 };\n *     const [update, { isLoading, error }] = useUpdate();\n *     const handleClick = () => {\n *         update('likes', { id: record.id, data: diff, previousData: record })\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={handleClick}>Like</div>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useUpdate } from 'react-admin';\n *\n * const IncreaseLikeButton = ({ record }) => {\n *     const diff = { likes: record.likes + 1 };\n *     const [update, { isLoading, error }] = useUpdate('likes', { id: record.id, data: diff, previousData: record });\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={() => update()}>Like</button>;\n * };\n *\n * @example // TypeScript\n * const [update, { data }] = useUpdate<Product>('products', { id, data: diff, previousData: product });\n *                    \\-- data is Product\n */\nexport const useUpdate = <RecordType extends RaRecord = any>(\n    resource?: string,\n    params: Partial<UpdateParams<RecordType>> = {},\n    options: UseUpdateOptions<RecordType> = {}\n): UseUpdateResult<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const { id, data, meta } = params;\n    const { mutationMode = 'pessimistic', ...reactMutationOptions } = options;\n    const mode = useRef<MutationMode>(mutationMode);\n    const paramsRef = useRef<Partial<UpdateParams<RecordType>>>(params);\n    const snapshot = useRef<Snapshot>([]);\n\n    const updateCache = ({ resource, id, data }) => {\n        // hack: only way to tell react-query not to fetch this query for the next 5 seconds\n        // because setQueryData doesn't accept a stale time option\n        const now = Date.now();\n        const updatedAt = mode.current === 'undoable' ? now + 5 * 1000 : now;\n\n        const updateColl = (old: RecordType[]) => {\n            if (!old) return;\n            const index = old.findIndex(\n                // eslint-disable-next-line eqeqeq\n                record => record.id == id\n            );\n            if (index === -1) {\n                return old;\n            }\n            return [\n                ...old.slice(0, index),\n                { ...old[index], ...data },\n                ...old.slice(index + 1),\n            ];\n        };\n\n        type GetListResult = { data?: RecordType[]; total?: number };\n\n        queryClient.setQueryData(\n            [resource, 'getOne', { id: String(id), meta }],\n            (record: RecordType) => ({ ...record, ...data }),\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getList'],\n            (res: GetListResult) =>\n                res && res.data\n                    ? { data: updateColl(res.data), total: res.total }\n                    : res,\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getMany'],\n            (coll: RecordType[]) =>\n                coll && coll.length > 0 ? updateColl(coll) : coll,\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getManyReference'],\n            (res: GetListResult) =>\n                res && res.data\n                    ? { data: updateColl(res.data), total: res.total }\n                    : res,\n            { updatedAt }\n        );\n    };\n\n    const mutation = useMutation<\n        RecordType,\n        unknown,\n        Partial<UseUpdateMutateParams<RecordType>>\n    >(\n        ({\n            resource: callTimeResource = resource,\n            id: callTimeId = paramsRef.current.id,\n            data: callTimeData = paramsRef.current.data,\n            meta: callTimeMeta = paramsRef.current.meta,\n            previousData: callTimePreviousData = paramsRef.current.previousData,\n        } = {}) =>\n            dataProvider\n                .update<RecordType>(callTimeResource, {\n                    id: callTimeId,\n                    data: callTimeData,\n                    previousData: callTimePreviousData,\n                    meta: callTimeMeta,\n                })\n                .then(({ data }) => data),\n        {\n            ...reactMutationOptions,\n            onMutate: async (\n                variables: Partial<UseUpdateMutateParams<RecordType>>\n            ) => {\n                if (reactMutationOptions.onMutate) {\n                    const userContext =\n                        (await reactMutationOptions.onMutate(variables)) || {};\n                    return {\n                        snapshot: snapshot.current,\n                        // @ts-ignore\n                        ...userContext,\n                    };\n                } else {\n                    // Return a context object with the snapshot value\n                    return { snapshot: snapshot.current };\n                }\n            },\n            onError: (\n                error: unknown,\n                variables: Partial<UseUpdateMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // If the mutation fails, use the context returned from onMutate to rollback\n                    context.snapshot.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                }\n\n                if (reactMutationOptions.onError) {\n                    return reactMutationOptions.onError(\n                        error,\n                        variables,\n                        context\n                    );\n                }\n                // call-time error callback is executed by react-query\n            },\n            onSuccess: (\n                data: RecordType,\n                variables: Partial<UseUpdateMutateParams<RecordType>> = {},\n                context: unknown\n            ) => {\n                if (mode.current === 'pessimistic') {\n                    // update the getOne and getList query cache with the new result\n                    const {\n                        resource: callTimeResource = resource,\n                        id: callTimeId = id,\n                    } = variables;\n                    updateCache({\n                        resource: callTimeResource,\n                        id: callTimeId,\n                        data,\n                    });\n\n                    if (reactMutationOptions.onSuccess) {\n                        reactMutationOptions.onSuccess(\n                            data,\n                            variables,\n                            context\n                        );\n                    }\n                    // call-time success callback is executed by react-query\n                }\n            },\n            onSettled: (\n                data: RecordType,\n                error: unknown,\n                variables: Partial<UseUpdateMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // Always refetch after error or success:\n                    context.snapshot.forEach(([key]) => {\n                        queryClient.invalidateQueries(key);\n                    });\n                }\n\n                if (reactMutationOptions.onSettled) {\n                    return reactMutationOptions.onSettled(\n                        data,\n                        error,\n                        variables,\n                        context\n                    );\n                }\n            },\n        }\n    );\n\n    const update = async (\n        callTimeResource: string = resource,\n        callTimeParams: Partial<UpdateParams<RecordType>> = {},\n        updateOptions: MutateOptions<\n            RecordType,\n            unknown,\n            Partial<UseUpdateMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode; returnPromise?: boolean } = {}\n    ) => {\n        const {\n            mutationMode,\n            returnPromise,\n            onSuccess,\n            onSettled,\n            onError,\n        } = updateOptions;\n\n        // store the hook time params *at the moment of the call*\n        // because they may change afterwards, which would break the undoable mode\n        // as the previousData would be overwritten by the optimistic update\n        paramsRef.current = params;\n\n        if (mutationMode) {\n            mode.current = mutationMode;\n        }\n\n        if (returnPromise && mode.current !== 'pessimistic') {\n            console.warn(\n                'The returnPromise parameter can only be used if the mutationMode is set to pessimistic'\n            );\n        }\n\n        if (mode.current === 'pessimistic') {\n            if (returnPromise) {\n                return mutation.mutateAsync(\n                    { resource: callTimeResource, ...callTimeParams },\n                    { onSuccess, onSettled, onError }\n                );\n            }\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSuccess, onSettled, onError }\n            );\n        }\n\n        const {\n            id: callTimeId = id,\n            data: callTimeData = data,\n            meta: callTimeMeta = meta,\n        } = callTimeParams;\n\n        // optimistic update as documented in https://react-query.tanstack.com/guides/optimistic-updates\n        // except we do it in a mutate wrapper instead of the onMutate callback\n        // to have access to success side effects\n\n        const previousRecord = queryClient.getQueryData<RecordType>([\n            callTimeResource,\n            'getOne',\n            { id: String(callTimeId), meta: callTimeMeta },\n        ]);\n\n        const queryKeys = [\n            [\n                callTimeResource,\n                'getOne',\n                { id: String(callTimeId), meta: callTimeMeta },\n            ],\n            [callTimeResource, 'getList'],\n            [callTimeResource, 'getMany'],\n            [callTimeResource, 'getManyReference'],\n        ];\n\n        /**\n         * Snapshot the previous values via queryClient.getQueriesData()\n         *\n         * The snapshotData ref will contain an array of tuples [query key, associated data]\n         *\n         * @example\n         * [\n         *   [['posts', 'getOne', { id: '1' }], { id: 1, title: 'Hello' }],\n         *   [['posts', 'getList'], { data: [{ id: 1, title: 'Hello' }], total: 1 }],\n         *   [['posts', 'getMany'], [{ id: 1, title: 'Hello' }]],\n         * ]\n         *\n         * @see https://react-query.tanstack.com/reference/QueryClient#queryclientgetqueriesdata\n         */\n        snapshot.current = queryKeys.reduce(\n            (prev, curr) => prev.concat(queryClient.getQueriesData(curr)),\n            [] as Snapshot\n        );\n\n        // Cancel any outgoing re-fetches (so they don't overwrite our optimistic update)\n        await Promise.all(\n            snapshot.current.map(([key]) => queryClient.cancelQueries(key))\n        );\n\n        // Optimistically update to the new value\n        updateCache({\n            resource: callTimeResource,\n            id: callTimeId,\n            data: callTimeData,\n        });\n\n        // run the success callbacks during the next tick\n        if (onSuccess) {\n            setTimeout(\n                () =>\n                    onSuccess(\n                        previousRecord,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n        if (reactMutationOptions.onSuccess) {\n            setTimeout(\n                () =>\n                    reactMutationOptions.onSuccess(\n                        previousRecord,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n\n        if (mode.current === 'optimistic') {\n            // call the mutate method without success side effects\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSettled, onError }\n            );\n        } else {\n            // undoable mutation: register the mutation for later\n            undoableEventEmitter.once('end', ({ isUndo }) => {\n                if (isUndo) {\n                    // rollback\n                    snapshot.current.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                } else {\n                    // call the mutate method without success side effects\n                    mutation.mutate(\n                        { resource: callTimeResource, ...callTimeParams },\n                        { onSettled, onError }\n                    );\n                }\n            });\n        }\n    };\n\n    return [update, mutation];\n};\n\ntype Snapshot = [key: QueryKey, value: any][];\n\nexport interface UseUpdateMutateParams<RecordType extends RaRecord = any> {\n    resource?: string;\n    id?: RecordType['id'];\n    data?: Partial<RecordType>;\n    previousData?: any;\n    meta?: any;\n}\n\nexport type UseUpdateOptions<\n    RecordType extends RaRecord = any\n> = UseMutationOptions<\n    RecordType,\n    unknown,\n    Partial<UseUpdateMutateParams<RecordType>>\n> & { mutationMode?: MutationMode };\n\nexport type UseUpdateResult<\n    RecordType extends RaRecord = any,\n    TReturnPromise extends boolean = boolean\n> = [\n    (\n        resource?: string,\n        params?: Partial<UpdateParams<RecordType>>,\n        options?: MutateOptions<\n            RecordType,\n            unknown,\n            Partial<UseUpdateMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode; returnPromise?: TReturnPromise }\n    ) => Promise<TReturnPromise extends true ? RecordType : void>,\n    UseMutationResult<\n        RecordType,\n        unknown,\n        Partial<UpdateParams<RecordType> & { resource?: string }>,\n        unknown\n    >\n];\n","import { useRef } from 'react';\nimport {\n    useMutation,\n    useQueryClient,\n    UseMutationOptions,\n    UseMutationResult,\n    MutateOptions,\n    QueryKey,\n} from 'react-query';\n\nimport { useDataProvider } from './useDataProvider';\nimport undoableEventEmitter from './undoableEventEmitter';\nimport { RaRecord, UpdateManyParams, MutationMode } from '../types';\nimport { Identifier } from '..';\n\n/**\n * Get a callback to call the dataProvider.updateMany() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The updateMany parameters { ids, data, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }\n *\n * @typedef Params\n * @prop params.ids The resource identifiers, e.g. [123, 456]\n * @prop params.data The updates to merge into the record, e.g. { views: 10 }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current mutation state. Destructure as [updateMany, { data, error, isLoading }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [updateMany, { isLoading: false, isIdle: true }]\n * - start:   [updateMany, { isLoading: true }]\n * - success: [updateMany, { data: [data from response], isLoading: false, isSuccess: true }]\n * - error:   [updateMany, { error: [error from response], isLoading: false, isError: true }]\n *\n * The updateMany() function must be called with a resource and a parameter object: updateMany(resource, { ids, data, previousData }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://react-query.tanstack.com/reference/useMutation\n *\n * @example // set params when calling the updateMany callback\n *\n * import { useUpdateMany } from 'react-admin';\n *\n * const BulkResetViewsButton = ({ selectedIds }) => {\n *     const [updateMany, { isLoading, error }] = useUpdateMany();\n *     const handleClick = () => {\n *         updateMany('posts', { ids: selectedIds, data: { views: 0 } });\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={handleClick}>Reset views</button>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useUpdateMany } from 'react-admin';\n *\n * const BulkResetViewsButton = ({ selectedIds }) => {\n *     const [updateMany, { isLoading, error }] = useUpdateMany('posts', { ids: selectedIds, data: { views: 0 } });\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={() => updateMany()}>Reset views</button>;\n * };\n */\nexport const useUpdateMany = <RecordType extends RaRecord = any>(\n    resource?: string,\n    params: Partial<UpdateManyParams<Partial<RecordType>>> = {},\n    options: UseUpdateManyOptions<RecordType> = {}\n): UseUpdateManyResult<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const { ids, data, meta } = params;\n    const { mutationMode = 'pessimistic', ...reactMutationOptions } = options;\n    const mode = useRef<MutationMode>(mutationMode);\n    const paramsRef = useRef<Partial<UpdateManyParams<Partial<RecordType>>>>(\n        params\n    );\n    const snapshot = useRef<Snapshot>([]);\n\n    const updateCache = async ({\n        resource,\n        ids,\n        data,\n        meta,\n    }: {\n        resource: string;\n        ids: Identifier[];\n        data: any;\n        meta?: any;\n    }) => {\n        // hack: only way to tell react-query not to fetch this query for the next 5 seconds\n        // because setQueryData doesn't accept a stale time option\n        const updatedAt =\n            mode.current === 'undoable' ? Date.now() + 1000 * 5 : Date.now();\n\n        const updateColl = (old: RecordType[]) => {\n            if (!old) return;\n            let newCollection = [...old];\n            ids.forEach(id => {\n                // eslint-disable-next-line eqeqeq\n                const index = old.findIndex(record => record.id == id);\n                if (index === -1) {\n                    return;\n                }\n                newCollection = [\n                    ...newCollection.slice(0, index),\n                    { ...newCollection[index], ...data },\n                    ...newCollection.slice(index + 1),\n                ];\n            });\n            return newCollection;\n        };\n\n        type GetListResult = { data?: RecordType[]; total?: number };\n\n        ids.forEach(id =>\n            queryClient.setQueryData(\n                [resource, 'getOne', { id: String(id), meta }],\n                (record: RecordType) => ({ ...record, ...data }),\n                { updatedAt }\n            )\n        );\n        queryClient.setQueriesData(\n            [resource, 'getList'],\n            (res: GetListResult) =>\n                res && res.data\n                    ? { data: updateColl(res.data), total: res.total }\n                    : res,\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getMany'],\n            (coll: RecordType[]) =>\n                coll && coll.length > 0 ? updateColl(coll) : coll,\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getManyReference'],\n            (res: GetListResult) =>\n                res && res.data\n                    ? { data: updateColl(res.data), total: res.total }\n                    : res,\n            { updatedAt }\n        );\n    };\n\n    const mutation = useMutation<\n        Array<RecordType['id']>,\n        unknown,\n        Partial<UseUpdateManyMutateParams<RecordType>>\n    >(\n        ({\n            resource: callTimeResource = resource,\n            ids: callTimeIds = paramsRef.current.ids,\n            data: callTimeData = paramsRef.current.data,\n            meta: callTimeMeta = paramsRef.current.meta,\n        } = {}) =>\n            dataProvider\n                .updateMany(callTimeResource, {\n                    ids: callTimeIds,\n                    data: callTimeData,\n                    meta: callTimeMeta,\n                })\n                .then(({ data }) => data),\n        {\n            ...reactMutationOptions,\n            onMutate: async (\n                variables: Partial<UseUpdateManyMutateParams<RecordType>>\n            ) => {\n                if (reactMutationOptions.onMutate) {\n                    const userContext =\n                        (await reactMutationOptions.onMutate(variables)) || {};\n                    return {\n                        snapshot: snapshot.current,\n                        // @ts-ignore\n                        ...userContext,\n                    };\n                } else {\n                    // Return a context object with the snapshot value\n                    return { snapshot: snapshot.current };\n                }\n            },\n            onError: (\n                error: unknown,\n                variables: Partial<UseUpdateManyMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // If the mutation fails, use the context returned from onMutate to rollback\n                    context.snapshot.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                }\n\n                if (reactMutationOptions.onError) {\n                    return reactMutationOptions.onError(\n                        error,\n                        variables,\n                        context\n                    );\n                }\n                // call-time error callback is executed by react-query\n            },\n            onSuccess: (\n                data: Array<RecordType['id']>,\n                variables: Partial<UseUpdateManyMutateParams<RecordType>> = {},\n                context: unknown\n            ) => {\n                if (mode.current === 'pessimistic') {\n                    // update the getOne and getList query cache with the new result\n                    const {\n                        resource: callTimeResource = resource,\n                        ids: callTimeIds = ids,\n                        meta: callTimeMeta = meta,\n                    } = variables;\n                    updateCache({\n                        resource: callTimeResource,\n                        ids: callTimeIds,\n                        data,\n                        meta: callTimeMeta,\n                    });\n\n                    if (reactMutationOptions.onSuccess) {\n                        reactMutationOptions.onSuccess(\n                            data,\n                            variables,\n                            context\n                        );\n                    }\n                    // call-time success callback is executed by react-query\n                }\n            },\n            onSettled: (\n                data: Array<RecordType['id']>,\n                error: unknown,\n                variables: Partial<UseUpdateManyMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // Always refetch after error or success:\n                    context.snapshot.forEach(([key]) => {\n                        queryClient.invalidateQueries(key);\n                    });\n                }\n\n                if (reactMutationOptions.onSettled) {\n                    return reactMutationOptions.onSettled(\n                        data,\n                        error,\n                        variables,\n                        context\n                    );\n                }\n            },\n        }\n    );\n\n    const updateMany = async (\n        callTimeResource: string = resource,\n        callTimeParams: Partial<UpdateManyParams<RecordType>> = {},\n        updateOptions: MutateOptions<\n            Array<RecordType['id']>,\n            unknown,\n            Partial<UseUpdateManyMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode } = {}\n    ) => {\n        const { mutationMode, onSuccess, onSettled, onError } = updateOptions;\n\n        // store the hook time params *at the moment of the call*\n        // because they may change afterwards, which would break the undoable mode\n        // as the previousData would be overwritten by the optimistic update\n        paramsRef.current = params;\n\n        if (mutationMode) {\n            mode.current = mutationMode;\n        }\n\n        if (mode.current === 'pessimistic') {\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSuccess, onSettled, onError }\n            );\n        }\n\n        const {\n            ids: callTimeIds = ids,\n            data: callTimeData = data,\n            meta: callTimeMeta = meta,\n        } = callTimeParams;\n\n        // optimistic update as documented in https://react-query.tanstack.com/guides/optimistic-updates\n        // except we do it in a mutate wrapper instead of the onMutate callback\n        // to have access to success side effects\n\n        const queryKeys = [\n            [callTimeResource, 'getOne'],\n            [callTimeResource, 'getList'],\n            [callTimeResource, 'getMany'],\n            [callTimeResource, 'getManyReference'],\n        ];\n\n        /**\n         * Snapshot the previous values via queryClient.getQueriesData()\n         *\n         * The snapshotData ref will contain an array of tuples [query key, associated data]\n         *\n         * @example\n         * [\n         *   [['posts', 'getOne', { id: '1' }], { id: 1, title: 'Hello' }],\n         *   [['posts', 'getList'], { data: [{ id: 1, title: 'Hello' }], total: 1 }],\n         *   [['posts', 'getMany'], [{ id: 1, title: 'Hello' }]],\n         * ]\n         *\n         * @see https://react-query.tanstack.com/reference/QueryClient#queryclientgetqueriesdata\n         */\n        snapshot.current = queryKeys.reduce(\n            (prev, curr) => prev.concat(queryClient.getQueriesData(curr)),\n            [] as Snapshot\n        );\n\n        // Cancel any outgoing re-fetches (so they don't overwrite our optimistic update)\n        await Promise.all(\n            snapshot.current.map(([key]) => queryClient.cancelQueries(key))\n        );\n\n        // Optimistically update to the new data\n        await updateCache({\n            resource: callTimeResource,\n            ids: callTimeIds,\n            data: callTimeData,\n            meta: callTimeMeta,\n        });\n\n        // run the success callbacks during the next tick\n        if (onSuccess) {\n            setTimeout(\n                () =>\n                    onSuccess(\n                        callTimeIds,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n        if (reactMutationOptions.onSuccess) {\n            setTimeout(\n                () =>\n                    reactMutationOptions.onSuccess(\n                        callTimeIds,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n\n        if (mode.current === 'optimistic') {\n            // call the mutate method without success side effects\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSettled, onError }\n            );\n        } else {\n            // undoable mutation: register the mutation for later\n            undoableEventEmitter.once('end', ({ isUndo }) => {\n                if (isUndo) {\n                    // rollback\n                    snapshot.current.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                } else {\n                    // call the mutate method without success side effects\n                    mutation.mutate(\n                        { resource: callTimeResource, ...callTimeParams },\n                        { onSettled, onError }\n                    );\n                }\n            });\n        }\n    };\n\n    return [updateMany, mutation];\n};\n\ntype Snapshot = [key: QueryKey, value: any][];\n\nexport interface UseUpdateManyMutateParams<RecordType extends RaRecord = any> {\n    resource?: string;\n    ids?: Array<RecordType['id']>;\n    data?: Partial<RecordType>;\n    previousData?: any;\n    meta?: any;\n}\n\nexport type UseUpdateManyOptions<\n    RecordType extends RaRecord = any\n> = UseMutationOptions<\n    Array<RecordType['id']>,\n    unknown,\n    Partial<UseUpdateManyMutateParams<RecordType>>\n> & { mutationMode?: MutationMode };\n\nexport type UseUpdateManyResult<RecordType extends RaRecord = any> = [\n    (\n        resource?: string,\n        params?: Partial<UpdateManyParams<RecordType>>,\n        options?: MutateOptions<\n            Array<RecordType['id']>,\n            unknown,\n            Partial<UseUpdateManyMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode }\n    ) => Promise<void>,\n    UseMutationResult<\n        Array<RecordType['id']>,\n        unknown,\n        Partial<UpdateManyParams<Partial<RecordType>> & { resource?: string }>,\n        unknown\n    >\n];\n","import { useRef } from 'react';\nimport {\n    useMutation,\n    useQueryClient,\n    UseMutationOptions,\n    UseMutationResult,\n    MutateOptions,\n    QueryKey,\n} from 'react-query';\n\nimport { useDataProvider } from './useDataProvider';\nimport undoableEventEmitter from './undoableEventEmitter';\nimport { RaRecord, DeleteParams, MutationMode } from '../types';\n\n/**\n * Get a callback to call the dataProvider.delete() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The delete parameters { id, previousData }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }\n *\n * @typedef Params\n * @prop params.id The resource identifier, e.g. 123\n * @prop params.previousData The record before the update is applied\n *\n * @returns The current mutation state. Destructure as [deleteOne, { data, error, isLoading }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [deleteOne, { isLoading: false, isIdle: true }]\n * - start:   [deleteOne, { isLoading: true }]\n * - success: [deleteOne, { data: [data from response], isLoading: false, isSuccess: true }]\n * - error:   [deleteOne, { error: [error from response], isLoading: false, isError: true }]\n *\n * The deleteOne() function must be called with a resource and a parameter object: deleteOne(resource, { id, previousData, meta }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://react-query.tanstack.com/reference/useMutation\n *\n * @example // set params when calling the deleteOne callback\n *\n * import { useDelete } from 'react-admin';\n *\n * const DeleteButton = ({ record }) => {\n *     const [deleteOne, { isLoading, error }] = useDelete();\n *     const handleClick = () => {\n *         deleteOne('likes', { id: record.id }, record)\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={handleClick}>Delete</div>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useDelete } from 'react-admin';\n *\n * const DeleteButton = ({ record }) => {\n *     const [deleteOne, { isLoading, error }] = useDelete('likes', { id: record.id }, record);\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={() => deleteOne()}>Delete</button>;\n * };\n *\n * @example // TypeScript\n * const [delete, { data }] = useDelete<Product>('products', { id, previousData: product });\n *                    \\-- data is Product\n */\nexport const useDelete = <RecordType extends RaRecord = any>(\n    resource?: string,\n    params: Partial<DeleteParams<RecordType>> = {},\n    options: UseDeleteOptions<RecordType> = {}\n): UseDeleteResult<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const { id, previousData } = params;\n    const { mutationMode = 'pessimistic', ...reactMutationOptions } = options;\n    const mode = useRef<MutationMode>(mutationMode);\n    const paramsRef = useRef<Partial<DeleteParams<RecordType>>>(params);\n    const snapshot = useRef<Snapshot>([]);\n\n    const updateCache = ({ resource, id }) => {\n        // hack: only way to tell react-query not to fetch this query for the next 5 seconds\n        // because setQueryData doesn't accept a stale time option\n        const now = Date.now();\n        const updatedAt = mode.current === 'undoable' ? now + 5 * 1000 : now;\n\n        const updateColl = (old: RecordType[]) => {\n            if (!old) return;\n            const index = old.findIndex(\n                // eslint-disable-next-line eqeqeq\n                record => record.id == id\n            );\n            if (index === -1) {\n                return old;\n            }\n            return [...old.slice(0, index), ...old.slice(index + 1)];\n        };\n\n        type GetListResult = { data?: RecordType[]; total?: number };\n\n        queryClient.setQueriesData(\n            [resource, 'getList'],\n            (res: GetListResult) => {\n                if (!res || !res.data) return res;\n                const newCollection = updateColl(res.data);\n                const recordWasFound = newCollection.length < res.data.length;\n                return recordWasFound\n                    ? {\n                          data: newCollection,\n                          total: res.total - 1,\n                      }\n                    : res;\n            },\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getMany'],\n            (coll: RecordType[]) =>\n                coll && coll.length > 0 ? updateColl(coll) : coll,\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getManyReference'],\n            (res: GetListResult) => {\n                if (!res || !res.data) return res;\n                const newCollection = updateColl(res.data);\n                const recordWasFound = newCollection.length < res.data.length;\n                return recordWasFound\n                    ? {\n                          data: newCollection,\n                          total: res.total - 1,\n                      }\n                    : res;\n            },\n            { updatedAt }\n        );\n    };\n\n    const mutation = useMutation<\n        RecordType,\n        unknown,\n        Partial<UseDeleteMutateParams<RecordType>>\n    >(\n        ({\n            resource: callTimeResource = resource,\n            id: callTimeId = paramsRef.current.id,\n            previousData: callTimePreviousData = paramsRef.current.previousData,\n            meta: callTimeMeta = paramsRef.current.meta,\n        } = {}) =>\n            dataProvider\n                .delete<RecordType>(callTimeResource, {\n                    id: callTimeId,\n                    previousData: callTimePreviousData,\n                    meta: callTimeMeta,\n                })\n                .then(({ data }) => data),\n        {\n            ...reactMutationOptions,\n            onMutate: async (\n                variables: Partial<UseDeleteMutateParams<RecordType>>\n            ) => {\n                if (reactMutationOptions.onMutate) {\n                    const userContext =\n                        (await reactMutationOptions.onMutate(variables)) || {};\n                    return {\n                        snapshot: snapshot.current,\n                        // @ts-ignore\n                        ...userContext,\n                    };\n                } else {\n                    // Return a context object with the snapshot value\n                    return { snapshot: snapshot.current };\n                }\n            },\n            onError: (\n                error: unknown,\n                variables: Partial<UseDeleteMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // If the mutation fails, use the context returned from onMutate to rollback\n                    context.snapshot.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                }\n\n                if (reactMutationOptions.onError) {\n                    return reactMutationOptions.onError(\n                        error,\n                        variables,\n                        context\n                    );\n                }\n                // call-time error callback is executed by react-query\n            },\n            onSuccess: (\n                data: RecordType,\n                variables: Partial<UseDeleteMutateParams<RecordType>> = {},\n                context: unknown\n            ) => {\n                if (mode.current === 'pessimistic') {\n                    // update the getOne and getList query cache with the new result\n                    const {\n                        resource: callTimeResource = resource,\n                        id: callTimeId = id,\n                    } = variables;\n                    updateCache({\n                        resource: callTimeResource,\n                        id: callTimeId,\n                    });\n\n                    if (reactMutationOptions.onSuccess) {\n                        reactMutationOptions.onSuccess(\n                            data,\n                            variables,\n                            context\n                        );\n                    }\n                    // call-time success callback is executed by react-query\n                }\n            },\n            onSettled: (\n                data: RecordType,\n                error: unknown,\n                variables: Partial<UseDeleteMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // Always refetch after error or success:\n                    context.snapshot.forEach(([key]) => {\n                        queryClient.invalidateQueries(key);\n                    });\n                }\n\n                if (reactMutationOptions.onSettled) {\n                    return reactMutationOptions.onSettled(\n                        data,\n                        error,\n                        variables,\n                        context\n                    );\n                }\n            },\n        }\n    );\n\n    const mutate = async (\n        callTimeResource: string = resource,\n        callTimeParams: Partial<DeleteParams<RecordType>> = {},\n        updateOptions: MutateOptions<\n            RecordType,\n            unknown,\n            Partial<UseDeleteMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode } = {}\n    ) => {\n        const { mutationMode, onSuccess, onSettled, onError } = updateOptions;\n\n        // store the hook time params *at the moment of the call*\n        // because they may change afterwards, which would break the undoable mode\n        // as the previousData would be overwritten by the optimistic update\n        paramsRef.current = params;\n\n        if (mutationMode) {\n            mode.current = mutationMode;\n        }\n\n        if (mode.current === 'pessimistic') {\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSuccess, onSettled, onError }\n            );\n        }\n\n        const {\n            id: callTimeId = id,\n            previousData: callTimePreviousData = previousData,\n        } = callTimeParams;\n\n        // optimistic update as documented in https://react-query.tanstack.com/guides/optimistic-updates\n        // except we do it in a mutate wrapper instead of the onMutate callback\n        // to have access to success side effects\n\n        const queryKeys = [\n            [callTimeResource, 'getList'],\n            [callTimeResource, 'getMany'],\n            [callTimeResource, 'getManyReference'],\n        ];\n\n        /**\n         * Snapshot the previous values via queryClient.getQueriesData()\n         *\n         * The snapshotData ref will contain an array of tuples [query key, associated data]\n         *\n         * @example\n         * [\n         *   [['posts', 'getList'], { data: [{ id: 1, title: 'Hello' }], total: 1 }],\n         *   [['posts', 'getMany'], [{ id: 1, title: 'Hello' }]],\n         * ]\n         *\n         * @see https://react-query.tanstack.com/reference/QueryClient#queryclientgetqueriesdata\n         */\n        snapshot.current = queryKeys.reduce(\n            (prev, curr) => prev.concat(queryClient.getQueriesData(curr)),\n            [] as Snapshot\n        );\n\n        // Cancel any outgoing re-fetches (so they don't overwrite our optimistic update)\n        await Promise.all(\n            snapshot.current.map(([key]) => queryClient.cancelQueries(key))\n        );\n\n        // Optimistically update to the new value\n        updateCache({\n            resource: callTimeResource,\n            id: callTimeId,\n        });\n\n        // run the success callbacks during the next tick\n        if (onSuccess) {\n            setTimeout(\n                () =>\n                    onSuccess(\n                        callTimePreviousData,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n        if (reactMutationOptions.onSuccess) {\n            setTimeout(\n                () =>\n                    reactMutationOptions.onSuccess(\n                        callTimePreviousData,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n\n        if (mode.current === 'optimistic') {\n            // call the mutate method without success side effects\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSettled, onError }\n            );\n        } else {\n            // undoable mutation: register the mutation for later\n            undoableEventEmitter.once('end', ({ isUndo }) => {\n                if (isUndo) {\n                    // rollback\n                    snapshot.current.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                } else {\n                    // call the mutate method without success side effects\n                    mutation.mutate(\n                        { resource: callTimeResource, ...callTimeParams },\n                        { onSettled, onError }\n                    );\n                }\n            });\n        }\n    };\n\n    return [mutate, mutation];\n};\n\ntype Snapshot = [key: QueryKey, value: any][];\n\nexport interface UseDeleteMutateParams<RecordType extends RaRecord = any> {\n    resource?: string;\n    id?: RecordType['id'];\n    data?: Partial<RecordType>;\n    previousData?: any;\n    meta?: any;\n}\n\nexport type UseDeleteOptions<\n    RecordType extends RaRecord = any\n> = UseMutationOptions<\n    RecordType,\n    unknown,\n    Partial<UseDeleteMutateParams<RecordType>>\n> & { mutationMode?: MutationMode };\n\nexport type UseDeleteResult<RecordType extends RaRecord = any> = [\n    (\n        resource?: string,\n        params?: Partial<DeleteParams<RecordType>>,\n        options?: MutateOptions<\n            RecordType,\n            unknown,\n            Partial<UseDeleteMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode }\n    ) => Promise<void>,\n    UseMutationResult<\n        RecordType,\n        unknown,\n        Partial<DeleteParams<RecordType> & { resource?: string }>,\n        unknown\n    >\n];\n","import { useRef } from 'react';\nimport {\n    useMutation,\n    useQueryClient,\n    UseMutationOptions,\n    UseMutationResult,\n    MutateOptions,\n    QueryKey,\n} from 'react-query';\n\nimport { useDataProvider } from './useDataProvider';\nimport undoableEventEmitter from './undoableEventEmitter';\nimport { RaRecord, DeleteManyParams, MutationMode } from '../types';\n\n/**\n * Get a callback to call the dataProvider.delete() method, the result and the loading state.\n *\n * @param {string} resource\n * @param {Params} params The delete parameters { ids }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }\n *\n * @typedef Params\n * @prop params.ids The resource identifiers, e.g. [123, 456]\n *\n * @returns The current mutation state. Destructure as [deleteMany, { data, error, isLoading }].\n *\n * The return value updates according to the request state:\n *\n * - initial: [deleteMany, { isLoading: false, isIdle: true }]\n * - start:   [deleteMany, { isLoading: true }]\n * - success: [deleteMany, { data: [data from response], isLoading: false, isSuccess: true }]\n * - error:   [deleteMany, { error: [error from response], isLoading: false, isError: true }]\n *\n * The deleteMany() function must be called with a resource and a parameter object: deleteMany(resource, { ids, meta }, options)\n *\n * This hook uses react-query useMutation under the hood.\n * This means the state object contains mutate, isIdle, reset and other react-query methods.\n *\n * @see https://react-query.tanstack.com/reference/useMutation\n *\n * @example // set params when calling the deleteMany callback\n *\n * import { useDeleteMany } from 'react-admin';\n *\n * const BulkDeletePostsButton = ({ selectedIds }) => {\n *     const [deleteMany, { isLoading, error }] = useDeleteMany();\n *     const handleClick = () => {\n *         deleteMany('posts', { ids: selectedIds })\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={handleClick}>Delete selected posts</button>;\n * };\n *\n * @example // set params when calling the hook\n *\n * import { useDeleteMany } from 'react-admin';\n *\n * const BulkDeletePostsButton = ({ selectedIds }) => {\n *     const [deleteMany, { isLoading, error }] = useDeleteMany('posts', { ids: selectedIds });\n *     const handleClick = () => {\n *         deleteMany()\n *     }\n *     if (error) { return <p>ERROR</p>; }\n *     return <button disabled={isLoading} onClick={handleClick}>Delete selected posts</button>;\n * };\n *\n * @example // TypeScript\n * const [deleteMany, { data }] = useDeleteMany<Product>('products', { ids });\n *                        \\-- data is Product\n */\nexport const useDeleteMany = <RecordType extends RaRecord = any>(\n    resource?: string,\n    params: Partial<DeleteManyParams<RecordType>> = {},\n    options: UseDeleteManyOptions<RecordType> = {}\n): UseDeleteManyResult<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const { ids } = params;\n    const { mutationMode = 'pessimistic', ...reactMutationOptions } = options;\n    const mode = useRef<MutationMode>(mutationMode);\n    const paramsRef = useRef<Partial<DeleteManyParams<RecordType>>>({});\n    const snapshot = useRef<Snapshot>([]);\n\n    const updateCache = ({ resource, ids }) => {\n        // hack: only way to tell react-query not to fetch this query for the next 5 seconds\n        // because setQueryData doesn't accept a stale time option\n        const now = Date.now();\n        const updatedAt = mode.current === 'undoable' ? now + 5 * 1000 : now;\n\n        const updateColl = (old: RecordType[]) => {\n            if (!old) return;\n            let newCollection = [...old];\n            ids.forEach(id => {\n                const index = newCollection.findIndex(\n                    // eslint-disable-next-line eqeqeq\n                    record => record.id == id\n                );\n                if (index === -1) {\n                    return;\n                }\n                newCollection = [\n                    ...newCollection.slice(0, index),\n                    ...newCollection.slice(index + 1),\n                ];\n            });\n            return newCollection;\n        };\n\n        type GetListResult = { data?: RecordType[]; total?: number };\n\n        queryClient.setQueriesData(\n            [resource, 'getList'],\n            (res: GetListResult) => {\n                if (!res || !res.data) return res;\n                const newCollection = updateColl(res.data);\n                const recordWasFound = newCollection.length < res.data.length;\n                return recordWasFound\n                    ? {\n                          data: newCollection,\n                          total:\n                              res.total -\n                              (res.data.length - newCollection.length),\n                      }\n                    : res;\n            },\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getMany'],\n            (coll: RecordType[]) =>\n                coll && coll.length > 0 ? updateColl(coll) : coll,\n            { updatedAt }\n        );\n        queryClient.setQueriesData(\n            [resource, 'getManyReference'],\n            (res: GetListResult) => {\n                if (!res || !res.data) return res;\n                const newCollection = updateColl(res.data);\n                const recordWasFound = newCollection.length < res.data.length;\n                return recordWasFound\n                    ? {\n                          data: newCollection,\n                          total:\n                              res.total -\n                              (res.data.length - newCollection.length),\n                      }\n                    : res;\n            },\n            { updatedAt }\n        );\n    };\n\n    const mutation = useMutation<\n        RecordType['id'][],\n        unknown,\n        Partial<UseDeleteManyMutateParams<RecordType>>\n    >(\n        ({\n            resource: callTimeResource = resource,\n            ids: callTimeIds = paramsRef.current.ids,\n            meta: callTimeMeta = paramsRef.current.meta,\n        } = {}) =>\n            dataProvider\n                .deleteMany<RecordType>(callTimeResource, {\n                    ids: callTimeIds,\n                    meta: callTimeMeta,\n                })\n                .then(({ data }) => data),\n        {\n            ...reactMutationOptions,\n            onMutate: async (\n                variables: Partial<UseDeleteManyMutateParams<RecordType>>\n            ) => {\n                if (reactMutationOptions.onMutate) {\n                    const userContext =\n                        (await reactMutationOptions.onMutate(variables)) || {};\n                    return {\n                        snapshot: snapshot.current,\n                        // @ts-ignore\n                        ...userContext,\n                    };\n                } else {\n                    // Return a context object with the snapshot value\n                    return { snapshot: snapshot.current };\n                }\n            },\n            onError: (\n                error: unknown,\n                variables: Partial<UseDeleteManyMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // If the mutation fails, use the context returned from onMutate to rollback\n                    context.snapshot.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                }\n\n                if (reactMutationOptions.onError) {\n                    return reactMutationOptions.onError(\n                        error,\n                        variables,\n                        context\n                    );\n                }\n                // call-time error callback is executed by react-query\n            },\n            onSuccess: (\n                data: RecordType['id'][],\n                variables: Partial<UseDeleteManyMutateParams<RecordType>> = {},\n                context: unknown\n            ) => {\n                if (mode.current === 'pessimistic') {\n                    // update the getOne and getList query cache with the new result\n                    const {\n                        resource: callTimeResource = resource,\n                        ids: callTimeIds = ids,\n                    } = variables;\n                    updateCache({\n                        resource: callTimeResource,\n                        ids: callTimeIds,\n                    });\n\n                    if (reactMutationOptions.onSuccess) {\n                        reactMutationOptions.onSuccess(\n                            data,\n                            variables,\n                            context\n                        );\n                    }\n                    // call-time success callback is executed by react-query\n                }\n            },\n            onSettled: (\n                data: RecordType['id'][],\n                error: unknown,\n                variables: Partial<UseDeleteManyMutateParams<RecordType>> = {},\n                context: { snapshot: Snapshot }\n            ) => {\n                if (\n                    mode.current === 'optimistic' ||\n                    mode.current === 'undoable'\n                ) {\n                    // Always refetch after error or success:\n                    context.snapshot.forEach(([key]) => {\n                        queryClient.invalidateQueries(key);\n                    });\n                }\n\n                if (reactMutationOptions.onSettled) {\n                    return reactMutationOptions.onSettled(\n                        data,\n                        error,\n                        variables,\n                        context\n                    );\n                }\n            },\n        }\n    );\n\n    const mutate = async (\n        callTimeResource: string = resource,\n        callTimeParams: Partial<DeleteManyParams<RecordType>> = {},\n        updateOptions: MutateOptions<\n            RecordType['id'][],\n            unknown,\n            Partial<UseDeleteManyMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode } = {}\n    ) => {\n        const { mutationMode, onSuccess, onSettled, onError } = updateOptions;\n\n        // store the hook time params *at the moment of the call*\n        // because they may change afterwards, which would break the undoable mode\n        // as the previousData would be overwritten by the optimistic update\n        paramsRef.current = params;\n\n        if (mutationMode) {\n            mode.current = mutationMode;\n        }\n\n        if (mode.current === 'pessimistic') {\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSuccess, onSettled, onError }\n            );\n        }\n\n        const { ids: callTimeIds = ids } = callTimeParams;\n\n        // optimistic update as documented in https://react-query.tanstack.com/guides/optimistic-updates\n        // except we do it in a mutate wrapper instead of the onMutate callback\n        // to have access to success side effects\n\n        const queryKeys = [\n            [callTimeResource, 'getList'],\n            [callTimeResource, 'getMany'],\n            [callTimeResource, 'getManyReference'],\n        ];\n\n        /**\n         * Snapshot the previous values via queryClient.getQueriesData()\n         *\n         * The snapshotData ref will contain an array of tuples [query key, associated data]\n         *\n         * @example\n         * [\n         *   [['posts', 'getList'], { data: [{ id: 1, title: 'Hello' }], total: 1 }],\n         *   [['posts', 'getMany'], [{ id: 1, title: 'Hello' }]],\n         * ]\n         *\n         * @see https://react-query.tanstack.com/reference/QueryClient#queryclientgetqueriesdata\n         */\n        snapshot.current = queryKeys.reduce(\n            (prev, curr) => prev.concat(queryClient.getQueriesData(curr)),\n            [] as Snapshot\n        );\n\n        // Cancel any outgoing re-fetches (so they don't overwrite our optimistic update)\n        await Promise.all(\n            snapshot.current.map(([key]) => queryClient.cancelQueries(key))\n        );\n\n        // Optimistically update to the new value\n        updateCache({\n            resource: callTimeResource,\n            ids: callTimeIds,\n        });\n\n        // run the success callbacks during the next tick\n        if (onSuccess) {\n            setTimeout(\n                () =>\n                    onSuccess(\n                        callTimeIds,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n        if (reactMutationOptions.onSuccess) {\n            setTimeout(\n                () =>\n                    reactMutationOptions.onSuccess(\n                        callTimeIds,\n                        { resource: callTimeResource, ...callTimeParams },\n                        { snapshot: snapshot.current }\n                    ),\n                0\n            );\n        }\n\n        if (mode.current === 'optimistic') {\n            // call the mutate method without success side effects\n            return mutation.mutate(\n                { resource: callTimeResource, ...callTimeParams },\n                { onSettled, onError }\n            );\n        } else {\n            // undoable mutation: register the mutation for later\n            undoableEventEmitter.once('end', ({ isUndo }) => {\n                if (isUndo) {\n                    // rollback\n                    snapshot.current.forEach(([key, value]) => {\n                        queryClient.setQueryData(key, value);\n                    });\n                } else {\n                    // call the mutate method without success side effects\n                    mutation.mutate(\n                        { resource: callTimeResource, ...callTimeParams },\n                        { onSettled, onError }\n                    );\n                }\n            });\n        }\n    };\n\n    return [mutate, mutation];\n};\n\ntype Snapshot = [key: QueryKey, value: any][];\n\nexport interface UseDeleteManyMutateParams<RecordType extends RaRecord = any> {\n    resource?: string;\n    ids?: RecordType['id'][];\n    meta?: any;\n}\n\nexport type UseDeleteManyOptions<\n    RecordType extends RaRecord = any\n> = UseMutationOptions<\n    RecordType['id'][],\n    unknown,\n    Partial<UseDeleteManyMutateParams<RecordType>>\n> & { mutationMode?: MutationMode };\n\nexport type UseDeleteManyResult<RecordType extends RaRecord = any> = [\n    (\n        resource?: string,\n        params?: Partial<DeleteManyParams<RecordType>>,\n        options?: MutateOptions<\n            RecordType['id'][],\n            unknown,\n            Partial<UseDeleteManyMutateParams<RecordType>>,\n            unknown\n        > & { mutationMode?: MutationMode }\n    ) => Promise<void>,\n    UseMutationResult<\n        RecordType['id'][],\n        unknown,\n        Partial<DeleteManyParams<RecordType> & { resource?: string }>,\n        unknown\n    >\n];\n","import * as React from 'react';\nimport { createContext, useCallback, useState, useMemo } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nimport { ResourceDefinition } from '../types';\n\nexport type ResourceDefinitions = {\n    [name: string]: ResourceDefinition;\n};\n\nexport type ResourceDefinitionContextValue = {\n    definitions: ResourceDefinitions;\n    register: (config: ResourceDefinition) => void;\n    unregister: (config: ResourceDefinition) => void;\n};\n\nexport const ResourceDefinitionContext = createContext<\n    ResourceDefinitionContextValue\n>({\n    definitions: {},\n    register: () => {},\n    unregister: () => {},\n});\n\n/**\n * Context to store the current resource Definition.\n *\n * Use the useResourceDefinition() hook to read the context.\n *\n * @example\n *\n * import { useResourceDefinition, useTranslate } from 'ra-core';\n *\n * const PostMenuItem = () => {\n *     const { name, icon } = useResourceDefinition({ resource: 'posts' });\n *\n *     return (\n *          <MenuItem>\n *              <ListItemIcon>{icon}</ListItemIcon>\n *              {name}\n *          </MenuItem>\n *     );\n * };\n */\nexport const ResourceDefinitionContextProvider = ({\n    definitions: defaultDefinitions = {},\n    children,\n}) => {\n    const [definitions, setState] = useState<ResourceDefinitions>(\n        defaultDefinitions\n    );\n\n    const register = useCallback((config: ResourceDefinition) => {\n        setState(prev =>\n            isEqual(prev[config.name], config)\n                ? prev\n                : {\n                      ...prev,\n                      [config.name]: config,\n                  }\n        );\n    }, []);\n\n    const unregister = useCallback((config: ResourceDefinition) => {\n        setState(prev => {\n            const { [config.name]: _, ...rest } = prev;\n            return rest;\n        });\n    }, []);\n\n    const contextValue = useMemo(\n        () => ({ definitions, register, unregister }),\n        [definitions] // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    return (\n        <ResourceDefinitionContext.Provider value={contextValue}>\n            {children}\n        </ResourceDefinitionContext.Provider>\n    );\n};\n","import * as React from 'react';\nimport { ComponentType, useEffect, isValidElement, createElement } from 'react';\nimport { Routes, Route } from 'react-router-dom';\n\nimport { CoreAdminRoutes } from './CoreAdminRoutes';\nimport { Ready } from '../util';\nimport {\n    TitleComponent,\n    LoginComponent,\n    LayoutComponent,\n    CoreLayoutProps,\n    AdminChildren,\n    CatchAllComponent,\n    DashboardComponent,\n    LoadingComponent,\n} from '../types';\n\nexport type ChildrenFunction = () => ComponentType[];\n\nconst DefaultLayout = ({ children }: CoreLayoutProps) => <>{children}</>;\n\nexport interface CoreAdminUIProps {\n    catchAll?: CatchAllComponent;\n    children?: AdminChildren;\n    dashboard?: DashboardComponent;\n    disableTelemetry?: boolean;\n    layout?: LayoutComponent;\n    loading?: LoadingComponent;\n    loginPage?: LoginComponent | boolean;\n    /**\n     * @deprecated use a custom layout instead\n     */\n    menu?: ComponentType;\n    requireAuth?: boolean;\n    ready?: ComponentType;\n    title?: TitleComponent;\n}\n\nexport const CoreAdminUI = (props: CoreAdminUIProps) => {\n    const {\n        catchAll = Noop,\n        children,\n        dashboard,\n        disableTelemetry = false,\n        layout = DefaultLayout,\n        loading = Noop,\n        loginPage: LoginPage = false,\n        menu, // deprecated, use a custom layout instead\n        ready = Ready,\n        title = 'React Admin',\n        requireAuth = false,\n    } = props;\n\n    useEffect(() => {\n        if (\n            disableTelemetry ||\n            process.env.NODE_ENV !== 'production' ||\n            typeof window === 'undefined' ||\n            typeof window.location === 'undefined' ||\n            typeof Image === 'undefined'\n        ) {\n            return;\n        }\n        const img = new Image();\n        img.src = `https://react-admin-telemetry.marmelab.com/react-admin-telemetry?domain=${window.location.hostname}`;\n    }, [disableTelemetry]);\n\n    return (\n        <Routes>\n            {LoginPage !== false && LoginPage !== true ? (\n                <Route path=\"/login\" element={createOrGetElement(LoginPage)} />\n            ) : null}\n            <Route\n                path=\"/*\"\n                element={\n                    <CoreAdminRoutes\n                        catchAll={catchAll}\n                        dashboard={dashboard}\n                        layout={layout}\n                        loading={loading}\n                        menu={menu}\n                        requireAuth={requireAuth}\n                        ready={ready}\n                        title={title}\n                    >\n                        {children}\n                    </CoreAdminRoutes>\n                }\n            />\n        </Routes>\n    );\n};\n\nconst createOrGetElement = el => (isValidElement(el) ? el : createElement(el));\n\nconst Noop = () => null;\n","import * as React from 'react';\nimport { useState, useEffect, Children, ComponentType } from 'react';\nimport { Navigate, Route, Routes } from 'react-router-dom';\n\nimport { WithPermissions, useCheckAuth } from '../auth';\nimport { useTimeout } from '../util';\nimport { useScrollToTop, useCreatePath } from '../routing';\nimport {\n    AdminChildren,\n    CatchAllComponent,\n    LayoutComponent,\n    LoadingComponent,\n    CoreLayoutProps,\n} from '../types';\nimport { useConfigureAdminRouterFromChildren } from './useConfigureAdminRouterFromChildren';\n\nexport const CoreAdminRoutes = (props: CoreAdminRoutesProps) => {\n    const oneSecondHasPassed = useTimeout(1000);\n    useScrollToTop();\n    const createPath = useCreatePath();\n\n    const {\n        customRoutesWithLayout,\n        customRoutesWithoutLayout,\n        status,\n        resources,\n    } = useConfigureAdminRouterFromChildren(props.children);\n\n    const {\n        layout: Layout,\n        catchAll: CatchAll,\n        dashboard,\n        loading: LoadingPage,\n        menu,\n        requireAuth,\n        ready: Ready,\n        title,\n    } = props;\n\n    const [canRender, setCanRender] = useState(!requireAuth);\n    const checkAuth = useCheckAuth();\n\n    useEffect(() => {\n        if (requireAuth) {\n            checkAuth()\n                .then(() => {\n                    setCanRender(true);\n                })\n                .catch(() => {});\n        }\n    }, [checkAuth, requireAuth]);\n\n    if (status === 'empty') {\n        return <Ready />;\n    }\n\n    if (status === 'loading' || !canRender) {\n        return (\n            <Routes>\n                {customRoutesWithoutLayout}\n                {oneSecondHasPassed ? (\n                    <Route path=\"*\" element={<LoadingPage />} />\n                ) : (\n                    <Route path=\"*\" element={null} />\n                )}\n            </Routes>\n        );\n    }\n\n    return (\n        <Routes>\n            {/*\n                Render the custom routes that were outside the child function.\n            */}\n            {customRoutesWithoutLayout}\n            <Route\n                path=\"/*\"\n                element={\n                    <div>\n                        <Layout dashboard={dashboard} menu={menu} title={title}>\n                            <Routes>\n                                {customRoutesWithLayout}\n                                {Children.map(resources, resource => (\n                                    <Route\n                                        key={resource.props.name}\n                                        path={`${resource.props.name}/*`}\n                                        element={resource}\n                                    />\n                                ))}\n                                <Route\n                                    path=\"/\"\n                                    element={\n                                        dashboard ? (\n                                            <WithPermissions\n                                                authParams={defaultAuthParams}\n                                                component={dashboard}\n                                            />\n                                        ) : resources.length > 0 ? (\n                                            <Navigate\n                                                to={createPath({\n                                                    resource:\n                                                        resources[0].props.name,\n                                                    type: 'list',\n                                                })}\n                                            />\n                                        ) : null\n                                    }\n                                />\n                                <Route\n                                    path=\"*\"\n                                    element={<CatchAll title={title} />}\n                                />\n                            </Routes>\n                        </Layout>\n                    </div>\n                }\n            />\n        </Routes>\n    );\n};\n\nCoreAdminRoutes.defaultProps = {\n    customRoutes: [],\n};\n\nexport interface CoreAdminRoutesProps extends CoreLayoutProps {\n    layout: LayoutComponent;\n    catchAll: CatchAllComponent;\n    children?: AdminChildren;\n    loading: LoadingComponent;\n    requireAuth?: boolean;\n    ready?: ComponentType;\n}\n\nconst defaultAuthParams = { route: 'dashboard' };\n","import * as React from 'react';\nimport {\n    Children,\n    Dispatch,\n    Fragment,\n    ReactElement,\n    ReactNode,\n    SetStateAction,\n    useCallback,\n    useEffect,\n    useState,\n} from 'react';\nimport { useLogout, usePermissions, useAuthState } from '../auth';\nimport { useSafeSetState } from '../util';\nimport {\n    AdminChildren,\n    RenderResourcesFunction,\n    ResourceDefinition,\n    ResourceProps,\n} from '../types';\nimport { CustomRoutesProps } from './CustomRoutes';\nimport { useResourceDefinitionContext } from './useResourceDefinitionContext';\n\n/**\n * This hook inspects the CoreAdminRouter children and returns them separated in three groups:\n * - Custom routes without layout\n * - Custom routes with layout\n * - Resources\n *\n * It also returns a status:\n * - loading: still loading children from a function child\n * - empty: no resources were provided among children\n * - ready: admin is ready to be rendered\n *\n * @example\n * const {\n *    customRoutesWithLayout,\n *    customRoutesWithoutLayout,\n *    resources,\n *    status,\n * } = useConfigureAdminRouterFromChildren(children);\n */\nexport const useConfigureAdminRouterFromChildren = (\n    children: AdminChildren\n): RoutesAndResources & { status: AdminRouterStatus } => {\n    const { permissions } = usePermissions();\n\n    // Whenever children are updated, update our custom routes and resources\n    const [routesAndResources, status] = useRoutesAndResourcesFromChildren(\n        children,\n        permissions\n    );\n\n    // Whenever the resources change, we must ensure they're all registered\n    useRegisterResources(routesAndResources.resources, permissions);\n\n    return {\n        customRoutesWithLayout: routesAndResources.customRoutesWithLayout,\n        customRoutesWithoutLayout: routesAndResources.customRoutesWithoutLayout,\n        status,\n        resources: routesAndResources.resources,\n    };\n};\n\n/**\n * A hook that determine the routes and resources from React nodes and permissions.\n * Returns a tuple with the routes and resources as a single object, and the status.\n * @param children React nodes to inspect\n * @param permissions The permissions\n */\nconst useRoutesAndResourcesFromChildren = (\n    children: ReactNode,\n    permissions: any\n): [RoutesAndResources, AdminRouterStatus] => {\n    // Gather custom routes and resources that were declared as direct children of CoreAdminRouter\n    // e.g. Not returned from the child function (if any)\n    // We need to know right away wether some resources were declared to correctly\n    // initialize the status at the next stop\n    const doLogout = useLogout();\n    const { authenticated } = useAuthState();\n    const [\n        routesAndResources,\n        setRoutesAndResources,\n        mergeRoutesAndResources,\n    ] = useRoutesAndResourcesState(getRoutesAndResourceFromNodes(children));\n\n    const [status, setStatus] = useSafeSetState<AdminRouterStatus>(() =>\n        getStatus({\n            children,\n            ...routesAndResources,\n        })\n    );\n\n    useEffect(() => {\n        const resolveChildFunction = async (\n            childFunc: RenderResourcesFunction\n        ) => {\n            try {\n                const childrenFuncResult = childFunc(permissions);\n                if ((childrenFuncResult as Promise<ReactNode>).then) {\n                    (childrenFuncResult as Promise<ReactNode>).then(\n                        resolvedChildren => {\n                            mergeRoutesAndResources(\n                                getRoutesAndResourceFromNodes(resolvedChildren)\n                            );\n                            setStatus('ready');\n                        }\n                    );\n                } else {\n                    mergeRoutesAndResources(\n                        getRoutesAndResourceFromNodes(childrenFuncResult)\n                    );\n                    setStatus('ready');\n                }\n            } catch (error) {\n                console.error(error);\n                doLogout();\n            }\n        };\n\n        const updateFromChildren = async () => {\n            const functionChild = getSingleChildFunction(children);\n            const newRoutesAndResources = getRoutesAndResourceFromNodes(\n                children\n            );\n            setRoutesAndResources(newRoutesAndResources);\n            setStatus(\n                !!functionChild\n                    ? 'loading'\n                    : newRoutesAndResources.resources.length > 0\n                    ? 'ready'\n                    : 'empty'\n            );\n\n            if (functionChild) {\n                resolveChildFunction(functionChild);\n            }\n        };\n        updateFromChildren();\n    }, [\n        authenticated,\n        children,\n        doLogout,\n        mergeRoutesAndResources,\n        permissions,\n        setRoutesAndResources,\n        setStatus,\n    ]);\n\n    return [routesAndResources, status];\n};\n\n/*\n * A hook that store the routes and resources just like setState but also provides an additional function\n * to merge new routes and resources with the existing ones.\n */\nconst useRoutesAndResourcesState = (\n    initialState: RoutesAndResources\n): [\n    RoutesAndResources,\n    Dispatch<SetStateAction<RoutesAndResources>>,\n    (newRoutesAndResources: RoutesAndResources) => void\n] => {\n    const [routesAndResources, setRoutesAndResources] = useState(initialState);\n\n    const mergeRoutesAndResources = useCallback(\n        (newRoutesAndResources: RoutesAndResources) => {\n            setRoutesAndResources(previous => ({\n                customRoutesWithLayout: previous.customRoutesWithLayout.concat(\n                    newRoutesAndResources.customRoutesWithLayout\n                ),\n                customRoutesWithoutLayout: previous.customRoutesWithoutLayout.concat(\n                    newRoutesAndResources.customRoutesWithoutLayout\n                ),\n                resources: previous.resources.concat(\n                    newRoutesAndResources.resources\n                ),\n            }));\n        },\n        []\n    );\n\n    return [routesAndResources, setRoutesAndResources, mergeRoutesAndResources];\n};\n\n/**\n * A hook that register resources and unregister them when the calling component is unmounted.\n * @param resources: An array of Resource elements\n * @param permissions: The permissions\n */\nconst useRegisterResources = (\n    resources: (ReactElement<ResourceProps> & ResourceWithRegisterFunction)[],\n    permissions: any\n) => {\n    const { register, unregister } = useResourceDefinitionContext();\n\n    useEffect(() => {\n        resources.forEach(resource => {\n            if (\n                typeof ((resource.type as unknown) as ResourceWithRegisterFunction)\n                    .registerResource === 'function'\n            ) {\n                const definition = ((resource.type as unknown) as ResourceWithRegisterFunction).registerResource(\n                    resource.props,\n                    permissions\n                );\n                register(definition);\n            } else {\n                throw new Error(\n                    'When using a custom Resource element, it must have a static registerResource method accepting its props and returning a ResourceDefinition'\n                );\n            }\n        });\n        return () => {\n            resources.forEach(resource => {\n                if (\n                    typeof ((resource.type as unknown) as ResourceWithRegisterFunction)\n                        .registerResource === 'function'\n                ) {\n                    const definition = ((resource.type as unknown) as ResourceWithRegisterFunction).registerResource(\n                        resource.props,\n                        permissions\n                    );\n                    unregister(definition);\n                } else {\n                    throw new Error(\n                        'When using a custom Resource element, it must have a static registerResource method accepting its props and returning a ResourceDefinition'\n                    );\n                }\n            });\n        };\n    }, [permissions, register, resources, unregister]);\n};\n\nconst getStatus = ({\n    children,\n    resources,\n    customRoutesWithLayout,\n    customRoutesWithoutLayout,\n}: {\n    children: ReactNode;\n    resources: ReactElement<ResourceProps>[];\n    customRoutesWithLayout: ReactElement<CustomRoutesProps>[];\n    customRoutesWithoutLayout: ReactElement<CustomRoutesProps>[];\n}) => {\n    return getSingleChildFunction(children)\n        ? 'loading'\n        : resources.length > 0 ||\n          customRoutesWithLayout.length > 0 ||\n          customRoutesWithoutLayout.length > 0\n        ? 'ready'\n        : 'empty';\n};\n\n/**\n * Inspect the children of a CoreAdminRouter to see if one of them is a function.\n * Throws an error if there are more than one function child.\n * Returns the function child if one was provided, or null otherwise.\n */\nconst getSingleChildFunction = (\n    children: ReactNode\n): RenderResourcesFunction | null => {\n    const childrenArray = Array.isArray(children) ? children : [children];\n\n    const functionChildren = childrenArray.filter(\n        child => typeof child === 'function'\n    );\n\n    if (functionChildren.length > 1) {\n        throw new Error(\n            'You can only provide one function child to AdminRouter'\n        );\n    }\n\n    if (functionChildren.length === 0) {\n        return null;\n    }\n\n    return functionChildren[0] as RenderResourcesFunction;\n};\n\n/**\n * Inspect the children and return an object with the following keys:\n * - customRoutesWithLayout: an array of the custom routes to render inside the layout\n * - customRoutesWithoutLayout: an array of custom routes to render outside the layout\n * - resources: an array of resources elements\n */\nconst getRoutesAndResourceFromNodes = (\n    children: ReactNode\n): RoutesAndResources => {\n    const customRoutesWithLayout = [];\n    const customRoutesWithoutLayout = [];\n    const resources = [];\n    Children.forEach(children, element => {\n        if (!React.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        if (element.type === Fragment) {\n            const customRoutesFromFragment = getRoutesAndResourceFromNodes(\n                element.props.children\n            );\n            customRoutesWithLayout.push(\n                ...customRoutesFromFragment.customRoutesWithLayout\n            );\n            customRoutesWithoutLayout.push(\n                ...customRoutesFromFragment.customRoutesWithoutLayout\n            );\n            resources.push(...customRoutesFromFragment.resources);\n        }\n\n        if ((element.type as any).raName === 'CustomRoutes') {\n            const customRoutesElement = element as ReactElement<\n                CustomRoutesProps\n            >;\n\n            if (customRoutesElement.props.noLayout) {\n                customRoutesWithoutLayout.push(\n                    customRoutesElement.props.children\n                );\n            } else {\n                customRoutesWithLayout.push(customRoutesElement.props.children);\n            }\n        } else if ((element.type as any).raName === 'Resource') {\n            resources.push(element as ReactElement<ResourceProps>);\n        }\n    });\n\n    return {\n        customRoutesWithLayout,\n        customRoutesWithoutLayout,\n        resources,\n    };\n};\n\ntype RoutesAndResources = {\n    customRoutesWithLayout: ReactElement<CustomRoutesProps>[];\n    customRoutesWithoutLayout: ReactElement<CustomRoutesProps>[];\n    resources: (ReactElement<ResourceProps> & ResourceWithRegisterFunction)[];\n};\n\ntype ResourceWithRegisterFunction = {\n    registerResource: (\n        props: ResourceProps,\n        permissions: any\n    ) => ResourceDefinition;\n};\n\ntype AdminRouterStatus = 'loading' | 'empty' | 'ready';\n","import { useContext } from 'react';\n\nimport { ResourceDefinitionContext } from './ResourceDefinitionContext';\n\nexport const useResourceDefinitionContext = () =>\n    useContext(ResourceDefinitionContext);\n","import { ReactNode } from 'react';\n\n/**\n * This component allows you to provide custom routes to the Admin.\n * @param props The component props\n * @param props.children The custom routes.\n * @param props.noLayout A boolean indicating whether to render the routes outside the Layout. Defaults to false.\n * @returns Nothing. This is a configuration component.\n */\nexport const CustomRoutes = (props: CustomRoutesProps) => {\n    return null;\n};\n\nCustomRoutes.raName = 'CustomRoutes';\n\nexport type CustomRoutesProps = {\n    children: ReactNode;\n    noLayout?: boolean;\n};\n","import * as React from 'react';\nimport { isValidElement } from 'react';\nimport { Route, Routes } from 'react-router-dom';\n\nimport { ResourceProps } from '../types';\nimport { ResourceContextProvider } from './ResourceContextProvider';\n\nexport const Resource = (props: ResourceProps) => {\n    const { create: Create, edit: Edit, list: List, name, show: Show } = props;\n\n    return (\n        <ResourceContextProvider value={name}>\n            <Routes>\n                {Create && (\n                    <Route\n                        path=\"create/*\"\n                        element={isValidElement(Create) ? Create : <Create />}\n                    />\n                )}\n                {Show && (\n                    <Route\n                        path=\":id/show/*\"\n                        element={isValidElement(Show) ? Show : <Show />}\n                    />\n                )}\n                {Edit && (\n                    <Route\n                        path=\":id/*\"\n                        element={isValidElement(Edit) ? Edit : <Edit />}\n                    />\n                )}\n                {List && (\n                    <Route\n                        path=\"/*\"\n                        element={isValidElement(List) ? List : <List />}\n                    />\n                )}\n            </Routes>\n        </ResourceContextProvider>\n    );\n};\n\nResource.raName = 'Resource';\n\nResource.registerResource = ({\n    create,\n    edit,\n    icon,\n    list,\n    name,\n    options,\n    show,\n}: ResourceProps) => ({\n    name,\n    options,\n    hasList: !!list,\n    hasCreate: !!create,\n    hasEdit: !!edit,\n    hasShow: !!show,\n    icon,\n});\n","import * as React from 'react';\nimport { ReactElement } from 'react';\nimport { ResourceContext, ResourceContextValue } from './ResourceContext';\n\n/**\n * Create a Resource Context with the resource name\n *\n * Some react-admin components rely on the resource name to be available in the context.\n * This component provides it.\n *\n * If the value is empty, the context is not provided.\n *\n * @param {string} value the resource name\n * @example\n *\n * import { ResourceContextProvider } from 'react-admin';\n *\n * const MyComponent = () => (\n *    <ResourceContextProvider value=\"posts\">\n *       <MyResourceSpecificComponent />\n *   </ResourceContextProvider>\n * );\n */\nexport const ResourceContextProvider = ({\n    children,\n    value,\n}: {\n    children: ReactElement;\n    value?: ResourceContextValue;\n}) =>\n    value ? (\n        <ResourceContext.Provider value={value}>\n            {children}\n        </ResourceContext.Provider>\n    ) : (\n        children\n    );\n","import inflection from 'inflection';\n\nimport { useResourceDefinitions } from './useResourceDefinitions';\nimport { useTranslate } from '../i18n';\n\n/**\n * A hook which returns function to get a translated resource name. It will use the label option of the `Resource` component if it was provided.\n *\n * @returns {GetResourceLabel} A function which takes a resource name and an optional number indicating the number of items (used for pluralization) and returns a translated string.\n * @example\n * const Menu = () => {\n *     const resources = useResourceDefinitions();\n *     const getResourceLabel = useGetResourceLabel();\n *\n *     return (\n *         <ul>\n *             {Object.keys(resources).map(name => (\n *                 <li key={name}>\n *                     {getResourceLabel(name, 2)}\n *                 </li>\n *             ))}\n *         </ul>\n *     )\n * }\n */\nexport const useGetResourceLabel = (): GetResourceLabel => {\n    const translate = useTranslate();\n    const definitions = useResourceDefinitions();\n\n    return (resource: string, count = 2): string => {\n        const resourceDefinition = definitions[resource];\n\n        const label = translate(`resources.${resource}.name`, {\n            smart_count: count,\n            _:\n                resourceDefinition &&\n                resourceDefinition.options &&\n                resourceDefinition.options.label\n                    ? translate(resourceDefinition.options.label, {\n                          smart_count: count,\n                          _: resourceDefinition.options.label,\n                      })\n                    : inflection.humanize(\n                          count > 1\n                              ? inflection.pluralize(resource)\n                              : inflection.singularize(resource)\n                      ),\n        });\n\n        return label;\n    };\n};\n\nexport type GetResourceLabel = (resource: string, count?: number) => string;\n","import { ResourceDefinitions } from './ResourceDefinitionContext';\nimport { useResourceDefinitionContext } from './useResourceDefinitionContext';\n\n/**\n * Get the definition of the all resources\n *\n * @example\n *\n * const definitions = useResourceDefinitions();\n * console.log(definitions.posts);\n * // {\n * //   name: 'posts',\n * //   hasList: true,\n * //   hasEdit: true,\n * //   hasShow: true,\n * //   hasCreate: true,\n * //   options: {},\n * //   icon: PostIcon,\n * // }\n */\nexport const useResourceDefinitions = (): ResourceDefinitions =>\n    useResourceDefinitionContext().definitions;\n","import { useMemo } from 'react';\nimport defaults from 'lodash/defaults';\n\nimport { useResourceDefinitions } from './useResourceDefinitions';\nimport { useResourceContext } from './useResourceContext';\nimport { ResourceDefinition } from '../types';\n\n/**\n * Hook to get the definition of a given resource\n *\n * @example // Get the current resource definition (based on ResourceContext)\n *\n * const definition = useResourceDefinition();\n * console.log(definition);\n * // {\n * //   name: 'posts',\n * //   hasList: true,\n * //   hasEdit: true,\n * //   hasShow: true,\n * //   hasCreate: true,\n * //   options: {},\n * //   icon: PostIcon,\n * // }\n *\n * @example // Pass a resource prop to check a different resource definition\n *\n * const definition = useResourceDefinition({ resource: 'posts' });\n */\nexport const useResourceDefinition = (\n    props?: UseResourceDefinitionOptions\n): ResourceDefinition => {\n    const resource = useResourceContext(props);\n    const resourceDefinitions = useResourceDefinitions();\n    const { hasCreate, hasEdit, hasList, hasShow } = props || {};\n\n    const definition = useMemo(() => {\n        return defaults(\n            {},\n            {\n                hasCreate,\n                hasEdit,\n                hasList,\n                hasShow,\n            },\n            resourceDefinitions[resource]\n        );\n    }, [resource, resourceDefinitions, hasCreate, hasEdit, hasList, hasShow]);\n\n    return definition;\n};\n\nexport interface UseResourceDefinitionOptions {\n    readonly resource?: string;\n    readonly hasList?: boolean;\n    readonly hasEdit?: boolean;\n    readonly hasShow?: boolean;\n    readonly hasCreate?: boolean;\n}\n","import jsonExport from 'jsonexport/dist';\n\nimport downloadCSV from './downloadCSV';\nimport { Exporter } from '../types';\n\nconst defaultExporter: Exporter = (data, _, __, resource) =>\n    jsonExport(data, (err, csv) => downloadCSV(csv, resource));\n\nexport default defaultExporter;\n","export default (csv, filename) => {\n    const fakeLink = document.createElement('a');\n    fakeLink.style.display = 'none';\n    document.body.appendChild(fakeLink);\n    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });\n    // @ts-ignore\n    if (window.navigator && window.navigator.msSaveOrOpenBlob) {\n        // Manage IE11+ & Edge\n        // @ts-ignore\n        window.navigator.msSaveOrOpenBlob(blob, `${filename}.csv`);\n    } else {\n        fakeLink.setAttribute('href', URL.createObjectURL(blob));\n        fakeLink.setAttribute('download', `${filename}.csv`);\n        fakeLink.click();\n    }\n};\n","import { createContext } from 'react';\n\nimport { Exporter } from '../types';\nimport defaultExporter from './defaultExporter';\n\nconst ExporterContext = createContext<Exporter | false>(defaultExporter);\n\nExporterContext.displayName = 'ExporterContext';\n\nexport default ExporterContext;\n","import { RaRecord, Identifier, DataProvider } from '../types';\n\n/**\n * Helper function for calling the dataProvider.getMany() method,\n * and getting a Promise for the records indexed by id in return.\n *\n * @example\n *     fetchRelatedRecords(dataProvider)(records, 'post_id', 'posts').then(posts =>\n *         posts.map(record => ({\n *             ...record,\n *             post_title: posts[record.post_id].title,\n *         }))\n *     );\n */\nconst fetchRelatedRecords = (dataProvider: DataProvider) => (\n    data,\n    field,\n    resource\n) =>\n    dataProvider\n        .getMany(resource, { ids: getRelatedIds(data, field) })\n        .then(({ data }) =>\n            data.reduce((acc, post) => {\n                acc[post.id] = post;\n                return acc;\n            }, {})\n        );\n\n/**\n * Extracts, aggregates and deduplicates the ids of related records\n *\n * @example\n *     const books = [\n *         { id: 1, author_id: 123, title: 'Pride and Prejudice' },\n *         { id: 2, author_id: 123, title: 'Sense and Sensibility' },\n *         { id: 3, author_id: 456, title: 'War and Peace' },\n *     ];\n *     getRelatedIds(books, 'author_id'); => [123, 456]\n *\n * @example\n *     const books = [\n *         { id: 1, tag_ids: [1, 2], title: 'Pride and Prejudice' },\n *         { id: 2, tag_ids: [2, 3], title: 'Sense and Sensibility' },\n *         { id: 3, tag_ids: [4], title: 'War and Peace' },\n *     ];\n *     getRelatedIds(records, 'tag_ids'); => [1, 2, 3, 4]\n *\n * @param {Object[]} records An array of records\n * @param {string} field the identifier of the record field to use\n */\nexport const getRelatedIds = (\n    records: RaRecord[],\n    field: string\n): Identifier[] =>\n    Array.from(\n        new Set(\n            records\n                .filter(record => record[field] != null)\n                .map(record => record[field])\n                .reduce((ids, value) => ids.concat(value), [])\n        )\n    );\n\nexport default fetchRelatedRecords;\n","import * as React from 'react';\nimport inflection from 'inflection';\n\nimport getValuesFromRecords from './getValuesFromRecords';\nimport InferredElement from './InferredElement';\n\nimport {\n    isObject,\n    valuesAreArray,\n    valuesAreBoolean,\n    valuesAreDate,\n    valuesAreDateString,\n    valuesAreHtml,\n    valuesAreInteger,\n    valuesAreNumeric,\n    valuesAreObject,\n    valuesAreString,\n} from './assertions';\nimport { InferredTypeMap } from './types';\n\nconst DefaultComponent = () => <span>;</span>;\nconst defaultType = {\n    type: DefaultComponent,\n    representation: () => '<DefaultComponent />',\n};\nconst defaultTypes = {\n    array: defaultType,\n    boolean: defaultType,\n    date: defaultType,\n    email: defaultType,\n    id: defaultType,\n    number: defaultType,\n    reference: defaultType,\n    referenceArray: defaultType,\n    richText: defaultType,\n    string: defaultType,\n    url: defaultType,\n};\n\nconst hasType = (type, types) => typeof types[type] !== 'undefined';\n\n/**\n * Guesses an element based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *         { number: NumberField, string: StringField }\n *     );\n *     // new InferredElement(<StringField source=\"address\" />)\n *\n * Types are optional: if a type isn't provided, the function falls back\n * to the nearest type.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField } // no richText type\n *     );\n *     // new InferredElement(<StringField source=\"content\" />)\n *\n * Types can be disabled by passing a falsy value.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField, richText: false }\n *     );\n *     // null\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n * @param {Object} types A set of components indexed by type. The string type is the only required one\n *\n * @return InferredElement\n */\nconst inferElementFromValues = (\n    name,\n    values = [],\n    types: InferredTypeMap = defaultTypes\n) => {\n    if (name === 'id' && hasType('id', types)) {\n        return new InferredElement(types.id, { source: name });\n    }\n    if (name.substr(name.length - 3) === '_id' && hasType('reference', types)) {\n        const reference = inflection.pluralize(name.substr(0, name.length - 3));\n        return (\n            types.reference &&\n            new InferredElement(\n                types.reference,\n                {\n                    source: name,\n                    reference,\n                },\n                new InferredElement(types.referenceChild)\n            )\n        );\n    }\n    if (name.substr(name.length - 2) === 'Id' && hasType('reference', types)) {\n        const reference = inflection.pluralize(name.substr(0, name.length - 2));\n        return (\n            types.reference &&\n            new InferredElement(\n                types.reference,\n                {\n                    source: name,\n                    reference,\n                },\n                new InferredElement(types.referenceChild)\n            )\n        );\n    }\n    if (\n        name.substr(name.length - 4) === '_ids' &&\n        hasType('referenceArray', types)\n    ) {\n        const reference = inflection.pluralize(name.substr(0, name.length - 4));\n        return (\n            types.referenceArray &&\n            new InferredElement(\n                types.referenceArray,\n                {\n                    source: name,\n                    reference,\n                },\n                new InferredElement(types.referenceArrayChild)\n            )\n        );\n    }\n    if (\n        name.substr(name.length - 3) === 'Ids' &&\n        hasType('referenceArray', types)\n    ) {\n        const reference = inflection.pluralize(name.substr(0, name.length - 3));\n        return (\n            types.referenceArray &&\n            new InferredElement(\n                types.referenceArray,\n                {\n                    source: name,\n                    reference,\n                },\n                new InferredElement(types.referenceArrayChild)\n            )\n        );\n    }\n    if (values.length === 0) {\n        // FIXME introspect further using name\n        return new InferredElement(types.string, { source: name });\n    }\n    if (valuesAreArray(values)) {\n        if (isObject(values[0][0]) && hasType('array', types)) {\n            const leafValues = getValuesFromRecords(\n                values.reduce((acc, vals) => acc.concat(vals), [])\n            );\n            // FIXME bad visual representation\n            return (\n                types.array &&\n                new InferredElement(\n                    types.array,\n                    {\n                        source: name,\n                    },\n                    Object.keys(leafValues).map(leafName =>\n                        inferElementFromValues(\n                            leafName,\n                            leafValues[leafName],\n                            types\n                        )\n                    )\n                )\n            );\n        }\n        // FIXME introspect further\n        return new InferredElement(types.string, { source: name });\n    }\n    if (valuesAreBoolean(values) && hasType('boolean', types)) {\n        return new InferredElement(types.boolean, { source: name });\n    }\n    if (valuesAreDate(values) && hasType('date', types)) {\n        return new InferredElement(types.date, { source: name });\n    }\n    if (valuesAreString(values)) {\n        if (name === 'email' && hasType('email', types)) {\n            return new InferredElement(types.email, { source: name });\n        }\n        if (name === 'url' && hasType('url', types)) {\n            return new InferredElement(types.url, { source: name });\n        }\n        if (valuesAreDateString(values) && hasType('date', types)) {\n            return new InferredElement(types.date, { source: name });\n        }\n        if (valuesAreHtml(values) && hasType('richText', types)) {\n            return new InferredElement(types.richText, { source: name });\n        }\n        return new InferredElement(types.string, { source: name });\n    }\n    if (\n        (valuesAreInteger(values) || valuesAreNumeric(values)) &&\n        hasType('number', types)\n    ) {\n        return new InferredElement(types.number, { source: name });\n    }\n    if (valuesAreObject(values)) {\n        // we need to go deeper\n        // Arbitrarily, choose the first prop of the first object\n        const propName = Object.keys(values[0]).shift();\n        const leafValues = values.map(v => v[propName]);\n        return inferElementFromValues(`${name}.${propName}`, leafValues, types);\n    }\n    return new InferredElement(types.string, { source: name });\n};\n\nexport default inferElementFromValues;\n","/**\n * Gets a list of values indexed by field based on a list of records\n *\n * @example\n * const records = [\n *     {\n *         id: 1,\n *         title: \"Lorem Ipsum\",\n *         views: 254,\n *         user_id: 123,\n *     },\n *     {\n *         id: 2,\n *         title: \"Sic Dolor amet\",\n *         views: 65,\n *         user_id: 456,\n *     },\n * ];\n * getValuesFromRecords(records);\n * // {\n * //    id: [1, 2],\n * //    title: ['Lorem Ipsum', 'Sic Dolor amet'],\n * //    views: [254, 65],\n * //    user_id: [123, 456],\n * // }\n */\nexport default (records: any[]) =>\n    records.reduce((values, record) => {\n        Object.keys(record).forEach(fieldName => {\n            if (!values[fieldName]) {\n                values[fieldName] = [];\n            }\n            if (record[fieldName] != null) {\n                const value = Array.isArray(record[fieldName])\n                    ? [record[fieldName]]\n                    : record[fieldName];\n                values[fieldName] = values[fieldName].concat(value);\n            }\n        });\n        return values;\n    }, {});\n","import { createElement } from 'react';\nimport { InferredType } from './types';\n\nclass InferredElement {\n    constructor(\n        private type?: InferredType,\n        private props?: any,\n        private children?: any\n    ) {}\n\n    getElement(props = {}) {\n        if (!this.isDefined()) {\n            return;\n        }\n        return this.children\n            ? createElement(\n                  this.type.component,\n                  { ...this.props, ...props },\n                  this.children.length > 0\n                      ? this.children.map((child, index) =>\n                            child.getElement({ key: index })\n                        )\n                      : this.children.getElement()\n              )\n            : createElement(this.type.component, { ...this.props, ...props });\n    }\n\n    getProps() {\n        return this.props;\n    }\n\n    isDefined() {\n        return !!this.type;\n    }\n\n    getRepresentation() {\n        if (!this.isDefined()) {\n            return;\n        }\n        if (this.type.representation) {\n            return this.type.representation(this.props, this.children);\n        }\n        return `<${\n            this.type.component.displayName || this.type.component.name\n        } source=\"${this.props.source}\" />`;\n    }\n}\n\nexport default InferredElement;\n","import { isMatch, isValid, parseISO } from 'date-fns';\n\nexport const isNumeric = (value: any) =>\n    !isNaN(parseFloat(value)) && isFinite(value);\nexport const valuesAreNumeric = (values: any[]) => values.every(isNumeric);\n\nexport const isInteger = (value: any) =>\n    Number.isInteger(value) || !isNaN(parseInt(value));\nexport const valuesAreInteger = (values: any[]) => values.every(isInteger);\n\nexport const isBoolean = (value: any) => typeof value === 'boolean';\nexport const valuesAreBoolean = (values: any[]) => values.every(isBoolean);\n\nexport const isBooleanString = (value: any) =>\n    ['true', 'false'].includes(value.toString().toLowerCase());\nexport const valuesAreBooleanString = (values: any[]) =>\n    values.every(isBooleanString);\n\nexport const isString = (value: any) => typeof value === 'string';\nexport const valuesAreString = (values: any[]) => values.every(isString);\n\nconst HtmlRegexp = /<([A-Z][A-Z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/i;\nexport const isHtml = (value: any) => !value || HtmlRegexp.test(value);\nexport const valuesAreHtml = (values: any[]) => values.every(isHtml);\n\nconst UrlRegexp = /http(s*):\\/\\/.*/i;\nexport const isUrl = (value: any) => !value || UrlRegexp.test(value);\nexport const valuesAreUrl = (values: any[]) => values.every(isUrl);\n\nconst ImageUrlRegexp = /http(s*):\\/\\/.*\\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;\nexport const isImageUrl = (value: any) => !value || ImageUrlRegexp.test(value);\nexport const valuesAreImageUrl = (values: any[]) => values.every(isImageUrl);\n\n// This is a very simple regex to find emails\n// It is NOT meant to validate emails as the spec is way more complicated but is\n// enough for our inference needs\nconst EmailRegexp = /@{1}/;\nexport const isEmail = (value: any) => !value || EmailRegexp.test(value);\nexport const valuesAreEmail = (values: any[]) => values.every(isEmail);\n\nexport const isArray = (value: any) => Array.isArray(value);\nexport const valuesAreArray = (values: any[]) => values.every(isArray);\n\nexport const isDate = (value: any) => !value || value instanceof Date;\nexport const valuesAreDate = (values: any[]) => values.every(isDate);\n\nexport const isDateString = (value: any) =>\n    !value ||\n    (typeof value === 'string' &&\n        (isMatch(value, 'MM/dd/yyyy') ||\n            isMatch(value, 'MM/dd/yy') ||\n            isValid(parseISO(value))));\n\nexport const valuesAreDateString = (values: any[]) =>\n    values.every(isDateString);\n\nexport const isObject = (value: any) =>\n    Object.prototype.toString.call(value) === '[object Object]';\nexport const valuesAreObject = (values: any[]) => values.every(isObject);\n","import inferElementFromValues from './inferElementFromValues';\nimport getValuesFromRecords from './getValuesFromRecords';\nimport { InferredTypeMap } from './types';\n\n/**\n * Get a list of React-admin field components from a list of records\n *\n * @example\n * const records = [\n *     {\n *         \"id\": 1,\n *         \"title\": \"Lorem Ipsum\",\n *         \"views\": 254,\n *         \"user_id\": 123,\n *     },\n *     {\n *         \"id\": 2,\n *         \"title\": \"Sic Dolor amet\",\n *         \"user_id\": 456,\n *     },\n * ];\n * const types = {\n *     id: NumberField,\n *     string: TextField,\n *     number: NumberField,\n *     reference: ReferenceField\n * };\n * const components = getElementsFromRecords(records, types);\n * // [\n * //    <NumberField source=\"id\" />,\n * //    <TextField source=\"title\" />,\n * //    <NumberField source=\"views\" />,\n * //    <ReferenceField source=\"user_id\" reference=\"users\"><NumberField source=\"id\" /></ReferenceField>,\n * // ];\n */\nexport default (records: any[], types: InferredTypeMap) => {\n    const fieldValues = getValuesFromRecords(records);\n    return Object.keys(fieldValues)\n        .reduce(\n            (fields, fieldName) =>\n                fields.concat(\n                    inferElementFromValues(\n                        fieldName,\n                        fieldValues[fieldName],\n                        types\n                    )\n                ),\n            []\n        )\n        .filter(inferredElement => inferredElement.isDefined());\n};\n","import inflection from 'inflection';\n\nimport getValuesFromRecords from './getValuesFromRecords';\n\nimport {\n    isObject,\n    valuesAreArray,\n    valuesAreBoolean,\n    valuesAreDate,\n    valuesAreDateString,\n    valuesAreHtml,\n    valuesAreInteger,\n    valuesAreNumeric,\n    valuesAreObject,\n    valuesAreString,\n    valuesAreUrl,\n    valuesAreImageUrl,\n    valuesAreEmail,\n} from './assertions';\n\nexport const InferenceTypes = [\n    'array',\n    'boolean',\n    'date',\n    'email',\n    'id',\n    'image',\n    'number',\n    'reference',\n    'referenceChild',\n    'referenceArray',\n    'referenceArrayChild',\n    'richText',\n    'string',\n    'url',\n    'object',\n] as const;\n\nexport type PossibleInferredElementTypes = typeof InferenceTypes[number];\n\nexport interface InferredElementDescription {\n    type: PossibleInferredElementTypes;\n    props?: any;\n    children?: InferredElementDescription | InferredElementDescription[];\n}\n\n/**\n * Guesses an element type based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *     );\n *     // { type: 'string', props: { source: 'address' } }\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n */\nexport const inferTypeFromValues = (\n    name,\n    values = []\n): InferredElementDescription => {\n    if (name === 'id') {\n        return { type: 'id', props: { source: name } };\n    }\n    if (name.substr(name.length - 3) === '_id') {\n        return {\n            type: 'reference',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 3)\n                ),\n            },\n            children: { type: 'referenceChild' },\n        };\n    }\n    if (name.substr(name.length - 2) === 'Id') {\n        return {\n            type: 'reference',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 2)\n                ),\n            },\n            children: { type: 'referenceChild' },\n        };\n    }\n    if (name.substr(name.length - 4) === '_ids') {\n        return {\n            type: 'referenceArray',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 4)\n                ),\n            },\n            children: { type: 'referenceArrayChild' },\n        };\n    }\n    if (name.substr(name.length - 3) === 'Ids') {\n        return {\n            type: 'referenceArray',\n            props: {\n                source: name,\n                reference: inflection.pluralize(\n                    name.substr(0, name.length - 3)\n                ),\n            },\n            children: { type: 'referenceArrayChild' },\n        };\n    }\n    if (values.length === 0) {\n        if (name === 'email') {\n            return { type: 'email', props: { source: name } };\n        }\n        if (name === 'url') {\n            return { type: 'url', props: { source: name } };\n        }\n        // FIXME introspect further using name\n        return { type: 'string', props: { source: name } };\n    }\n    if (valuesAreArray(values)) {\n        if (isObject(values[0][0])) {\n            const leafValues = getValuesFromRecords(\n                values.reduce((acc, vals) => acc.concat(vals), [])\n            );\n            // FIXME bad visual representation\n            return {\n                type: 'array',\n                props: { source: name },\n                children: Object.keys(leafValues).map(leafName =>\n                    inferTypeFromValues(leafName, leafValues[leafName])\n                ),\n            };\n        }\n        // FIXME introspect further\n        return { type: 'string', props: { source: name } };\n    }\n    if (valuesAreBoolean(values)) {\n        return { type: 'boolean', props: { source: name } };\n    }\n    if (valuesAreDate(values)) {\n        return { type: 'date', props: { source: name } };\n    }\n    if (valuesAreString(values)) {\n        if (name === 'email' || valuesAreEmail(values)) {\n            return { type: 'email', props: { source: name } };\n        }\n        if (name === 'url' || valuesAreUrl(values)) {\n            if (valuesAreImageUrl(values)) {\n                return { type: 'image', props: { source: name } };\n            }\n            return { type: 'url', props: { source: name } };\n        }\n        if (valuesAreDateString(values)) {\n            return { type: 'date', props: { source: name } };\n        }\n        if (valuesAreHtml(values)) {\n            return { type: 'richText', props: { source: name } };\n        }\n        if (valuesAreInteger(values) || valuesAreNumeric(values)) {\n            return { type: 'number', props: { source: name } };\n        }\n        return { type: 'string', props: { source: name } };\n    }\n    if (valuesAreInteger(values) || valuesAreNumeric(values)) {\n        return { type: 'number', props: { source: name } };\n    }\n    if (valuesAreObject(values)) {\n        /// Arbitrarily, choose the first prop of the first object\n        const propName = Object.keys(values[0]).shift();\n        const leafValues = values.map(v => v[propName]);\n        return inferTypeFromValues(`${name}.${propName}`, leafValues);\n    }\n    return { type: 'string', props: { source: name } };\n};\n","import { useEffect, useRef, useCallback } from 'react';\nimport debounce from 'lodash/debounce';\nimport isEqual from 'lodash/isEqual';\n\nimport { useSafeSetState } from '../util';\nimport { FilterPayload } from '../types';\n\ninterface UseFilterStateOptions {\n    filterToQuery?: (v: string) => FilterPayload;\n    permanentFilter?: FilterPayload;\n    debounceTime?: number;\n}\n\n/**\n * @typedef UseFilterStateProps\n * @property {Object} filter: The filter object.\n * @property {setFilter} setFilter: Update the filter with the given string\n */\ninterface UseFilterStateProps {\n    filter: FilterPayload;\n    setFilter: (v: string) => void;\n}\n\nconst defaultFilterToQuery = (v: string) => ({ q: v });\n\n/**\n * Hooks to provide filter state and setFilter which update the query part of the filter\n *\n * @example\n *\n * const { filter, setFilter } = useFilter({\n *      filterToQuery: v => ({ query: v }),\n *      permanentFilter: { foo: 'bar' },\n *      debounceTime: 500,\n * });\n * // filter initial value:\n * {\n *      query: '',\n *      foo: 'bar'\n * }\n *  // after updating filter\n *  setFilter('needle');\n *  {\n *      query: 'needle',\n *      foo: 'bar'\n *  }\n *\n * @param {Object} option\n * @param {Function} option.filterToQuery Function to convert the filter string to a filter object. Defaults to v => ({ q: v }).\n * @param {Object} option.permanentFilter Permanent filter to be merged with the filter string. Defaults to {}.\n * @param {number} option.debounceTime Time in ms between filter updates - used to debounce the search. Defaults to 500ms.\n *\n * @returns {UseFilterStateOptions} The filter props\n */\nexport default ({\n    filterToQuery = defaultFilterToQuery,\n    permanentFilter = {},\n    debounceTime = 500,\n}: UseFilterStateOptions): UseFilterStateProps => {\n    const permanentFilterProp = useRef(permanentFilter);\n    const latestValue = useRef<string>();\n    const [filter, setFilterValue] = useSafeSetState({\n        ...permanentFilter,\n        ...filterToQuery(''),\n    });\n    // Developers often pass an object literal as permanent filter\n    // e.g. <ReferenceInput source=\"book_id\" reference=\"books\" filter={{ is_published: true }}>\n    // The effect should execute again when the parent component updates the filter value,\n    // but not when the object literal describes the same values. Therefore,\n    // we use JSON.stringify(permanentFilter) in the `useEffect` and `useCallback`\n    // dependencies instead of permanentFilter.\n    const permanentFilterSignature = JSON.stringify(permanentFilter);\n\n    useEffect(() => {\n        if (!isEqual(permanentFilterProp.current, permanentFilter)) {\n            permanentFilterProp.current = permanentFilter;\n            setFilterValue({\n                ...permanentFilter,\n                ...filterToQuery(latestValue.current),\n            });\n        }\n    }, [permanentFilterSignature, permanentFilterProp, filterToQuery]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const setFilter = useCallback(\n        debounce((value: string) => {\n            setFilterValue({\n                ...permanentFilter,\n                ...filterToQuery(value),\n            });\n            latestValue.current = value;\n        }, debounceTime),\n        [permanentFilterSignature] // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    return {\n        filter,\n        setFilter,\n    };\n};\n","import { useReducer, useEffect, useRef, useCallback } from 'react';\n\nimport { SORT_ASC, SORT_DESC } from './list/queryReducer';\nimport { SortPayload } from '../types';\n\nexport interface SortProps {\n    setSortField: (field: SortPayload['field']) => void;\n    setSortOrder: (order: SortPayload['order']) => void;\n    setSort: (sort: SortPayload) => void;\n    sort: SortPayload;\n}\n\ntype Action =\n    | { type: 'SET_SORT'; payload: SortPayload }\n    | { type: 'SET_SORT_FIELD'; payload: SortPayload['field'] }\n    | { type: 'SET_SORT_ORDER'; payload: SortPayload['order'] };\n\nconst sortReducer = (state: SortPayload, action: Action): SortPayload => {\n    switch (action.type) {\n        case 'SET_SORT':\n            return action.payload;\n        case 'SET_SORT_FIELD': {\n            const field = action.payload;\n            const order =\n                state.field === field\n                    ? state.order === SORT_ASC\n                        ? SORT_DESC\n                        : SORT_ASC\n                    : SORT_ASC;\n            return { field, order };\n        }\n        case 'SET_SORT_ORDER': {\n            const order = action.payload;\n            return {\n                ...state,\n                order,\n            };\n        }\n        default:\n            return state;\n    }\n};\n\nexport const defaultSort = { field: 'id', order: 'DESC' };\n\n/**\n * Set the sort { field, order }\n * @name setSort\n * @function\n * @param {SortPayload} sort the sort object\n */\n\n/**\n * Set the sort field, swap the order if the field is the same\n * @name setSortField\n * @function\n * @param {string} field the sort field\n */\n\n/**\n * Set the sort order\n * @name setSortOrder\n * @function\n * @param {string} order The sort order, either ASC or DESC\n */\n\n/**\n * @typedef SortProps\n * @type {Object}\n * @property {Object} sort: the sort object.\n * @property {string} sort.field: the sort object.\n * @property {'ASC' | 'DESC'} sort.order: the sort object.\n * @property {setSort} setSort\n * @property {setSortField} setSortField\n * @property {setSortOrder} setSortOrder\n */\n\n/**\n * Hooks to provide sort state\n *\n * @example\n *\n * const { sort, setSort, setSortField, setSortOrder } = useSort({\n *      field: 'name',\n *      order: 'ASC',\n * });\n *\n * setSort({ field: 'name', order: 'ASC' });\n * // is the same as\n * setSortField('name');\n * setSortOrder('ASC');\n *\n * @param {Object} initialSort\n * @param {string} initialSort.field The initial sort field\n * @param {string} initialSort.order The initial sort order\n * @returns {SortProps} The sort props\n */\nconst useSortState = (initialSort: SortPayload = defaultSort): SortProps => {\n    const [sort, dispatch] = useReducer(sortReducer, initialSort);\n    const isFirstRender = useRef(true);\n    useEffect(() => {\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        dispatch({ type: 'SET_SORT', payload: initialSort });\n    }, [initialSort.field, initialSort.order]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return {\n        setSort: useCallback(\n            (sort: SortPayload) =>\n                dispatch({ type: 'SET_SORT', payload: sort }),\n            [dispatch]\n        ),\n        setSortField: useCallback(\n            (field: string) =>\n                dispatch({ type: 'SET_SORT_FIELD', payload: field }),\n            [dispatch]\n        ),\n        setSortOrder: useCallback(\n            (order: string) =>\n                dispatch({ type: 'SET_SORT_ORDER', payload: order }),\n            [dispatch]\n        ),\n        sort,\n    };\n};\n\nexport default useSortState;\n","import { Reducer } from 'react';\nimport set from 'lodash/set';\n\nimport removeEmpty from '../../util/removeEmpty';\nimport removeKey from '../../util/removeKey';\nimport { ListParams } from './useListParams';\n\nexport const SET_SORT = 'SET_SORT';\nexport const SORT_ASC = 'ASC';\nexport const SORT_DESC = 'DESC';\n\nexport const SET_PAGE = 'SET_PAGE';\nexport const SET_PER_PAGE = 'SET_PER_PAGE';\n\nexport const SET_FILTER = 'SET_FILTER';\nexport const SHOW_FILTER = 'SHOW_FILTER';\nexport const HIDE_FILTER = 'HIDE_FILTER';\n\nconst oppositeOrder = direction =>\n    direction === SORT_DESC ? SORT_ASC : SORT_DESC;\n\ntype ActionTypes =\n    | {\n          type: typeof SET_SORT;\n          payload: {\n              field: string;\n              order?: typeof SORT_ASC | typeof SORT_DESC;\n          };\n      }\n    | {\n          type: typeof SET_PAGE;\n          payload: number;\n      }\n    | {\n          type: typeof SET_PER_PAGE;\n          payload: number;\n      }\n    | {\n          type: typeof SET_FILTER;\n          payload: {\n              filter: any;\n              displayedFilters?: { [key: string]: boolean };\n          };\n      }\n    | {\n          type: typeof SHOW_FILTER;\n          payload: { filterName: string; defaultValue?: any };\n      }\n    | {\n          type: typeof HIDE_FILTER;\n          payload: string;\n      };\n\n/**\n * This reducer is for the react-router query string.\n */\nexport const queryReducer: Reducer<ListParams, ActionTypes> = (\n    previousState,\n    action\n) => {\n    switch (action.type) {\n        case SET_SORT:\n            if (action.payload.field === previousState.sort) {\n                return {\n                    ...previousState,\n                    order: oppositeOrder(previousState.order),\n                    page: 1,\n                };\n            }\n\n            return {\n                ...previousState,\n                sort: action.payload.field,\n                order: action.payload.order || SORT_ASC,\n                page: 1,\n            };\n\n        case SET_PAGE:\n            return { ...previousState, page: action.payload };\n\n        case SET_PER_PAGE:\n            return { ...previousState, page: 1, perPage: action.payload };\n\n        case SET_FILTER: {\n            return {\n                ...previousState,\n                page: 1,\n                filter: action.payload.filter,\n                displayedFilters: action.payload.displayedFilters\n                    ? action.payload.displayedFilters\n                    : previousState.displayedFilters,\n            };\n        }\n\n        case SHOW_FILTER: {\n            if (\n                previousState.displayedFilters &&\n                previousState.displayedFilters[action.payload.filterName]\n            ) {\n                // the filter is already shown\n                return previousState;\n            }\n            return {\n                ...previousState,\n                filter:\n                    typeof action.payload.defaultValue !== 'undefined'\n                        ? set(\n                              previousState.filter,\n                              action.payload.filterName,\n                              action.payload.defaultValue\n                          )\n                        : previousState.filter,\n                // we don't use lodash.set() for displayed filters\n                // to avoid problems with compound filter names (e.g. 'author.name')\n                displayedFilters: {\n                    ...previousState.displayedFilters,\n                    [action.payload.filterName]: true,\n                },\n            };\n        }\n\n        case HIDE_FILTER: {\n            return {\n                ...previousState,\n                filter: removeEmpty(\n                    removeKey(previousState.filter, action.payload)\n                ),\n                // we don't use lodash.set() for displayed filters\n                // to avoid problems with compound filter names (e.g. 'author.name')\n                displayedFilters: previousState.displayedFilters\n                    ? Object.keys(previousState.displayedFilters).reduce(\n                          (filters, filter) => {\n                              return filter !== action.payload\n                                  ? { ...filters, [filter]: true }\n                                  : filters;\n                          },\n                          {}\n                      )\n                    : previousState.displayedFilters,\n            };\n        }\n\n        default:\n            return previousState;\n    }\n};\n\nexport default queryReducer;\n","import { useEffect, useReducer, useCallback, useRef } from 'react';\nimport { PaginationPayload } from '../types';\n\n/**\n * @typedef PaginationProps\n * @type {Object}\n * @property {number} page: The page number.\n * @property {number} perPage: The number of item per page.\n * @property {Function} setPage: Set the page number\n * @property {Function} setPerPage: Set the per page number\n * @property {Function} setPagination: Set page and perPage pagination numbers\n */\nexport interface PaginationHookResult {\n    page: number;\n    perPage: number;\n    pagination: PaginationPayload;\n    setPage: (page: number) => void;\n    setPerPage: (perPage: number) => void;\n    setPagination: (pagination: PaginationPayload) => void;\n}\n\nconst paginationReducer = (\n    prevState: PaginationPayload,\n    nextState: Partial<PaginationPayload>\n): PaginationPayload => {\n    return {\n        ...prevState,\n        ...nextState,\n    };\n};\n\nconst defaultPagination = {\n    page: 1,\n    perPage: 25,\n};\n\n/**\n * Hooks to provide pagination state (page and perPage)\n *\n * @example\n *\n * const { page, setPage, perPage, setPerPage } = usePagination(initialPerPage);\n *\n * @param {number} initialPagination the initial value per page\n * @returns {PaginationHookResult} The pagination props\n */\nexport default (\n    initialPagination: { perPage?: number; page?: number } = {}\n): PaginationHookResult => {\n    const [pagination, setPagination] = useReducer(paginationReducer, {\n        ...defaultPagination,\n        ...initialPagination,\n    });\n    const isFirstRender = useRef(true);\n\n    const setPerPage = useCallback(\n        perPage => setPagination({ perPage, page: 1 }),\n        []\n    );\n    const setPage = useCallback(page => setPagination({ page }), []);\n\n    useEffect(() => {\n        if (isFirstRender.current) {\n            isFirstRender.current = false;\n            return;\n        }\n        setPerPage(initialPagination.perPage || 25);\n    }, [initialPagination.perPage, setPerPage]);\n\n    return {\n        page: pagination.page,\n        perPage: pagination.perPage,\n        pagination,\n        setPage,\n        setPerPage,\n        setPagination,\n    };\n};\n","import * as React from 'react';\nimport { ComponentType } from 'react';\n\nconst checkMinimumRequiredProps = (\n    displayName: string,\n    requiredProps: string[]\n) => (WrappedComponent: ComponentType) => (props: any) => {\n    useCheckMinimumRequiredProps(displayName, requiredProps, props);\n    return <WrappedComponent {...props} />;\n};\n\nexport default checkMinimumRequiredProps;\n\n// Not a hook but named that way to avoid conflicts with the old one\nexport const useCheckMinimumRequiredProps = (\n    displayName: string,\n    requiredProps: string[],\n    props: any\n): void => {\n    const propNames = Object.keys(props);\n    const missingProps = requiredProps.filter(\n        prop => !propNames.includes(prop)\n    );\n\n    if (missingProps.length > 0) {\n        throw new Error(\n            `<${displayName}> component is not properly configured, some essential props are missing.\nBe sure to pass the props from the parent. Example:\n\nconst My${displayName} = props => (\n    <${displayName} {...props}></${displayName}>\n);\n\nThe missing props are: ${missingProps.join(', ')}`\n        );\n    }\n};\n","import { useCallback, ReactEventHandler } from 'react';\nimport { UseMutationOptions } from 'react-query';\n\nimport { useDelete } from '../../dataProvider';\nimport { useUnselect } from '../../controller';\nimport { useRedirect, RedirectionSideEffect } from '../../routing';\nimport { useNotify } from '../../notification';\nimport { RaRecord, DeleteParams } from '../../types';\nimport { useResourceContext } from '../../core';\n\n/**\n * Prepare callback for a Delete button with undo support\n *\n * @example\n *\n * import React from 'react';\n * import ActionDelete from '@mui/icons-material/Delete';\n * import { Button, useDeleteWithUndoController } from 'react-admin';\n *\n * const DeleteButton = ({\n *     resource,\n *     record,\n *     redirect,\n *     onClick,\n *     ...rest\n * }) => {\n *     const { isLoading, handleDelete } = useDeleteWithUndoController({\n *         resource,\n *         record,\n *         redirect,\n *         onClick,\n *     });\n *\n *     return (\n *         <Button\n *             onClick={handleDelete}\n *             disabled={isLoading}\n *             label=\"ra.action.delete\"\n *             {...rest}\n *         >\n *             <ActionDelete />\n *         </Button>\n *     );\n * };\n */\nconst useDeleteWithUndoController = <RecordType extends RaRecord = any>(\n    props: UseDeleteWithUndoControllerParams<RecordType>\n): UseDeleteWithUndoControllerReturn => {\n    const {\n        record,\n        redirect: redirectTo = 'list',\n        onClick,\n        mutationOptions,\n    } = props;\n    const resource = useResourceContext(props);\n    const notify = useNotify();\n    const unselect = useUnselect(resource);\n    const redirect = useRedirect();\n    const [deleteOne, { isLoading }] = useDelete<RecordType>();\n\n    const handleDelete = useCallback(\n        event => {\n            event.stopPropagation();\n            deleteOne(\n                resource,\n                { id: record.id, previousData: record },\n                {\n                    onSuccess: () => {\n                        notify('ra.notification.deleted', {\n                            type: 'info',\n                            messageArgs: { smart_count: 1 },\n                            undoable: true,\n                        });\n                        unselect([record.id]);\n                        redirect(redirectTo, resource);\n                    },\n                    onError: (error: Error) => {\n                        notify(\n                            typeof error === 'string'\n                                ? error\n                                : error.message || 'ra.notification.http_error',\n                            {\n                                type: 'warning',\n                                messageArgs: {\n                                    _:\n                                        typeof error === 'string'\n                                            ? error\n                                            : error && error.message\n                                            ? error.message\n                                            : undefined,\n                                },\n                            }\n                        );\n                    },\n                    mutationMode: 'undoable',\n                    ...mutationOptions,\n                }\n            );\n            if (typeof onClick === 'function') {\n                onClick(event);\n            }\n        },\n        [\n            deleteOne,\n            mutationOptions,\n            notify,\n            onClick,\n            record,\n            redirect,\n            redirectTo,\n            resource,\n            unselect,\n        ]\n    );\n\n    return { isLoading, handleDelete };\n};\n\nexport interface UseDeleteWithUndoControllerParams<\n    RecordType extends RaRecord = any\n> {\n    record?: RecordType;\n    redirect?: RedirectionSideEffect;\n    // @deprecated. This hook get the resource from the context\n    resource?: string;\n    onClick?: ReactEventHandler<any>;\n    mutationOptions?: UseMutationOptions<\n        RecordType,\n        unknown,\n        DeleteParams<RecordType>\n    >;\n}\n\nexport interface UseDeleteWithUndoControllerReturn {\n    isLoading: boolean;\n    handleDelete: ReactEventHandler<any>;\n}\n\nexport default useDeleteWithUndoController;\n","import {\n    useState,\n    useCallback,\n    ReactEventHandler,\n    SyntheticEvent,\n} from 'react';\nimport { UseMutationOptions } from 'react-query';\n\nimport { useDelete } from '../../dataProvider';\nimport { useUnselect } from '../../controller';\nimport { useRedirect, RedirectionSideEffect } from '../../routing';\nimport { useNotify } from '../../notification';\nimport { RaRecord, MutationMode, DeleteParams } from '../../types';\nimport { useResourceContext } from '../../core';\n\n/**\n * Prepare a set of callbacks for a delete button guarded by confirmation dialog\n *\n * @example\n *\n * const DeleteButton = ({\n *     resource,\n *     record,\n *     redirect,\n *     onClick,\n *     ...rest\n * }) => {\n *     const {\n *         open,\n *         isLoading,\n *         handleDialogOpen,\n *         handleDialogClose,\n *         handleDelete,\n *     } = useDeleteWithConfirmController({\n *         resource,\n *         record,\n *         redirect,\n *         onClick,\n *     });\n *\n *     return (\n *         <Fragment>\n *             <Button\n *                 onClick={handleDialogOpen}\n *                 label=\"ra.action.delete\"\n *                 {...rest}\n *             >\n *                 {icon}\n *             </Button>\n *             <Confirm\n *                 isOpen={open}\n *                 loading={isLoading}\n *                 title=\"ra.message.delete_title\"\n *                 content=\"ra.message.delete_content\"\n *                 translateOptions={{\n *                     name: resource,\n *                     id: record.id,\n *                 }}\n *                 onConfirm={handleDelete}\n *                 onClose={handleDialogClose}\n *             />\n *         </Fragment>\n *     );\n * };\n */\nconst useDeleteWithConfirmController = <RecordType extends RaRecord = any>(\n    props: UseDeleteWithConfirmControllerParams<RecordType>\n): UseDeleteWithConfirmControllerReturn => {\n    const {\n        record,\n        redirect: redirectTo,\n        mutationMode,\n        onClick,\n        mutationOptions,\n    } = props;\n    const resource = useResourceContext(props);\n    const [open, setOpen] = useState(false);\n    const notify = useNotify();\n    const unselect = useUnselect(resource);\n    const redirect = useRedirect();\n    const [deleteOne, { isLoading }] = useDelete<RecordType>();\n\n    const handleDialogOpen = e => {\n        setOpen(true);\n        e.stopPropagation();\n    };\n\n    const handleDialogClose = e => {\n        setOpen(false);\n        e.stopPropagation();\n    };\n\n    const handleDelete = useCallback(\n        event => {\n            event.stopPropagation();\n            deleteOne(\n                resource,\n                { id: record.id, previousData: record },\n                {\n                    onSuccess: () => {\n                        setOpen(false);\n                        notify('ra.notification.deleted', {\n                            type: 'info',\n                            messageArgs: { smart_count: 1 },\n                            undoable: mutationMode === 'undoable',\n                        });\n                        unselect([record.id]);\n                        redirect(redirectTo, resource);\n                    },\n                    onError: (error: Error) => {\n                        setOpen(false);\n\n                        notify(\n                            typeof error === 'string'\n                                ? error\n                                : error.message || 'ra.notification.http_error',\n                            {\n                                type: 'warning',\n                                messageArgs: {\n                                    _:\n                                        typeof error === 'string'\n                                            ? error\n                                            : error && error.message\n                                            ? error.message\n                                            : undefined,\n                                },\n                            }\n                        );\n                    },\n                    mutationMode,\n                    ...mutationOptions,\n                }\n            );\n            if (typeof onClick === 'function') {\n                onClick(event);\n            }\n        },\n        [\n            deleteOne,\n            mutationMode,\n            mutationOptions,\n            notify,\n            onClick,\n            record,\n            redirect,\n            redirectTo,\n            resource,\n            unselect,\n        ]\n    );\n\n    return {\n        open,\n        isLoading,\n        handleDialogOpen,\n        handleDialogClose,\n        handleDelete,\n    };\n};\n\nexport interface UseDeleteWithConfirmControllerParams<\n    RecordType extends RaRecord = any\n> {\n    mutationMode?: MutationMode;\n    record?: RecordType;\n    redirect?: RedirectionSideEffect;\n    // @deprecated. This hook get the resource from the context\n    resource?: string;\n    onClick?: ReactEventHandler<any>;\n    mutationOptions?: UseMutationOptions<\n        RecordType,\n        unknown,\n        DeleteParams<RecordType>\n    >;\n}\n\nexport interface UseDeleteWithConfirmControllerReturn {\n    open: boolean;\n    isLoading: boolean;\n    handleDialogOpen: (e: SyntheticEvent) => void;\n    handleDialogClose: (e: SyntheticEvent) => void;\n    handleDelete: ReactEventHandler<any>;\n}\n\nexport default useDeleteWithConfirmController;\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport {\n    useCreateController,\n    CreateControllerProps,\n} from './useCreateController';\nimport { CreateContextProvider } from './CreateContextProvider';\nimport { RaRecord } from '../../types';\n\n/**\n * Call useCreateController and put the value in a CreateContext\n *\n * Base class for <Create> components, without UI.\n *\n * Accepts any props accepted by useCreateController:\n * - id: The record identifier\n * - resource: The resource\n *\n * @example // Custom edit layout\n *\n * const PostCreate = props => (\n *     <CreateBase {...props}>\n *         <Grid container>\n *             <Grid item xs={8}>\n *                 <SimpleForm>\n *                     ...\n *                 </SimpleForm>\n *             </Grid>\n *             <Grid item xs={4}>\n *                 Create instructions...\n *             </Grid>\n *         </Grid>\n *         <div>\n *             Post related links...\n *         </div>\n *     </CreateBase>\n * );\n */\nexport const CreateBase = <RecordType extends RaRecord = any>({\n    children,\n    ...props\n}: CreateControllerProps<RecordType> & { children: ReactNode }) => (\n    <CreateContextProvider value={useCreateController(props)}>\n        {children}\n    </CreateContextProvider>\n);\n","import { useCallback } from 'react';\n// @ts-ignore\nimport { parse } from 'query-string';\nimport { useLocation } from 'react-router-dom';\nimport { Location } from 'history';\nimport { UseMutationOptions } from 'react-query';\n\nimport { useAuthenticated } from '../../auth';\nimport { useCreate } from '../../dataProvider';\nimport { useRedirect, RedirectionSideEffect } from '../../routing';\nimport { useNotify } from '../../notification';\nimport { SaveHandler } from '../saveContext';\nimport { useTranslate } from '../../i18n';\nimport { RaRecord, CreateParams, TransformData } from '../../types';\nimport {\n    useResourceContext,\n    useResourceDefinition,\n    useGetResourceLabel,\n} from '../../core';\n\n/**\n * Prepare data for the Create view\n *\n * @param {Object} props The props passed to the Create component.\n *\n * @return {Object} controllerProps Fetched data and callbacks for the Create view\n *\n * @example\n *\n * import { useCreateController } from 'react-admin';\n * import CreateView from './CreateView';\n *\n * const MyCreate = props => {\n *     const controllerProps = useCreateController(props);\n *     return <CreateView {...controllerProps} {...props} />;\n * }\n */\nexport const useCreateController = <RecordType extends RaRecord = RaRecord>(\n    props: CreateControllerProps<RecordType> = {}\n): CreateControllerResult<RecordType> => {\n    const {\n        disableAuthentication,\n        record,\n        redirect: redirectTo,\n        transform,\n        mutationOptions = {},\n    } = props;\n\n    useAuthenticated({ enabled: !disableAuthentication });\n    const resource = useResourceContext(props);\n    const { hasEdit, hasShow } = useResourceDefinition(props);\n    const finalRedirectTo =\n        redirectTo ?? getDefaultRedirectRoute(hasShow, hasEdit);\n    const location = useLocation();\n    const translate = useTranslate();\n    const notify = useNotify();\n    const redirect = useRedirect();\n    const recordToUse = record ?? getRecordFromLocation(location) ?? undefined;\n    const { onSuccess, onError, ...otherMutationOptions } = mutationOptions;\n\n    const [create, { isLoading: saving }] = useCreate<RecordType>(\n        resource,\n        undefined,\n        otherMutationOptions\n    );\n\n    const save = useCallback(\n        (\n            data: Partial<RecordType>,\n            {\n                onSuccess: onSuccessFromSave,\n                onError: onErrorFromSave,\n                transform: transformFromSave,\n            } = {}\n        ) =>\n            Promise.resolve(\n                transformFromSave\n                    ? transformFromSave(data)\n                    : transform\n                    ? transform(data)\n                    : data\n            ).then((data: Partial<RecordType>) =>\n                create(\n                    resource,\n                    { data },\n                    {\n                        onSuccess: onSuccessFromSave\n                            ? onSuccessFromSave\n                            : onSuccess\n                            ? onSuccess\n                            : newRecord => {\n                                  notify('ra.notification.created', {\n                                      type: 'info',\n                                      messageArgs: { smart_count: 1 },\n                                  });\n                                  redirect(\n                                      finalRedirectTo,\n                                      resource,\n                                      newRecord.id,\n                                      newRecord\n                                  );\n                              },\n                        onError: onErrorFromSave\n                            ? onErrorFromSave\n                            : onError\n                            ? onError\n                            : (error: Error) => {\n                                  notify(\n                                      typeof error === 'string'\n                                          ? error\n                                          : error.message ||\n                                                'ra.notification.http_error',\n                                      {\n                                          type: 'warning',\n                                          messageArgs: {\n                                              _:\n                                                  typeof error === 'string'\n                                                      ? error\n                                                      : error && error.message\n                                                      ? error.message\n                                                      : undefined,\n                                          },\n                                      }\n                                  );\n                              },\n                    }\n                )\n            ),\n        [\n            create,\n            finalRedirectTo,\n            notify,\n            onError,\n            onSuccess,\n            redirect,\n            resource,\n            transform,\n        ]\n    );\n\n    const getResourceLabel = useGetResourceLabel();\n    const defaultTitle = translate('ra.page.create', {\n        name: getResourceLabel(resource, 1),\n    });\n\n    return {\n        isFetching: false,\n        isLoading: false,\n        saving,\n        defaultTitle,\n        save,\n        resource,\n        record: recordToUse,\n        redirect: finalRedirectTo,\n    };\n};\n\nexport interface CreateControllerProps<RecordType extends RaRecord = RaRecord> {\n    disableAuthentication?: boolean;\n    record?: Partial<RecordType>;\n    redirect?: RedirectionSideEffect;\n    resource?: string;\n    mutationOptions?: UseMutationOptions<\n        RecordType,\n        unknown,\n        CreateParams<RecordType>\n    >;\n    transform?: TransformData;\n}\n\nexport interface CreateControllerResult<\n    RecordType extends RaRecord = RaRecord\n> {\n    // Necessary for actions (EditActions) which expect a data prop containing the record\n    // @deprecated - to be removed in 4.0d\n    data?: RecordType;\n    defaultTitle: string;\n    isFetching: boolean;\n    isLoading: boolean;\n    save: SaveHandler<RecordType>;\n    saving: boolean;\n    record?: Partial<RecordType>;\n    redirect: RedirectionSideEffect;\n    resource: string;\n}\n\n/**\n * Get the initial record from the location, whether it comes from the location\n * state or is serialized in the url search part.\n */\nexport const getRecordFromLocation = ({ state, search }: Location) => {\n    if (state && (state as StateWithRecord).record) {\n        return (state as StateWithRecord).record;\n    }\n    if (search) {\n        try {\n            const searchParams = parse(search);\n            if (searchParams.source) {\n                if (Array.isArray(searchParams.source)) {\n                    console.error(\n                        `Failed to parse location search parameter '${search}'. To pre-fill some fields in the Create form, pass a stringified source parameter (e.g. '?source={\"title\":\"foo\"}')`\n                    );\n                    return;\n                }\n                return JSON.parse(searchParams.source);\n            }\n        } catch (e) {\n            console.error(\n                `Failed to parse location search parameter '${search}'. To pre-fill some fields in the Create form, pass a stringified source parameter (e.g. '?source={\"title\":\"foo\"}')`\n            );\n        }\n    }\n    return null;\n};\n\ntype StateWithRecord = {\n    record?: Partial<RaRecord>;\n};\n\nconst getDefaultRedirectRoute = (hasShow, hasEdit) => {\n    if (hasEdit) {\n        return 'edit';\n    }\n    if (hasShow) {\n        return 'show';\n    }\n    return 'list';\n};\n","import * as React from 'react';\nimport { ReactNode } from 'react';\n\nimport { RaRecord } from '../../types';\nimport { RecordContextProvider } from '../record/RecordContext';\nimport { CreateContext } from './CreateContext';\nimport { CreateControllerResult } from './useCreateController';\nimport { SaveContextProvider, usePickSaveContext } from '../saveContext';\n\n/**\n * Create a Create Context.\n *\n * @example\n *\n * const MyCreate = (props) => {\n *     const controllerProps = useCreateController(props);\n *     return (\n *         <CreateContextProvider value={controllerProps}>\n *             <MyCreateView>\n *         </CreateContextProvider>\n *     );\n * };\n *\n * const MyCreateView = () => {\n *     const record = useRecordContext();\n *     // or, to rerender only when the save operation change but not data\n *     const { saving } = useCreateContext();\n * }\n *\n * @see CreateContext\n * @see RecordContext\n */\nexport const CreateContextProvider = ({\n    children,\n    value,\n}: {\n    children: ReactNode;\n    value: CreateControllerResult;\n}) => (\n    <CreateContext.Provider value={value}>\n        <SaveContextProvider\n            value={{\n                ...usePickSaveContext(value),\n                mutationMode: 'pessimistic',\n            }}\n        >\n            <RecordContextProvider<Partial<RaRecord>>\n                value={value && value.record}\n            >\n                {children}\n            </RecordContextProvider>\n        </SaveContextProvider>\n    </CreateContext.Provider>\n);\n","import * as React from 'react';\nimport { createContext, ReactNode } from 'react';\nimport { RaRecord } from '../../types';\n\n/**\n * Context to store a record.\n *\n * @see RecordContextProvider\n * @see useRecordContext\n */\nexport const RecordContext = createContext<RaRecord | Omit<RaRecord, 'id'>>(\n    undefined\n);\n\nRecordContext.displayName = 'RecordContext';\n\n/**\n * Provider for the Record Context, to store a record.\n *\n * Use the useRecordContext() hook to read the context.\n * That's what the Edit and Show components do in react-admin.\n *\n * Many react-admin components read the RecordContext, including all Field\n * components.\n *\n * @example\n *\n * import { useGetOne, RecordContextProvider } from 'ra-core';\n *\n * const Show = ({ resource, id }) => {\n *     const { data } = useGetOne(resource, { id });\n *     return (\n *         <RecordContextProvider value={data}>\n *             ...\n *         </RecordContextProvider>\n *     );\n * };\n */\nexport const RecordContextProvider = <\n    RecordType extends RaRecord | Omit<RaRecord, 'id'> = RaRecord\n>({\n    children,\n    value,\n}: RecordContextProviderProps<RecordType>) => (\n    <RecordContext.Provider value={value}>{children}</RecordContext.Provider>\n);\n\nexport interface RecordContextProviderProps<RecordType> {\n    children: ReactNode;\n    value?: RecordType;\n}\n","import { createContext } from 'react';\nimport { CreateControllerResult } from './useCreateController';\n\n/**\n * Context to store the result of the useCreateController() hook.\n *\n * Use the useCreateContext() hook to read the context. That's what the Create components do in react-admin.\n *\n * @example\n *\n * import { useCreateController, CreateContextProvider } from 'ra-core';\n *\n * const Create = props => {\n *     const controllerProps = useCreateController(props);\n *     return (\n *         <CreateContextProvider value={controllerProps}>\n *             ...\n *         </CreateContextProvider>\n *     );\n * };\n */\nexport const CreateContext = createContext<CreateControllerResult>({\n    record: null,\n    defaultTitle: null,\n    isFetching: null,\n    isLoading: null,\n    redirect: null,\n    resource: null,\n    save: null,\n    saving: null,\n});\n\nCreateContext.displayName = 'CreateContext';\n","import { createContext } from 'react';\nimport {\n    RaRecord,\n    onError,\n    OnSuccess,\n    TransformData,\n    MutationMode,\n} from '../../types';\n\nexport interface SaveContextValue<RecordType extends RaRecord = any> {\n    save?: SaveHandler<RecordType>;\n    saving?: boolean;\n    mutationMode?: MutationMode;\n}\n\nexport type SaveHandler<RecordType> = (\n    record: Partial<RecordType>,\n    callbacks?: {\n        onSuccess?: OnSuccess;\n        onError?: onError;\n        transform?: TransformData;\n    }\n) => Promise<void | RecordType> | Record<string, string>;\n\nexport const SaveContext = createContext<SaveContextValue>(undefined);\n","import * as React from 'react';\nimport { SaveContext } from './SaveContext';\n\nexport const SaveContextProvider = ({ children, value }) => (\n    <SaveContext.Provider value={value}>{children}</SaveContext.Provider>\n);\n","import { useMemo } from 'react';\nimport pick from 'lodash/pick';\nimport { SaveContextValue } from './SaveContext';\n\n/**\n * This hook extracts the `save`, `saving` and mutationMode properties from either the `CreateContext` or `EditContext`. This ensures the `SaveContext` doesn't rerender when those two contexts have other properties changes.\n */\nexport const usePickSaveContext = <\n    ContextType extends SaveContextValue = SaveContextValue\n>(\n    context: ContextType\n): SaveContextValue => {\n    const value = useMemo(\n        () => pick(context, ['save', 'saving', 'mutationMode']),\n        /* eslint-disable react-hooks/exhaustive-deps */\n        [context.save, context.saving, context.mutationMode]\n        /* eslint-enable react-hooks/exhaustive-deps */\n    );\n\n    return value;\n};\n","import { useContext } from 'react';\nimport { SaveContext, SaveContextValue } from './SaveContext';\n/**\n * Get the save() function and its status\n *\n * Used in forms.\n *\n * @example\n *\n * const {\n *     save,\n *     saving\n * } = useSaveContext();\n */\nexport const useSaveContext = <\n    PropsType extends SaveContextValue = SaveContextValue\n>(\n    props?: PropsType\n): SaveContextValue => {\n    return useContext(SaveContext);\n};\n","import {\n    useCreateController,\n    CreateControllerProps,\n    CreateControllerResult,\n} from './useCreateController';\n\n/**\n * Render prop version of the useCreateController hook\n *\n * @see useCreateController\n * @example\n *\n * const CreateView = () => <div>...</div>\n * const MyCreate = props => (\n *     <CreateController {...props}>\n *         {controllerProps => <CreateView {...controllerProps} {...props} />}\n *     </CreateController>\n * );\n */\nexport const CreateController = ({\n    children,\n    ...props\n}: {\n    children: (params: CreateControllerResult) => JSX.Element;\n} & CreateControllerProps) => {\n    const controllerProps = useCreateController(props);\n    return children(controllerProps);\n};\n","import { useContext, useMemo } from 'react';\nimport defaults from 'lodash/defaults';\n\nimport { RaRecord } from '../../types';\nimport { CreateContext } from './CreateContext';\nimport { CreateControllerResult } from './useCreateController';\n\n/**\n * Hook to read the create controller props from the CreateContext.\n *\n * Mostly used within a <CreateContext.Provider> (e.g. as a descendent of <Create>).\n *\n * But you can also use it without a <CreateContext.Provider>. In this case, it is up to you\n * to pass all the necessary props.\n *\n * The given props will take precedence over context values.\n *\n * @typedef {Object} CreateControllerProps\n *\n * @returns {CreateControllerResult} create controller props\n *\n * @see useCreateController for how it is filled\n *\n */\nexport const useCreateContext = <RecordType extends RaRecord = RaRecord>(\n    props?: Partial<CreateControllerResult<RecordType>>\n): Partial<CreateControllerResult<RecordType>> => {\n    const context = useContext<CreateControllerResult<RecordType>>(\n        // Can't find a way to specify the RecordType when CreateContext is declared\n        // @ts-ignore\n        CreateContext\n    );\n    // Props take precedence over the context\n    return useMemo(\n        () =>\n            defaults(\n                {},\n                props != null ? extractCreateContextProps(props) : {},\n                context\n            ),\n        [context, props]\n    );\n};\n\n/**\n * Extract only the create controller props\n *\n * @param {Object} props props passed to the useCreateContext hook\n *\n * @returns {CreateControllerResult} create controller props\n */\nconst extractCreateContextProps = ({\n    record,\n    defaultTitle,\n    isFetching,\n    isLoading,\n    redirect,\n    resource,\n    save,\n    saving,\n}: any) => ({\n    record,\n    defaultTitle,\n    isFetching,\n    isLoading,\n    redirect,\n    resource,\n    save,\n    saving,\n});\n","import * as React from 'react';\nimport { ReactNode } from 'react';\n\nimport { RaRecord } from '../../types';\nimport { useEditController, EditControllerProps } from './useEditController';\nimport { EditContextProvider } from './EditContextProvider';\n\n/**\n * Call useEditController and put the value in a EditContext\n *\n * Base class for <Edit> components, without UI.\n *\n * Accepts any props accepted by useEditController:\n * - id: The record identifier\n * - resource: The resource\n *\n * @example // Custom edit layout\n *\n * const PostEdit = () => (\n *     <EditBase resource=\"posts\">\n *         <Grid container>\n *             <Grid item xs={8}>\n *                 <SimpleForm>\n *                     ...\n *                 </SimpleForm>\n *             </Grid>\n *             <Grid item xs={4}>\n *                 Edit instructions...\n *             </Grid>\n *         </Grid>\n *         <div>\n *             Post related links...\n *         </div>\n *     </EditBase>\n * );\n */\nexport const EditBase = <RecordType extends RaRecord = any>({\n    children,\n    ...props\n}: { children: ReactNode } & EditControllerProps<RecordType>) => (\n    <EditContextProvider value={useEditController<RecordType>(props)}>\n        {children}\n    </EditContextProvider>\n);\n","import { useCallback } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { UseQueryOptions, UseMutationOptions } from 'react-query';\n\nimport { useAuthenticated } from '../../auth';\nimport {\n    RaRecord,\n    MutationMode,\n    TransformData,\n    UpdateParams,\n} from '../../types';\nimport { useRedirect, RedirectionSideEffect } from '../../routing';\nimport { useNotify } from '../../notification';\nimport {\n    useGetOne,\n    useUpdate,\n    useRefresh,\n    UseGetOneHookValue,\n} from '../../dataProvider';\nimport { useTranslate } from '../../i18n';\nimport { useResourceContext, useGetResourceLabel } from '../../core';\nimport { SaveHandler } from '../saveContext';\n\n/**\n * Prepare data for the Edit view.\n *\n * useEditController does a few things:\n * - it grabs the id from the URL and the resource name from the ResourceContext,\n * - it fetches the record via useGetOne,\n * - it prepares the page title.\n *\n * @param {Object} props The props passed to the Edit component.\n *\n * @return {Object} controllerProps Fetched data and callbacks for the Edit view\n *\n * @example\n *\n * import { useEditController } from 'react-admin';\n * import EditView from './EditView';\n *\n * const MyEdit = () => {\n *     const controllerProps = useEditController({ resource: 'posts', id: 123 });\n *     return <EditView {...controllerProps} {...props} />;\n * }\n */\nexport const useEditController = <RecordType extends RaRecord = any>(\n    props: EditControllerProps<RecordType> = {}\n): EditControllerResult<RecordType> => {\n    const {\n        disableAuthentication,\n        id: propsId,\n        mutationMode = 'undoable',\n        mutationOptions = {},\n        queryOptions = {},\n        redirect: redirectTo = DefaultRedirect,\n        transform,\n    } = props;\n    useAuthenticated({ enabled: !disableAuthentication });\n    const resource = useResourceContext(props);\n    const translate = useTranslate();\n    const notify = useNotify();\n    const redirect = useRedirect();\n    const refresh = useRefresh();\n    const { id: routeId } = useParams<'id'>();\n    const id = propsId || decodeURIComponent(routeId);\n    const { onSuccess, onError, ...otherMutationOptions } = mutationOptions;\n\n    const { data: record, error, isLoading, isFetching, refetch } = useGetOne<\n        RecordType\n    >(\n        resource,\n        { id },\n        {\n            onError: () => {\n                notify('ra.notification.item_doesnt_exist', {\n                    type: 'warning',\n                });\n                redirect('list', resource);\n                refresh();\n            },\n            refetchOnReconnect: false,\n            refetchOnWindowFocus: false,\n            retry: false,\n            ...queryOptions,\n        }\n    );\n\n    // eslint-disable-next-line eqeqeq\n    if (record && record.id && record.id != id) {\n        throw new Error(\n            `useEditController: Fetched record's id attribute (${record.id}) must match the requested 'id' (${id})`\n        );\n    }\n\n    const getResourceLabel = useGetResourceLabel();\n    const defaultTitle = translate('ra.page.edit', {\n        name: getResourceLabel(resource, 1),\n        id,\n        record,\n    });\n\n    const recordCached = { id, previousData: record };\n\n    const [update, { isLoading: saving }] = useUpdate<RecordType>(\n        resource,\n        recordCached,\n        { ...otherMutationOptions, mutationMode }\n    );\n\n    const save = useCallback(\n        (\n            data: Partial<RecordType>,\n            {\n                onSuccess: onSuccessFromSave,\n                onError: onErrorFromSave,\n                transform: transformFromSave,\n            } = {}\n        ) =>\n            Promise.resolve(\n                transformFromSave\n                    ? transformFromSave(data, {\n                          previousData: recordCached.previousData,\n                      })\n                    : transform\n                    ? transform(data, {\n                          previousData: recordCached.previousData,\n                      })\n                    : data\n            ).then((data: Partial<RecordType>) =>\n                update(\n                    resource,\n                    { data },\n                    {\n                        onSuccess: onSuccessFromSave\n                            ? onSuccessFromSave\n                            : onSuccess\n                            ? onSuccess\n                            : () => {\n                                  notify('ra.notification.updated', {\n                                      type: 'info',\n                                      messageArgs: { smart_count: 1 },\n                                      undoable: mutationMode === 'undoable',\n                                  });\n                                  redirect(redirectTo, resource, data.id, data);\n                              },\n                        onError: onErrorFromSave\n                            ? onErrorFromSave\n                            : onError\n                            ? onError\n                            : (error: Error | string) => {\n                                  notify(\n                                      typeof error === 'string'\n                                          ? error\n                                          : error.message ||\n                                                'ra.notification.http_error',\n                                      {\n                                          type: 'warning',\n                                          messageArgs: {\n                                              _:\n                                                  typeof error === 'string'\n                                                      ? error\n                                                      : error && error.message\n                                                      ? error.message\n                                                      : undefined,\n                                          },\n                                      }\n                                  );\n                              },\n                    }\n                )\n            ),\n        [\n            mutationMode,\n            notify,\n            onError,\n            onSuccess,\n            redirect,\n            redirectTo,\n            resource,\n            transform,\n            update,\n            recordCached.previousData,\n        ]\n    );\n\n    return {\n        defaultTitle,\n        error,\n        isFetching,\n        isLoading,\n        mutationMode,\n        record,\n        redirect: DefaultRedirect,\n        refetch,\n        resource,\n        save,\n        saving,\n    };\n};\n\nexport interface EditControllerProps<RecordType extends RaRecord = any> {\n    disableAuthentication?: boolean;\n    id?: RecordType['id'];\n    mutationMode?: MutationMode;\n    mutationOptions?: UseMutationOptions<\n        RecordType,\n        unknown,\n        UpdateParams<RecordType>\n    >;\n    queryOptions?: UseQueryOptions<RecordType>;\n    redirect?: RedirectionSideEffect;\n    resource?: string;\n    transform?: TransformData;\n    [key: string]: any;\n}\n\nexport interface EditControllerResult<RecordType extends RaRecord = any> {\n    // Necessary for actions (EditActions) which expect a data prop containing the record\n    // @deprecated - to be removed in 4.0d\n    data?: RecordType;\n    error?: any;\n    defaultTitle: string;\n    isFetching: boolean;\n    isLoading: boolean;\n    mutationMode?: MutationMode;\n    save: SaveHandler<RecordType>;\n    saving: boolean;\n    record?: RecordType;\n    refetch: UseGetOneHookValue<RecordType>['refetch'];\n    redirect: RedirectionSideEffect;\n    resource: string;\n}\n\nconst DefaultRedirect = 'list';\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { RaRecord } from '../../types';\nimport { RecordContextProvider } from '../record';\nimport { SaveContextProvider, usePickSaveContext } from '../saveContext';\nimport { EditContext } from './EditContext';\nimport { EditControllerResult } from './useEditController';\n\n/**\n * Create an Edit Context.\n *\n * @example\n *\n * const MyEdit = (props) => {\n *     const controllerProps = useEditController(props);\n *     return (\n *         <EditContextProvider value={controllerProps}>\n *             <MyEditView>\n *         </EditContextProvider>\n *     );\n * };\n *\n * const MyEditView = () => {\n *     const record = useRecordContext();\n *     // or, to rerender only when the save operation change but not data\n *     const { saving } = useEditContext();\n * }\n *\n * @see EditContext\n * @see RecordContext\n */\nexport const EditContextProvider = ({\n    children,\n    value,\n}: {\n    children: ReactNode;\n    value: EditControllerResult;\n}) => (\n    <EditContext.Provider value={value}>\n        <SaveContextProvider value={usePickSaveContext(value)}>\n            <RecordContextProvider<Partial<RaRecord>>\n                value={value && value.record}\n            >\n                {children}\n            </RecordContextProvider>\n        </SaveContextProvider>\n    </EditContext.Provider>\n);\n","import { useContext } from 'react';\nimport { RaRecord } from '../../types';\nimport { RecordContext } from './RecordContext';\n\n/**\n * Hook to read the record from a RecordContext.\n *\n * Must be used within a <RecordContext> such as provided by the <EditContextProvider>\n * (e.g. as a descendent of <Edit> or <EditBase>) or within a <ShowContextProvider>\n * (e.g. as a descendent of <Show> or <ShowBase>)\n *\n * @example // basic usage\n *\n * import { useRecordContext } from 'ra-core';\n *\n * const TitleField = () => {\n *     const record = useRecordContext();\n *     return <span>{record && record.title}</span>;\n * };\n *\n * @example // allow record override via props\n *\n * import { useRecordContext } from 'ra-core';\n *\n * const TitleField = (props) => {\n *     const record = useRecordContext(props);\n *     return <span>{record && record.title}</span>;\n * };\n * render(<TextField record={record} />);\n *\n * @returns {RaRecord} A record object\n */\nexport const useRecordContext = <\n    RecordType extends RaRecord | Omit<RaRecord, 'id'> = RaRecord\n>(\n    props?: UseRecordContextParams<RecordType>\n): RecordType | undefined => {\n    // Can't find a way to specify the RecordType when CreateContext is declared\n    // @ts-ignore\n    const context = useContext<RecordType>(RecordContext);\n\n    return (props && props.record) || context;\n};\n\nexport interface UseRecordContextParams<\n    RecordType extends RaRecord | Omit<RaRecord, 'id'> = RaRecord\n> {\n    record?: RecordType;\n    [key: string]: any;\n}\n","import { ReactElement } from 'react';\nimport { RaRecord } from '../../types';\nimport { useRecordContext } from './useRecordContext';\n\n/**\n * Render prop version of useRecordContext\n *\n * @example\n * const BookShow = () => (\n *    <Show>\n *       <SimpleShowLayout>\n *          <WithRecord render={record => <span>{record.title}</span>} />\n *      </SimpleShowLayout>\n *   </Show>\n * );\n */\nexport const WithRecord = <RecordType extends RaRecord>({\n    render,\n}: WithRecordProps<RecordType>) => {\n    const record = useRecordContext<RecordType>();\n    return record ? render(record) : null;\n};\n\nexport interface WithRecordProps<RecordType extends RaRecord> {\n    render: (record: RecordType) => ReactElement;\n    label?: string;\n}\n","import * as React from 'react';\nimport { ReactElement } from 'react';\nimport { RaRecord } from '../../types';\nimport { RecordContextProvider } from './RecordContext';\n\n/**\n * Wrap children with a RecordContext provider only if the value is defined.\n *\n * Allows a component to work outside of a record context.\n *\n * @example\n *\n * import { OptionalRecordContextProvider, TextField } from 'react-admin';\n *\n * const RecordTitle = ({ record }) => (\n *     <OptionalRecordContextProvider value={record}>\n *         <TextField source=\"title\" />\n *     </OptionalRecordContextProvider>\n * );\n */\nexport const OptionalRecordContextProvider = <\n    RecordType extends RaRecord | Omit<RaRecord, 'id'> = RaRecord\n>({\n    value,\n    children,\n}: {\n    children: ReactElement;\n    value?: RecordType;\n}) =>\n    value ? (\n        <RecordContextProvider value={value}>{children}</RecordContextProvider>\n    ) : (\n        children\n    );\n","import { createContext } from 'react';\nimport { EditControllerResult } from './useEditController';\n\n/**\n * Context to store the result of the useEditController() hook.\n *\n * Use the useEditContext() hook to read the context. That's what the Edit components do in react-admin.\n *\n * @example\n *\n * import { useEditController, EditContextProvider } from 'ra-core';\n *\n * const Edit = props => {\n *     const controllerProps = useEditController(props);\n *     return (\n *         <EditContextProvider value={controllerProps}>\n *             ...\n *         </EditContextProvider>\n *     );\n * };\n */\nexport const EditContext = createContext<EditControllerResult>({\n    record: null,\n    defaultTitle: null,\n    isFetching: null,\n    isLoading: null,\n    mutationMode: null,\n    redirect: null,\n    refetch: null,\n    resource: null,\n    save: null,\n    saving: null,\n});\n\nEditContext.displayName = 'EditContext';\n","import {\n    useEditController,\n    EditControllerProps,\n    EditControllerResult,\n} from './useEditController';\n\n/**\n * Render prop version of the useEditController hook\n *\n * @see useEditController\n * @example\n *\n * const EditView = () => <div>...</div>\n * const MyEdit = props => (\n *     <EditController {...props}>\n *         {controllerProps => <EditView {...controllerProps} {...props} />}\n *     </EditController>\n * );\n */\nexport const EditController = ({\n    children,\n    ...props\n}: {\n    children: (params: EditControllerResult) => JSX.Element;\n} & EditControllerProps) => {\n    const controllerProps = useEditController(props);\n    return children(controllerProps);\n};\n","import { useContext, useMemo } from 'react';\nimport defaults from 'lodash/defaults';\n\nimport { RaRecord } from '../../types';\nimport { EditContext } from './EditContext';\nimport { EditControllerResult } from './useEditController';\n\n/**\n * Hook to read the edit controller props from the CreateContext.\n *\n * Mostly used within a <EditContext.Provider> (e.g. as a descendent of <Edit>).\n *\n * But you can also use it without a <EditContext.Provider>. In this case, it is up to you\n * to pass all the necessary props.\n *\n * The given props will take precedence over context values.\n *\n * @typedef {Object} EditControllerProps\n *\n * @returns {EditControllerResult} edit controller props\n *\n * @see useEditController for how it is filled\n *\n */\nexport const useEditContext = <RecordType extends RaRecord = any>(\n    props?: Partial<EditControllerResult<RecordType>>\n): Partial<EditControllerResult<RecordType>> => {\n    // Can't find a way to specify the RecordType when EditContext is declared\n    // @ts-ignore\n    const context = useContext<EditControllerResult<RecordType>>(EditContext);\n\n    // Props take precedence over the context\n    return useMemo(\n        () =>\n            defaults(\n                {},\n                props != null ? extractEditContextProps(props) : {},\n                context\n            ),\n        [context, props]\n    );\n};\n\n/**\n * Extract only the edit controller props\n *\n * @param {Object} props props passed to the useEditContext hook\n *\n * @returns {EditControllerResult} edit controller props\n */\nconst extractEditContextProps = ({\n    data,\n    record,\n    defaultTitle,\n    isFetching,\n    isLoading,\n    mutationMode,\n    redirect,\n    resource,\n    save,\n    saving,\n}: any) => ({\n    // Necessary for actions (EditActions) which expect a data prop containing the record\n    // @deprecated - to be removed in 4.0d\n    data: record || data,\n    record: record || data,\n    defaultTitle,\n    isFetching,\n    isLoading,\n    mutationMode,\n    redirect,\n    resource,\n    save,\n    saving,\n});\n","import get from 'lodash/get';\n\nimport { RaRecord, SortPayload } from '../../types';\nimport { useGetManyAggregate } from '../../dataProvider';\nimport { ListControllerResult, useList } from '../list';\nimport { useNotify } from '../../notification';\n\nexport interface UseReferenceArrayFieldControllerParams {\n    filter?: any;\n    page?: number;\n    perPage?: number;\n    record?: RaRecord;\n    reference: string;\n    resource: string;\n    sort?: SortPayload;\n    source: string;\n}\n\nconst emptyArray = [];\nconst defaultFilter = {};\nconst defaultSort = { field: null, order: null };\n\n/**\n * Hook that fetches records from another resource specified\n * by an array of *ids* in current record.\n *\n * @example\n *\n * const { data, error, isFetching, isLoading } = useReferenceArrayFieldController({\n *      record: { referenceIds: ['id1', 'id2']};\n *      reference: 'reference';\n *      resource: 'resource';\n *      source: 'referenceIds';\n * });\n *\n * @param {Object} props\n * @param {Object} props.record The current resource record\n * @param {string} props.reference The linked resource name\n * @param {string} props.resource The current resource name\n * @param {string} props.source The key of the linked resource identifier\n *\n * @param {Props} props\n *\n * @returns {ListControllerResult} The reference props\n */\nexport const useReferenceArrayFieldController = (\n    props: UseReferenceArrayFieldControllerParams\n): ListControllerResult => {\n    const {\n        filter = defaultFilter,\n        page = 1,\n        perPage = 1000,\n        record,\n        reference,\n        sort = defaultSort,\n        source,\n    } = props;\n    const notify = useNotify();\n    const ids = get(record, source) || emptyArray;\n    const { data, error, isLoading, isFetching, refetch } = useGetManyAggregate(\n        reference,\n        { ids },\n        {\n            onError: error =>\n                notify(\n                    typeof error === 'string'\n                        ? error\n                        : error.message || 'ra.notification.http_error',\n                    {\n                        type: 'warning',\n                        messageArgs: {\n                            _:\n                                typeof error === 'string'\n                                    ? error\n                                    : error && error.message\n                                    ? error.message\n                                    : undefined,\n                        },\n                    }\n                ),\n        }\n    );\n\n    const listProps = useList({\n        data,\n        error,\n        filter,\n        isFetching,\n        isLoading,\n        page,\n        perPage,\n        sort,\n    });\n\n    return {\n        ...listProps,\n        defaultTitle: null,\n        refetch,\n        resource: reference,\n    };\n};\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { useListController, ListControllerProps } from './useListController';\nimport { ResourceContextProvider } from '../../core';\nimport { RaRecord } from '../../types';\nimport { ListContextProvider } from './ListContextProvider';\n\n/**\n * Call useListController and put the value in a ListContext\n *\n * Base class for <List> components, without UI.\n *\n * Accepts any props accepted by useListController:\n * - filter: permanent filter applied to the list\n * - filters: Filter element, to display the filters\n * - filterDefaultValues: object;\n * - perPage: Number of results per page\n * - sort: Default sort\n * - exporter: exported function\n *\n * @example // Custom list layout\n *\n * const PostList = props => (\n *     <ListBase {...props} perPage={10}>\n *         <div>\n *              List metrics...\n *         </div>\n *         <Grid container>\n *             <Grid item xs={8}>\n *                 <SimpleList primaryText={record => record.title} />\n *             </Grid>\n *             <Grid item xs={4}>\n *                 List instructions...\n *             </Grid>\n *         </Grid>\n *         <div>\n *             Post related links...\n *         </div>\n *     </ListBase>\n * );\n */\nexport const ListBase = <RecordType extends RaRecord = any>({\n    children,\n    ...props\n}: ListControllerProps<RecordType> & { children: ReactNode }) => (\n    <ResourceContextProvider value={props.resource}>\n        <ListContextProvider value={useListController<RecordType>(props)}>\n            {children}\n        </ListContextProvider>\n    </ResourceContextProvider>\n);\n","import { isValidElement, useEffect, useMemo } from 'react';\nimport { UseQueryOptions } from 'react-query';\n\nimport { useAuthenticated } from '../../auth';\nimport { useTranslate } from '../../i18n';\nimport { useNotify } from '../../notification';\nimport { useGetList, UseGetListHookValue } from '../../dataProvider';\nimport { SORT_ASC } from './queryReducer';\nimport { defaultExporter } from '../../export';\nimport { FilterPayload, SortPayload, RaRecord, Exporter } from '../../types';\nimport { useResourceContext, useGetResourceLabel } from '../../core';\nimport { useRecordSelection } from './useRecordSelection';\nimport { useListParams } from './useListParams';\n\n/**\n * Prepare data for the List view\n *\n * @param {Object} props The props passed to the List component.\n *\n * @return {Object} controllerProps Fetched and computed data for the List view\n *\n * @example\n *\n * import { useListController } from 'react-admin';\n * import ListView from './ListView';\n *\n * const MyList = props => {\n *     const controllerProps = useListController(props);\n *     return <ListView {...controllerProps} {...props} />;\n * }\n */\nexport const useListController = <RecordType extends RaRecord = any>(\n    props: ListControllerProps<RecordType> = {}\n): ListControllerResult<RecordType> => {\n    const {\n        disableAuthentication,\n        exporter = defaultExporter,\n        filterDefaultValues,\n        sort = defaultSort,\n        perPage = 10,\n        filter,\n        debounce = 500,\n        disableSyncWithLocation,\n        queryOptions,\n    } = props;\n    useAuthenticated({ enabled: !disableAuthentication });\n    const resource = useResourceContext(props);\n\n    if (!resource) {\n        throw new Error(\n            `<List> was called outside of a ResourceContext and without a resource prop. You must set the resource prop.`\n        );\n    }\n    if (filter && isValidElement(filter)) {\n        throw new Error(\n            '<List> received a React element as `filter` props. If you intended to set the list filter elements, use the `filters` (with an s) prop instead. The `filter` prop is internal and should not be set by the developer.'\n        );\n    }\n\n    const translate = useTranslate();\n    const notify = useNotify();\n\n    const [query, queryModifiers] = useListParams({\n        resource,\n        filterDefaultValues,\n        sort,\n        perPage,\n        debounce,\n        disableSyncWithLocation,\n    });\n\n    const [selectedIds, selectionModifiers] = useRecordSelection(resource);\n\n    const {\n        data,\n        pageInfo,\n        total,\n        error,\n        isLoading,\n        isFetching,\n        refetch,\n    } = useGetList<RecordType>(\n        resource,\n        {\n            pagination: {\n                page: query.page,\n                perPage: query.perPage,\n            },\n            sort: { field: query.sort, order: query.order },\n            filter: { ...query.filter, ...filter },\n        },\n        {\n            keepPreviousData: true,\n            retry: false,\n            onError: error =>\n                notify(error?.message || 'ra.notification.http_error', {\n                    type: 'warning',\n                    messageArgs: {\n                        _: error?.message,\n                    },\n                }),\n            ...queryOptions,\n        }\n    );\n\n    // change page if there is no data\n    useEffect(() => {\n        if (\n            query.page <= 0 ||\n            (!isFetching && query.page > 1 && data.length === 0)\n        ) {\n            // Query for a page that doesn't exist, set page to 1\n            queryModifiers.setPage(1);\n            return;\n        }\n        if (total == null) {\n            return;\n        }\n        const totalPages = Math.ceil(total / query.perPage) || 1;\n        if (!isFetching && query.page > totalPages) {\n            // Query for a page out of bounds, set page to the last existing page\n            // It occurs when deleting the last element of the last page\n            queryModifiers.setPage(totalPages);\n        }\n    }, [isFetching, query.page, query.perPage, data, queryModifiers, total]);\n\n    const currentSort = useMemo(\n        () => ({\n            field: query.sort,\n            order: query.order,\n        }),\n        [query.sort, query.order]\n    );\n\n    const getResourceLabel = useGetResourceLabel();\n    const defaultTitle = translate('ra.page.list', {\n        name: getResourceLabel(resource, 2),\n    });\n\n    return {\n        sort: currentSort,\n        data,\n        defaultTitle,\n        displayedFilters: query.displayedFilters,\n        error,\n        exporter,\n        filter,\n        filterValues: query.filterValues,\n        hideFilter: queryModifiers.hideFilter,\n        isFetching,\n        isLoading,\n        onSelect: selectionModifiers.select,\n        onToggleItem: selectionModifiers.toggle,\n        onUnselectItems: selectionModifiers.clearSelection,\n        page: query.page,\n        perPage: query.perPage,\n        refetch,\n        resource,\n        selectedIds,\n        setFilters: queryModifiers.setFilters,\n        setPage: queryModifiers.setPage,\n        setPerPage: queryModifiers.setPerPage,\n        setSort: queryModifiers.setSort,\n        showFilter: queryModifiers.showFilter,\n        total: total,\n        hasNextPage: pageInfo\n            ? pageInfo.hasNextPage\n            : total != null\n            ? query.page * query.perPage < total\n            : undefined,\n        hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : query.page > 1,\n    };\n};\n\nexport interface ListControllerProps<RecordType extends RaRecord = any> {\n    debounce?: number;\n    disableAuthentication?: boolean;\n    /**\n     * Whether to disable the synchronization of the list parameters with the current location (URL search parameters)\n     */\n    disableSyncWithLocation?: boolean;\n    exporter?: Exporter | false;\n    filter?: FilterPayload;\n    filterDefaultValues?: object;\n    perPage?: number;\n    queryOptions?: UseQueryOptions<{\n        data: RecordType[];\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    }>;\n    resource?: string;\n    sort?: SortPayload;\n}\n\nconst defaultSort = {\n    field: 'id',\n    order: SORT_ASC,\n};\n\nexport interface ListControllerResult<RecordType extends RaRecord = any> {\n    sort: SortPayload;\n    data: RecordType[];\n    defaultTitle?: string;\n    displayedFilters: any;\n    error?: any;\n    exporter?: Exporter | false;\n    filter?: FilterPayload;\n    filterValues: any;\n    hideFilter: (filterName: string) => void;\n    isFetching: boolean;\n    isLoading: boolean;\n    onSelect: (ids: RecordType['id'][]) => void;\n    onToggleItem: (id: RecordType['id']) => void;\n    onUnselectItems: () => void;\n    page: number;\n    perPage: number;\n    refetch: UseGetListHookValue<RecordType>['refetch'];\n    resource: string;\n    selectedIds: RecordType['id'][];\n    setFilters: (\n        filters: any,\n        displayedFilters: any,\n        debounce?: boolean\n    ) => void;\n    setPage: (page: number) => void;\n    setPerPage: (page: number) => void;\n    setSort: (sort: SortPayload) => void;\n    showFilter: (filterName: string, defaultValue: any) => void;\n    total: number;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n}\n\nexport const injectedProps = [\n    'sort',\n    'data',\n    'defaultTitle',\n    'displayedFilters',\n    'error',\n    'exporter',\n    'filterValues',\n    'hideFilter',\n    'isFetching',\n    'isLoading',\n    'onSelect',\n    'onToggleItem',\n    'onUnselectItems',\n    'page',\n    'perPage',\n    'refetch',\n    'refresh',\n    'resource',\n    'selectedIds',\n    'setFilters',\n    'setPage',\n    'setPerPage',\n    'setSort',\n    'showFilter',\n    'total',\n    'totalPages',\n];\n\n/**\n * Select the props injected by the useListController hook\n * to be passed to the List children need\n * This is an implementation of pick()\n */\nexport const getListControllerProps = props =>\n    injectedProps.reduce((acc, key) => ({ ...acc, [key]: props[key] }), {});\n\n/**\n * Select the props not injected by the useListController hook\n * to be used inside the List children to sanitize props injected by List\n * This is an implementation of omit()\n */\nexport const sanitizeListRestProps = props =>\n    Object.keys(props)\n        .filter(propName => !injectedProps.includes(propName))\n        .reduce((acc, key) => ({ ...acc, [key]: props[key] }), {});\n","import { useMemo } from 'react';\n\nimport { useStore, useRemoveFromStore } from '../../store';\nimport { Identifier } from '../../types';\n\n/**\n * Get the list of selected items for a resource, and callbacks to change the selection\n *\n * @param resource The resource name, e.g. 'posts'\n *\n * @returns {Object} Destructure as [selectedIds, { select, toggle, clearSelection }].\n */\nexport const useRecordSelection = (\n    resource: string\n): [\n    Identifier[],\n    {\n        select: (ids: Identifier[]) => void;\n        unselect: (ids: Identifier[]) => void;\n        toggle: (id: Identifier) => void;\n        clearSelection: () => void;\n    }\n] => {\n    const storeKey = `${resource}.selectedIds`;\n    const [ids, setIds] = useStore(storeKey, defaultSelection);\n    const reset = useRemoveFromStore(storeKey);\n\n    const selectionModifiers = useMemo(\n        () => ({\n            select: (idsToAdd: Identifier[]) => {\n                if (!idsToAdd) return;\n                setIds([...idsToAdd]);\n            },\n            unselect(idsToRemove: Identifier[]) {\n                if (!idsToRemove || idsToRemove.length === 0) return;\n                setIds(ids => {\n                    if (!Array.isArray(ids)) return [];\n                    return ids.filter(id => !idsToRemove.includes(id));\n                });\n            },\n            toggle: (id: Identifier) => {\n                if (typeof id === 'undefined') return;\n                setIds(ids => {\n                    if (!Array.isArray(ids)) return [...ids];\n                    const index = ids.indexOf(id);\n                    return index > -1\n                        ? [...ids.slice(0, index), ...ids.slice(index + 1)]\n                        : [...ids, id];\n                });\n            },\n            clearSelection: () => {\n                reset();\n            },\n        }),\n        [setIds, reset]\n    );\n\n    return [ids, selectionModifiers];\n};\n\nconst defaultSelection = [];\n","import { useCallback, useMemo, useEffect, useState, useRef } from 'react';\nimport { parse, stringify } from 'query-string';\nimport lodashDebounce from 'lodash/debounce';\nimport pickBy from 'lodash/pickBy';\nimport { useNavigate, useLocation } from 'react-router-dom';\n\nimport { useStore } from '../../store';\nimport queryReducer, {\n    SET_FILTER,\n    HIDE_FILTER,\n    SHOW_FILTER,\n    SET_PAGE,\n    SET_PER_PAGE,\n    SET_SORT,\n    SORT_ASC,\n} from './queryReducer';\nimport { SortPayload, FilterPayload } from '../../types';\nimport removeEmpty from '../../util/removeEmpty';\nimport { useIsMounted } from '../../util/hooks';\n\nexport interface ListParams {\n    sort: string;\n    order: string;\n    page: number;\n    perPage: number;\n    filter: any;\n    displayedFilters: any;\n}\n\n/**\n * Get the list parameters (page, sort, filters) and modifiers.\n *\n * These parameters are merged from 3 sources:\n *   - the query string from the URL\n *   - the params stored in the state (from previous navigation)\n *   - the options passed to the hook (including the filter defaultValues)\n *\n * @returns {Array} A tuple [parameters, modifiers].\n * Destructure as [\n *    { page, perPage, sort, order, filter, filterValues, displayedFilters, requestSignature },\n *    { setFilters, hideFilter, showFilter, setPage, setPerPage, setSort }\n * ]\n *\n * @example\n *\n * const [listParams, listParamsActions] = useListParams({\n *      resource: 'posts',\n *      location: location // From react-router. Injected to your component by react-admin inside a List\n *      filterDefaultValues: {\n *          published: true\n *      },\n *      sort: {\n *          field: 'published_at',\n *          order: 'DESC'\n *      },\n *      perPage: 25\n * });\n *\n * const {\n *      page,\n *      perPage,\n *      sort,\n *      order,\n *      filter,\n *      filterValues,\n *      displayedFilters,\n *      requestSignature\n * } = listParams;\n *\n * const {\n *      setFilters,\n *      hideFilter,\n *      showFilter,\n *      setPage,\n *      setPerPage,\n *      setSort,\n * } = listParamsActions;\n */\nexport const useListParams = ({\n    resource,\n    filterDefaultValues,\n    sort = defaultSort,\n    perPage = 10,\n    debounce = 500,\n    disableSyncWithLocation = false,\n}: ListParamsOptions): [Parameters, Modifiers] => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const [localParams, setLocalParams] = useState(defaultParams);\n    const storeKey = `${resource}.listParams`;\n    const [params, setParams] = useStore(storeKey, defaultParams);\n    const tempParams = useRef<ListParams>();\n    const isMounted = useIsMounted();\n\n    const requestSignature = [\n        location.search,\n        resource,\n        JSON.stringify(disableSyncWithLocation ? localParams : params),\n        JSON.stringify(filterDefaultValues),\n        JSON.stringify(sort),\n        perPage,\n        disableSyncWithLocation,\n    ];\n\n    const queryFromLocation = disableSyncWithLocation\n        ? {}\n        : parseQueryFromLocation(location);\n\n    const query = useMemo(\n        () =>\n            getQuery({\n                queryFromLocation,\n                params: disableSyncWithLocation ? localParams : params,\n                filterDefaultValues,\n                sort,\n                perPage,\n            }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    // if the location includes params (for example from a link like\n    // the categories products on the demo), we need to persist them in the\n    // store as well so that we don't lose them after a redirection back\n    // to the list\n    useEffect(() => {\n        if (Object.keys(queryFromLocation).length > 0) {\n            setParams(query);\n        }\n    }, [location.search]); // eslint-disable-line\n\n    const changeParams = useCallback(action => {\n        // do not change params if the component is already unmounted\n        // this is necessary because changeParams can be debounced, and therefore\n        // executed after the component is unmounted\n        if (!isMounted.current) return;\n\n        if (!tempParams.current) {\n            // no other changeParams action dispatched this tick\n            tempParams.current = queryReducer(query, action);\n            // schedule side effects for next tick\n            setTimeout(() => {\n                if (disableSyncWithLocation) {\n                    setLocalParams(tempParams.current);\n                } else {\n                    // the useEffect above will apply the changes to the params in the store\n                    navigate(\n                        {\n                            search: `?${stringify({\n                                ...tempParams.current,\n                                filter: JSON.stringify(\n                                    tempParams.current.filter\n                                ),\n                                displayedFilters: JSON.stringify(\n                                    tempParams.current.displayedFilters\n                                ),\n                            })}`,\n                        },\n                        {\n                            state: { _scrollToTop: action.type === SET_PAGE },\n                        }\n                    );\n                }\n                tempParams.current = undefined;\n            }, 0);\n        } else {\n            // side effects already scheduled, just change the params\n            tempParams.current = queryReducer(tempParams.current, action);\n        }\n    }, requestSignature); // eslint-disable-line react-hooks/exhaustive-deps\n\n    const setSort = useCallback(\n        (sort: SortPayload) =>\n            changeParams({\n                type: SET_SORT,\n                payload: sort,\n            }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const setPage = useCallback(\n        (newPage: number) => changeParams({ type: SET_PAGE, payload: newPage }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const setPerPage = useCallback(\n        (newPerPage: number) =>\n            changeParams({ type: SET_PER_PAGE, payload: newPerPage }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const filterValues = query.filter || emptyObject;\n    const displayedFilterValues = query.displayedFilters || emptyObject;\n\n    const debouncedSetFilters = lodashDebounce((filter, displayedFilters) => {\n        changeParams({\n            type: SET_FILTER,\n            payload: {\n                filter: removeEmpty(filter),\n                displayedFilters,\n            },\n        });\n    }, debounce);\n\n    const setFilters = useCallback(\n        (filter, displayedFilters, debounce = true) =>\n            debounce\n                ? debouncedSetFilters(filter, displayedFilters)\n                : changeParams({\n                      type: SET_FILTER,\n                      payload: {\n                          filter: removeEmpty(filter),\n                          displayedFilters,\n                      },\n                  }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const hideFilter = useCallback((filterName: string) => {\n        changeParams({\n            type: HIDE_FILTER,\n            payload: filterName,\n        });\n    }, requestSignature); // eslint-disable-line react-hooks/exhaustive-deps\n\n    const showFilter = useCallback((filterName: string, defaultValue: any) => {\n        changeParams({\n            type: SHOW_FILTER,\n            payload: {\n                filterName,\n                defaultValue,\n            },\n        });\n    }, requestSignature); // eslint-disable-line react-hooks/exhaustive-deps\n\n    return [\n        {\n            displayedFilters: displayedFilterValues,\n            filterValues,\n            requestSignature,\n            ...query,\n        },\n        {\n            changeParams,\n            setPage,\n            setPerPage,\n            setSort,\n            setFilters,\n            hideFilter,\n            showFilter,\n        },\n    ];\n};\n\nexport const validQueryParams = [\n    'page',\n    'perPage',\n    'sort',\n    'order',\n    'filter',\n    'displayedFilters',\n];\n\nconst parseObject = (query, field) => {\n    if (query[field] && typeof query[field] === 'string') {\n        try {\n            query[field] = JSON.parse(query[field]);\n        } catch (err) {\n            delete query[field];\n        }\n    }\n};\n\nexport const parseQueryFromLocation = ({ search }): Partial<ListParams> => {\n    const query = pickBy(\n        parse(search),\n        (v, k) => validQueryParams.indexOf(k) !== -1\n    );\n    parseObject(query, 'filter');\n    parseObject(query, 'displayedFilters');\n    return query;\n};\n\n/**\n * Check if user has already set custom sort, page, or filters for this list\n *\n * User params come from the store as the params props. By default,\n * this object is:\n *\n * { filter: {}, order: null, page: 1, perPage: null, sort: null }\n *\n * To check if the user has custom params, we must compare the params\n * to these initial values.\n *\n * @param {Object} params\n */\nexport const hasCustomParams = (params: ListParams) => {\n    return (\n        params &&\n        params.filter &&\n        (Object.keys(params.filter).length > 0 ||\n            params.order != null ||\n            params.page !== 1 ||\n            params.perPage != null ||\n            params.sort != null)\n    );\n};\n\n/**\n * Merge list params from 3 different sources:\n *   - the query string\n *   - the params stored in the state (from previous navigation)\n *   - the props passed to the List component (including the filter defaultValues)\n */\nexport const getQuery = ({\n    queryFromLocation,\n    params,\n    filterDefaultValues,\n    sort,\n    perPage,\n}) => {\n    const query: Partial<ListParams> =\n        Object.keys(queryFromLocation).length > 0\n            ? queryFromLocation\n            : hasCustomParams(params)\n            ? { ...params }\n            : { filter: filterDefaultValues || {} };\n\n    if (!query.sort) {\n        query.sort = sort.field;\n        query.order = sort.order;\n    }\n    if (query.perPage == null) {\n        query.perPage = perPage;\n    }\n    if (query.page == null) {\n        query.page = 1;\n    }\n\n    return {\n        ...query,\n        page: getNumberOrDefault(query.page, 1),\n        perPage: getNumberOrDefault(query.perPage, 10),\n    } as ListParams;\n};\n\nexport const getNumberOrDefault = (\n    possibleNumber: string | number | undefined,\n    defaultValue: number\n) => {\n    const parsedNumber =\n        typeof possibleNumber === 'string'\n            ? parseInt(possibleNumber, 10)\n            : possibleNumber;\n\n    return isNaN(parsedNumber) ? defaultValue : parsedNumber;\n};\n\nexport interface ListParamsOptions {\n    resource: string;\n    perPage?: number;\n    sort?: SortPayload;\n    // default value for a filter when displayed but not yet set\n    filterDefaultValues?: FilterPayload;\n    debounce?: number;\n    // Whether to disable the synchronization of the list parameters with\n    // the current location (URL search parameters)\n    disableSyncWithLocation?: boolean;\n}\n\ninterface Parameters extends ListParams {\n    filterValues: object;\n    displayedFilters: {\n        [key: string]: boolean;\n    };\n    requestSignature: any[];\n}\n\ninterface Modifiers {\n    changeParams: (action: any) => void;\n    setPage: (page: number) => void;\n    setPerPage: (pageSize: number) => void;\n    setSort: (sort: SortPayload) => void;\n    setFilters: (filters: any, displayedFilters: any) => void;\n    hideFilter: (filterName: string) => void;\n    showFilter: (filterName: string, defaultValue: any) => void;\n}\n\nconst emptyObject = {};\n\nconst defaultSort = {\n    field: 'id',\n    order: SORT_ASC,\n};\n\nconst defaultParams = {};\n","import * as React from 'react';\nimport { ListContext } from './ListContext';\nimport { ListFilterContext, usePickFilterContext } from './ListFilterContext';\nimport { ListSortContext, usePickSortContext } from './ListSortContext';\nimport {\n    ListPaginationContext,\n    usePickPaginationContext,\n} from './ListPaginationContext';\n\n/**\n * Create a List Context and several thematic List subcontext.\n *\n * Allows children to subscribe to part of the ListContext, and bail out of\n * rendering when some parts of the context that they don't depend on change\n * (because unfortunately React doesn't allow to use context selectors yet).\n *\n * @example\n *\n * const MyList = (props) => {\n *     const controllerProps = useListController(props);\n *     return (\n *         <ListContextProvider value={controllerProps}>\n *             <MyListView>\n *         </ListContextProvider>\n *     );\n * };\n *\n * const MyListView = () => {\n *     const { data, filterValues, setFilters } = useListContext();\n *     // or, to rerender only when filters change but not data\n *     const { filterValues, setFilters } = useListFilterContext();\n * }\n *\n * @see ListContext\n * @see ListFilterContext\n */\nexport const ListContextProvider = ({ value, children }) => (\n    <ListContext.Provider value={value}>\n        <ListFilterContext.Provider value={usePickFilterContext(value)}>\n            <ListSortContext.Provider value={usePickSortContext(value)}>\n                <ListPaginationContext.Provider\n                    value={usePickPaginationContext(value)}\n                >\n                    {children}\n                </ListPaginationContext.Provider>\n            </ListSortContext.Provider>\n        </ListFilterContext.Provider>\n    </ListContext.Provider>\n);\n","import { createContext } from 'react';\nimport { ListControllerResult } from './useListController';\n\n/**\n * Context to store the result of the useListController() hook.\n *\n * Use the useListContext() hook to read the context. That's what many\n * List components do in react-admin (e.g. <Datagrid>, <FilterForm>, <Pagination>).\n *\n * @typedef {Object} ListControllerProps\n * @prop {Array}    data an array of the list records, e.g. [{ id: 123, title: 'hello world' }, { ... }]\n * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23\n * @prop {boolean}  isFetching boolean that is true on mount, and false once the data was fetched\n * @prop {boolean}  isLoading boolean that is false until the data is available\n * @prop {integer}  page the current page. Starts at 1\n * @prop {Function} setPage a callback to change the page, e.g. setPage(3)\n * @prop {integer}  perPage the number of results per page. Defaults to 25\n * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)\n * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }\n * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field: 'name', order: 'ASC' })\n * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }\n * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)\n * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }\n * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)\n * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')\n * @prop {Array}    selectedIds an array listing the ids of the selected rows, e.g. [123, 456]\n * @prop {Function} onSelect callback to change the list of selected rows, e.g. onSelect([456, 789])\n * @prop {Function} onToggleItem callback to toggle the selection of a given record based on its id, e.g. onToggleItem(456)\n * @prop {Function} onUnselectItems callback to clear the selection, e.g. onUnselectItems();\n * @prop {string}   defaultTitle the translated title based on the resource, e.g. 'Posts'\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n * @prop {Function} refetch a function for triggering a refetch of the list data\n *\n * @typedef Props\n * @prop {ListControllerResult} value\n *\n * @param {Props}\n *\n * @see useListController\n * @see useListContext\n *\n * @example\n *\n * import { useListController, ListContext } from 'ra-core';\n *\n * const List = props => {\n *     const controllerProps = useListController(props);\n *     return (\n *         <ListContext.Provider value={controllerProps}>\n *             ...\n *         </ListContext.Provider>\n *     );\n * };\n */\nexport const ListContext = createContext<ListControllerResult>({\n    sort: null,\n    data: null,\n    defaultTitle: null,\n    displayedFilters: null,\n    exporter: null,\n    filterValues: null,\n    hasNextPage: null,\n    hasPreviousPage: null,\n    hideFilter: null,\n    isFetching: null,\n    isLoading: null,\n    onSelect: null,\n    onToggleItem: null,\n    onUnselectItems: null,\n    page: null,\n    perPage: null,\n    refetch: null,\n    resource: null,\n    selectedIds: undefined,\n    setFilters: null,\n    setPage: null,\n    setPerPage: null,\n    setSort: null,\n    showFilter: null,\n    total: null,\n});\n\nListContext.displayName = 'ListContext';\n","import { createContext, useMemo } from 'react';\nimport pick from 'lodash/pick';\nimport { ListControllerResult } from './useListController';\n\n/**\n * Context to store the filter part of the useListController() result.\n *\n * Use the useListFilterContext() hook to read the context. That's what many\n * List components do in react-admin (e.g. <FilterForm>, <FilterListItem>).\n *\n * @typedef {Object} ListFilterContextValue\n * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }\n * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)\n * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }\n * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)\n * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @typedef Props\n * @prop {ListFilterContextValue} value\n *\n * @param {Props}\n *\n * @see useListController\n * @see useListFilterContext\n *\n * @example\n *\n * import { useListController, usePickFilterContext, ListFilterContext } from 'ra-core';\n *\n * const List = props => {\n *     const controllerProps = useListController(props);\n *     return (\n *         <ListFilterContext.Provider value={usePickFilterContext(controllerProps)}>\n *             ...\n *         </ListFilterContext.Provider>\n *     );\n * };\n */\nexport const ListFilterContext = createContext<ListFilterContextValue>({\n    displayedFilters: null,\n    filterValues: null,\n    hideFilter: null,\n    setFilters: null,\n    showFilter: null,\n    resource: null,\n});\n\nexport type ListFilterContextValue = Pick<\n    ListControllerResult,\n    | 'displayedFilters'\n    | 'filterValues'\n    | 'hideFilter'\n    | 'setFilters'\n    | 'showFilter'\n    | 'resource'\n>;\n\nexport const usePickFilterContext = (\n    context: ListControllerResult\n): ListFilterContextValue =>\n    useMemo(\n        () =>\n            pick(context, [\n                'displayedFilters',\n                'filterValues',\n                'hideFilter',\n                'setFilters',\n                'showFilter',\n                'resource',\n            ]),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            context.displayedFilters,\n            context.filterValues,\n            context.hideFilter,\n            context.setFilters,\n            context.showFilter,\n        ]\n    );\n\nListFilterContext.displayName = 'ListFilterContext';\n","import { createContext, useMemo } from 'react';\nimport pick from 'lodash/pick';\nimport { ListControllerResult } from './useListController';\n\n/**\n * Context to store the sort part of the useListController() result.\n *\n * Use the useListSortContext() hook to read the context. That's what many\n * List components do in react-admin (e.g. <SortButton>).\n *\n * @typedef {Object} ListSortContextValue\n * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }\n * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field: 'name', order: 'ASC' })\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @typedef Props\n * @prop {ListSortContextValue} value\n *\n * @param {Props}\n *\n * @see useListController\n * @see useListSortContext\n *\n * @example\n *\n * import { useListController, usePickSortContext, ListSortContext } from 'ra-core';\n *\n * const List = props => {\n *     const controllerProps = useListController(props);\n *     return (\n *         <ListSortContext.Provider value={usePickSortContext(controllerProps)}>\n *             ...\n *         </ListSortContext.Provider>\n *     );\n * };\n */\nexport const ListSortContext = createContext<ListSortContextValue>({\n    sort: null,\n    setSort: null,\n    resource: null,\n});\n\nexport type ListSortContextValue = Pick<\n    ListControllerResult,\n    'sort' | 'setSort' | 'resource'\n>;\n\nexport const usePickSortContext = (\n    context: ListControllerResult\n): ListSortContextValue =>\n    useMemo(\n        () => pick(context, ['sort', 'setSort', 'resource']),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [context.sort, context.setSort]\n    );\n\nListSortContext.displayName = 'ListSortContext';\n","import { createContext, useMemo } from 'react';\nimport pick from 'lodash/pick';\nimport { ListControllerResult } from './useListController';\n\n/**\n * Context to store the pagination part of the useListController() result.\n *\n * Use the useListPaginationContext() hook to read the pagination information.\n * That's what List components do in react-admin (e.g. <Pagination>).\n *\n * @typedef {Object} ListPaginationContextValue\n * @prop {boolean}  isLoading boolean that is false until the data is available\n * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23\n * @prop {integer}  page the current page. Starts at 1\n * @prop {Function} setPage a callback to change the page, e.g. setPage(3)\n * @prop {integer}  perPage the number of results per page. Defaults to 25\n * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)\n * @prop {Boolean}  hasPreviousPage true if the current page is not the first one\n * @prop {Boolean}  hasNextPage true if the current page is not the last one\n\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @typedef Props\n * @prop {ListPaginationContextValue} value\n *\n * @param {Props}\n *\n * @see useListController\n * @see useListContext\n *\n * @example\n *\n * import { useListController, ListPaginationContext } from 'ra-core';\n *\n * const List = props => {\n *     const controllerProps = useListController(props);\n *     return (\n *         <ListPaginationContext.Provider value={controllerProps}>\n *             ...\n *         </ListPaginationContext.Provider>\n *     );\n * };\n */\nexport const ListPaginationContext = createContext<ListPaginationContextValue>({\n    isLoading: null,\n    page: null,\n    perPage: null,\n    setPage: null,\n    setPerPage: null,\n    hasPreviousPage: null,\n    hasNextPage: null,\n    total: undefined,\n    resource: null,\n});\n\nListPaginationContext.displayName = 'ListPaginationContext';\n\nexport type ListPaginationContextValue = Pick<\n    ListControllerResult,\n    | 'isLoading'\n    | 'hasPreviousPage'\n    | 'hasNextPage'\n    | 'page'\n    | 'perPage'\n    | 'setPage'\n    | 'setPerPage'\n    | 'total'\n    | 'resource'\n>;\n\nexport const usePickPaginationContext = (\n    context: ListControllerResult\n): ListPaginationContextValue =>\n    useMemo(\n        () =>\n            pick(context, [\n                'isLoading',\n                'hasPreviousPage',\n                'hasNextPage',\n                'page',\n                'perPage',\n                'setPage',\n                'setPerPage',\n                'total',\n                'resource',\n            ]),\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            context.isLoading,\n            context.hasPreviousPage,\n            context.hasNextPage,\n            context.page,\n            context.perPage,\n            context.setPage,\n            context.setPerPage,\n            context.total,\n        ]\n    );\n","import {\n    useListController,\n    ListControllerProps,\n    ListControllerResult,\n} from './useListController';\n\n/**\n * Render prop version of the useListController hook.\n *\n * @see useListController\n * @example\n *\n * const ListView = () => <div>...</div>;\n * const List = props => (\n *     <ListController {...props}>\n *        {controllerProps => <ListView {...controllerProps} {...props} />}\n *     </ListController>\n * )\n */\nexport const ListController = ({\n    children,\n    ...props\n}: {\n    children: (params: ListControllerResult) => JSX.Element;\n} & ListControllerProps) => {\n    const controllerProps = useListController(props);\n    return children(controllerProps);\n};\n","import { useCallback, useEffect, useRef } from 'react';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport { removeEmpty, useSafeSetState } from '../../util';\nimport { FilterPayload, RaRecord, SortPayload } from '../../types';\nimport { useResourceContext } from '../../core';\nimport usePaginationState from '../usePaginationState';\nimport useSortState from '../useSortState';\nimport { useRecordSelection } from './useRecordSelection';\nimport { ListControllerResult } from './useListController';\n\nconst refetch = () => {\n    throw new Error(\n        'refetch is not available for a ListContext built from useList based on local data'\n    );\n};\n\n/**\n * Handle filtering, sorting and pagination on local data.\n *\n * Returns the data and callbacks expected by <ListContext>.\n *\n * @example\n * const data = [\n *     { id: 1, name: 'Arnold' },\n *     { id: 2, name: 'Sylvester' },\n *     { id: 3, name: 'Jean-Claude' },\n * ]\n *\n * const MyComponent = () => {\n *     const listContext = useList({ data });\n *     return (\n *         <ListContextProvider value={listContext}>\n *             <Datagrid>\n *                 <TextField source=\"id\" />\n *                 <TextField source=\"name\" />\n *             </Datagrid>\n *         </ListContextProvider>\n *     );\n * };\n *\n * @param {UseListOptions} props\n * @param {RaRecord[]} props.data An array of records\n * @param {Boolean} props.isFetching: Optional. A boolean indicating whether the data is being loaded\n * @param {Boolean} props.isLoading: Optional. A boolean indicating whether the data has been loaded at least once\n * @param {Error | String} props.error: Optional. The error if any occurred while loading the data\n * @param {Object} props.filter: Optional. An object containing the filters applied on the data\n * @param {Number} props.page: Optional. The initial page index\n * @param {Number} props.perPage: Optional. The initial page size\n * @param {SortPayload} props.sort: Optional. The initial sort (field and order)\n */\nexport const useList = <RecordType extends RaRecord = any>(\n    props: UseListOptions<RecordType>\n): UseListValue<RecordType> => {\n    const {\n        data,\n        error,\n        filter = defaultFilter,\n        isFetching = false,\n        isLoading = false,\n        page: initialPage = 1,\n        perPage: initialPerPage = 1000,\n        sort: initialSort = defaultSort,\n    } = props;\n    const resource = useResourceContext(props);\n\n    const [fetchingState, setFetchingState] = useSafeSetState<boolean>(\n        isFetching\n    );\n    const [loadingState, setLoadingState] = useSafeSetState<boolean>(isLoading);\n\n    const [finalItems, setFinalItems] = useSafeSetState<{\n        data?: RecordType[];\n        total: number;\n    }>(() => ({\n        data,\n        total: data ? data.length : undefined,\n    }));\n\n    // pagination logic\n    const { page, setPage, perPage, setPerPage } = usePaginationState({\n        page: initialPage,\n        perPage: initialPerPage,\n    });\n\n    // sort logic\n    const { sort, setSort: setSortState } = useSortState(initialSort);\n    const setSort = useCallback(\n        (sort: SortPayload) => {\n            setSortState(sort);\n            setPage(1);\n        },\n        [setPage, setSortState]\n    );\n\n    // selection logic\n    const [selectedIds, selectionModifiers] = useRecordSelection(resource);\n\n    // filter logic\n    const filterRef = useRef(filter);\n    const [displayedFilters, setDisplayedFilters] = useSafeSetState<{\n        [key: string]: boolean;\n    }>({});\n    const [filterValues, setFilterValues] = useSafeSetState<{\n        [key: string]: any;\n    }>(filter);\n    const hideFilter = useCallback(\n        (filterName: string) => {\n            setDisplayedFilters(previousState => {\n                const { [filterName]: _, ...newState } = previousState;\n                return newState;\n            });\n            setFilterValues(previousState => {\n                const { [filterName]: _, ...newState } = previousState;\n                return newState;\n            });\n        },\n        [setDisplayedFilters, setFilterValues]\n    );\n    const showFilter = useCallback(\n        (filterName: string, defaultValue: any) => {\n            setDisplayedFilters(previousState => ({\n                ...previousState,\n                [filterName]: true,\n            }));\n            setFilterValues(previousState =>\n                removeEmpty({\n                    ...previousState,\n                    [filterName]: defaultValue,\n                })\n            );\n        },\n        [setDisplayedFilters, setFilterValues]\n    );\n    const setFilters = useCallback(\n        (filters, displayedFilters) => {\n            setFilterValues(removeEmpty(filters));\n            if (displayedFilters) {\n                setDisplayedFilters(displayedFilters);\n            }\n            setPage(1);\n        },\n        [setDisplayedFilters, setFilterValues, setPage]\n    );\n    // handle filter prop change\n    useEffect(() => {\n        if (!isEqual(filter, filterRef.current)) {\n            filterRef.current = filter;\n            setFilterValues(filter);\n        }\n    });\n\n    // We do all the data processing (filtering, sorting, paginating) client-side\n    useEffect(\n        () => {\n            if (isLoading || !data) return;\n\n            // 1. filter\n            let tempData = data.filter(record =>\n                Object.entries(filterValues).every(\n                    ([filterName, filterValue]) => {\n                        const recordValue = get(record, filterName);\n                        const result = Array.isArray(recordValue)\n                            ? Array.isArray(filterValue)\n                                ? recordValue.some(item =>\n                                      filterValue.includes(item)\n                                  )\n                                : recordValue.includes(filterValue)\n                            : Array.isArray(filterValue)\n                            ? filterValue.includes(recordValue)\n                            : filterValue == recordValue; // eslint-disable-line eqeqeq\n                        return result;\n                    }\n                )\n            );\n\n            const filteredLength = tempData.length;\n\n            // 2. sort\n            if (sort.field) {\n                tempData = tempData.sort((a, b) => {\n                    if (get(a, sort.field) > get(b, sort.field)) {\n                        return sort.order === 'ASC' ? 1 : -1;\n                    }\n                    if (get(a, sort.field) < get(b, sort.field)) {\n                        return sort.order === 'ASC' ? -1 : 1;\n                    }\n                    return 0;\n                });\n            }\n\n            // 3. paginate\n            tempData = tempData.slice((page - 1) * perPage, page * perPage);\n\n            setFinalItems({\n                data: tempData,\n                total: filteredLength,\n            });\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            JSON.stringify(data),\n            filterValues,\n            isLoading,\n            page,\n            perPage,\n            setFinalItems,\n            sort.field,\n            sort.order,\n        ]\n    );\n\n    useEffect(() => {\n        if (isFetching !== fetchingState) {\n            setFetchingState(isFetching);\n        }\n    }, [isFetching, fetchingState, setFetchingState]);\n\n    useEffect(() => {\n        if (isLoading !== loadingState) {\n            setLoadingState(isLoading);\n        }\n    }, [isLoading, loadingState, setLoadingState]);\n\n    return {\n        sort,\n        data: finalItems.data,\n        defaultTitle: '',\n        error,\n        displayedFilters,\n        filterValues,\n        hasNextPage: page * perPage < finalItems.total,\n        hasPreviousPage: page > 1,\n        hideFilter,\n        isFetching: fetchingState,\n        isLoading: loadingState,\n        onSelect: selectionModifiers.select,\n        onToggleItem: selectionModifiers.toggle,\n        onUnselectItems: selectionModifiers.clearSelection,\n        page,\n        perPage,\n        resource: undefined,\n        refetch,\n        selectedIds,\n        setFilters,\n        setPage,\n        setPerPage,\n        setSort,\n        showFilter,\n        total: finalItems.total,\n    };\n};\n\nexport interface UseListOptions<RecordType extends RaRecord = any> {\n    data?: RecordType[];\n    error?: any;\n    filter?: FilterPayload;\n    isFetching?: boolean;\n    isLoading?: boolean;\n    page?: number;\n    perPage?: number;\n    sort?: SortPayload;\n    resource?: string;\n}\n\nexport type UseListValue<\n    RecordType extends RaRecord = any\n> = ListControllerResult<RecordType>;\n\nconst defaultFilter = {};\nconst defaultSort = { field: null, order: null };\n","import { useContext, useMemo } from 'react';\nimport defaults from 'lodash/defaults';\n\nimport { ListContext } from './ListContext';\nimport { ListControllerResult } from './useListController';\nimport { RaRecord } from '../../types';\n\n/**\n * Hook to read the list controller props from the ListContext.\n *\n * Mostly used within a <ListContext.Provider> (e.g. as a descendent of <List>\n * or <ListBase>).\n *\n * But you can also use it without a <ListContext.Provider>. In this case, it is up to you\n * to pass all the necessary props (see the list below).\n *\n * The given props will take precedence over context values.\n *\n * @typedef {Object} ListControllerProps\n * @prop {Object}   data an array of the list records, e.g. [{ id: 123, title: 'hello world' }, { ... }]\n * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23\n * @prop {boolean}  isFetching boolean that is true on mount, and false once the data was fetched\n * @prop {boolean}  isLoading boolean that is false until the data is available\n * @prop {integer}  page the current page. Starts at 1\n * @prop {Function} setPage a callback to change the page, e.g. setPage(3)\n * @prop {integer}  perPage the number of results per page. Defaults to 25\n * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)\n * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }\n * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field : 'name', order: 'ASC' })\n * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }\n * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)\n * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }\n * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)\n * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')\n * @prop {Array}    selectedIds an array listing the ids of the selected rows, e.g. [123, 456]\n * @prop {Function} onSelect callback to change the list of selected rows, e.g. onSelect([456, 789])\n * @prop {Function} onToggleItem callback to toggle the selection of a given record based on its id, e.g. onToggleItem(456)\n * @prop {Function} onUnselectItems callback to clear the selection, e.g. onUnselectItems();\n * @prop {string}   defaultTitle the translated title based on the resource, e.g. 'Posts'\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @returns {ListControllerResult} list controller props\n *\n * @see useListController for how it is filled\n *\n * @example // custom list view\n *\n * import { useListContext } from 'react-admin';\n *\n * const MyList = () => {\n *     const { data, isLoading } = useListContext();\n *     if (isLoading) {\n *         return <>Loading...</>;\n *     }\n *     return (\n *         <ul>\n *             {data.map(record => (\n *                 <li key={record.id}>{record.name}</li>\n *             ))}\n *         </ul>\n *     );\n * }\n *\n * @example // custom pagination\n *\n * import { useListContext } from 'react-admin';\n * import { Button, Toolbar } from '@mui/material';\n * import ChevronLeft from '@mui/icons-material/ChevronLeft';\n * import ChevronRight from '@mui/icons-material/ChevronRight';\n *\n * const PrevNextPagination = () => {\n *     const { page, perPage, total, setPage } = useListContext();\n *     const nbPages = Math.ceil(total / perPage) || 1;\n *     return (\n *         nbPages > 1 &&\n *             <Toolbar>\n *                 {page > 1 &&\n *                     <Button color=\"primary\" key=\"prev\" onClick={() => setPage(page - 1)}>\n *                         <ChevronLeft />\n *                         Prev\n *                     </Button>\n *                 }\n *                 {page !== nbPages &&\n *                     <Button color=\"primary\" key=\"next\" onClick={() => setPage(page + 1)}>\n *                         Next\n *                         <ChevronRight />\n *                     </Button>\n *                 }\n *             </Toolbar>\n *     );\n * }\n */\nexport const useListContext = <RecordType extends RaRecord = any>(\n    props?: any\n): ListControllerResult<RecordType> => {\n    const context = useContext(ListContext);\n    // Props take precedence over the context\n    // @ts-ignore\n    return useMemo(\n        () =>\n            defaults(\n                {},\n                props != null ? extractListContextProps(props) : {},\n                context\n            ),\n        [context, props]\n    );\n};\n\n/**\n * Extract only the list controller props\n *\n * @param {Object} props Props passed to the useListContext hook\n *\n * @returns {ListControllerResult} List controller props\n */\nconst extractListContextProps = ({\n    sort,\n    data,\n    defaultTitle,\n    displayedFilters,\n    exporter,\n    filterValues,\n    hasCreate,\n    hideFilter,\n    isFetching,\n    isLoading,\n    onSelect,\n    onToggleItem,\n    onUnselectItems,\n    page,\n    perPage,\n    refetch,\n    resource,\n    selectedIds,\n    setFilters,\n    setPage,\n    setPerPage,\n    setSort,\n    showFilter,\n    total,\n}) => ({\n    sort,\n    data,\n    defaultTitle,\n    displayedFilters,\n    exporter,\n    filterValues,\n    hasCreate,\n    hideFilter,\n    isFetching,\n    isLoading,\n    onSelect,\n    onToggleItem,\n    onUnselectItems,\n    page,\n    perPage,\n    refetch,\n    resource,\n    selectedIds,\n    setFilters,\n    setPage,\n    setPerPage,\n    setSort,\n    showFilter,\n    total,\n});\n","import { useContext } from 'react';\n\nimport { ListFilterContext, ListFilterContextValue } from './ListFilterContext';\n\n/**\n * Hook to read the list controller props from the ListContext.\n *\n * Must be used within a <ListContextProvider> (e.g. as a descendent of <List>\n * or <ListBase>).\n *\n * @typedef {Object} ListFilterContextValue\n * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }\n * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)\n * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }\n * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)\n * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @returns {ListFilterContextValue} list controller props\n *\n * @see useListController for how it is filled\n */\nexport const useListFilterContext = (props?: any): ListFilterContextValue => {\n    const context = useContext(ListFilterContext);\n    if (!context.hideFilter) {\n        /**\n         * The element isn't inside a <ListFilterContext.Provider>\n         *\n         * This may only happen when using Datagrid / SimpleList / SingleFieldList components\n         * outside of a List / ReferenceManyField / ReferenceArrayField -\n         * which isn't documented but tolerated.\n         * To avoid breakage in that case, fallback to props\n         *\n         * @deprecated - to be removed in 4.0\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            console.log(\n                \"List components must be used inside a <ListContextProvider>. Relying on props rather than context to get List data and callbacks is deprecated and won't be supported in the next major version of react-admin.\"\n            );\n        }\n        return props;\n    }\n    return context;\n};\n","import { useContext } from 'react';\n\nimport {\n    ListPaginationContext,\n    ListPaginationContextValue,\n} from './ListPaginationContext';\n\n/**\n * Hook to read the list controller props from the ListContext.\n *\n * Must be used within a <ListContextProvider> (e.g. as a descendent of <List>\n * or <ListBase>).\n *\n * @typedef {Object} ListPaginationContextValue\n * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23\n * @prop {integer}  page the current page. Starts at 1\n * @prop {Function} setPage a callback to change the page, e.g. setPage(3)\n * @prop {integer}  perPage the number of results per page. Defaults to 25\n * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)\n * @prop {Boolean}  hasPreviousPage true if the current page is not the first one\n * @prop {Boolean}  hasNextPage true if the current page is not the last one\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @returns {ListPaginationContextValue} list controller props\n *\n * @see useListController for how it is filled\n */\nexport const useListPaginationContext = (\n    props?: any\n): ListPaginationContextValue => {\n    const context = useContext(ListPaginationContext);\n    if (!context.setPage) {\n        /**\n         * The element isn't inside a <ListPaginationContext.Provider>\n         *\n         * This may only happen when using Datagrid / SimpleList / SingleFieldList components\n         * outside of a List / ReferenceManyField / ReferenceArrayField -\n         * which isn't documented but tolerated.\n         * To avoid breakage in that case, fallback to props\n         *\n         * @deprecated - to be removed in 4.0\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            console.log(\n                \"List components must be used inside a <ListContextProvider>. Relying on props rather than context to get List data and callbacks is deprecated and won't be supported in the next major version of react-admin.\"\n            );\n        }\n        return props;\n    }\n    return context;\n};\n\nexport default useListPaginationContext;\n","import { useContext } from 'react';\n\nimport { ListSortContext, ListSortContextValue } from './ListSortContext';\n\n/**\n * Hook to read the list controller props from the ListContext.\n *\n * Must be used within a <ListContextProvider> (e.g. as a descendent of <List>\n * or <ListBase>).\n *\n * @typedef {Object} ListSortContextValue\n * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }\n * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field: 'name', order: 'ASC' })\n * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'\n *\n * @returns {ListSortContextValue} list controller props\n *\n * @see useListController for how it is filled\n */\nexport const useListSortContext = (props?: any): ListSortContextValue => {\n    const context = useContext(ListSortContext);\n    if (!context.setSort) {\n        /**\n         * The element isn't inside a <ListSortContext.Provider>\n         *\n         * This may only happen when using Datagrid / SimpleList / SingleFieldList components\n         * outside of a List / ReferenceManyField / ReferenceArrayField -\n         * which isn't documented but tolerated.\n         * To avoid breakage in that case, fallback to props\n         *\n         * @deprecated - to be removed in 4.0\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            console.log(\n                \"List components must be used inside a <ListContextProvider>. Relying on props rather than context to get List data and callbacks is deprecated and won't be supported in the next major version of react-admin.\"\n            );\n        }\n        return props;\n    }\n    return context;\n};\n","import { useCallback } from 'react';\n\nimport { useRecordSelection } from './useRecordSelection';\nimport { Identifier } from '../../types';\n\n/**\n * Hook to Unselect the rows of a datagrid\n *\n * @example\n *\n * const unselect = useUnselect('posts');\n * unselect([123, 456]);\n */\nexport const useUnselect = (resource: string) => {\n    const [, { unselect }] = useRecordSelection(resource);\n    return useCallback(\n        (ids: Identifier[]) => {\n            unselect(ids);\n        },\n        [unselect]\n    );\n};\n","import { useCallback } from 'react';\n\nimport { useRecordSelection } from './useRecordSelection';\n\n/**\n * Hook to unselect all row of a datagrid\n *\n * @example\n *\n * const unselectAll = useUnselectAll('posts');\n * unselectAll();\n */\nexport const useUnselectAll = (resource: string) => {\n    const [, { clearSelection }] = useRecordSelection(resource);\n    return useCallback(() => {\n        clearSelection();\n    }, [clearSelection]);\n};\n","import { useCallback } from 'react';\n\nimport { useStore } from '../../store';\nimport { Identifier } from '../../types';\n\n/**\n * State-like hook for controlling the expanded state of a list item\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {string|integer} id The record identifier, e.g. 123\n * @param {boolean} single Forces only one id to be expanded at a time\n * @returns {Object} Destructure as [expanded, toggleExpanded].\n *\n * @example\n *\n * const [expanded, toggleExpanded] = useExpanded('posts', 123);\n * const expandIcon = expanded ? ExpandLess : ExpandMore;\n * const onExpandClick = () => toggleExpanded();\n */\nexport const useExpanded = (\n    resource: string,\n    id: Identifier,\n    single: boolean = false\n): [boolean, () => void] => {\n    const [expandedIds, setExpandedIds] = useStore<Identifier[]>(\n        `${resource}.datagrid.expanded`,\n        []\n    );\n    const expanded = Array.isArray(expandedIds)\n        ? // eslint-disable-next-line eqeqeq\n          expandedIds.map(el => el == id).indexOf(true) !== -1\n        : false;\n\n    const toggleExpanded = useCallback(() => {\n        setExpandedIds(ids => {\n            if (!Array.isArray(ids)) {\n                return [id];\n            }\n            const index = ids.findIndex(el => el == id); // eslint-disable-line eqeqeq\n            return index > -1\n                ? single\n                    ? []\n                    : [...ids.slice(0, index), ...ids.slice(index + 1)]\n                : single\n                ? [id]\n                : [...ids, id];\n        });\n    }, [setExpandedIds, id, single]);\n\n    return [expanded, toggleExpanded];\n};\n","import get from 'lodash/get';\nimport { useCallback, useEffect, useRef } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nimport { useSafeSetState, removeEmpty } from '../../util';\nimport { useGetManyReference } from '../../dataProvider';\nimport { useNotify } from '../../notification';\nimport { RaRecord, SortPayload } from '../../types';\nimport { ListControllerResult } from '../list';\nimport usePaginationState from '../usePaginationState';\nimport { useRecordSelection } from '../list/useRecordSelection';\nimport useSortState from '../useSortState';\n\nexport interface UseReferenceManyFieldControllerParams {\n    filter?: any;\n    page?: number;\n    perPage?: number;\n    record?: RaRecord;\n    reference: string;\n    resource: string;\n    sort?: SortPayload;\n    source?: string;\n    target: string;\n}\n\nconst defaultFilter = {};\n\n/**\n * Fetch reference records, and return them when available\n *\n * The reference prop should be the name of one of the <Resource> components\n * added as <Admin> child.\n *\n * @example\n *\n * const { isLoading, data } = useReferenceManyFieldController({\n *     resource\n *     reference: 'users',\n *     record: {\n *         userId: 7\n *     }\n *     target: 'comments',\n *     source: 'userId',\n *     page: 1,\n *     perPage: 25,\n * });\n *\n * @param {Object} props\n * @param {string} props.resource The current resource name\n * @param {string} props.reference The linked resource name\n * @param {Object} props.record The current resource record\n * @param {string} props.target The target resource key\n * @param {Object} props.filter The filter applied on the recorded records list\n * @param {string} props.source The key of the linked resource identifier\n * @param {number} props.page the page number\n * @param {number} props.perPage the number of item per page\n * @param {Object} props.sort the sort to apply to the referenced records\n *\n * @returns {ListControllerResult} The reference many props\n */\nexport const useReferenceManyFieldController = (\n    props: UseReferenceManyFieldControllerParams\n): ListControllerResult => {\n    const {\n        reference,\n        record,\n        target,\n        filter = defaultFilter,\n        source,\n        page: initialPage,\n        perPage: initialPerPage,\n        sort: initialSort = { field: 'id', order: 'DESC' },\n    } = props;\n    const notify = useNotify();\n\n    // pagination logic\n    const { page, setPage, perPage, setPerPage } = usePaginationState({\n        page: initialPage,\n        perPage: initialPerPage,\n    });\n\n    // sort logic\n    const { sort, setSort: setSortState } = useSortState(initialSort);\n    const setSort = useCallback(\n        (sort: SortPayload) => {\n            setSortState(sort);\n            setPage(1);\n        },\n        [setPage, setSortState]\n    );\n\n    // selection logic\n    const [selectedIds, selectionModifiers] = useRecordSelection(reference);\n\n    // filter logic\n    const filterRef = useRef(filter);\n    const [displayedFilters, setDisplayedFilters] = useSafeSetState<{\n        [key: string]: boolean;\n    }>({});\n    const [filterValues, setFilterValues] = useSafeSetState<{\n        [key: string]: any;\n    }>(filter);\n    const hideFilter = useCallback(\n        (filterName: string) => {\n            setDisplayedFilters(previousState => {\n                const { [filterName]: _, ...newState } = previousState;\n                return newState;\n            });\n            setFilterValues(previousState => {\n                const { [filterName]: _, ...newState } = previousState;\n                return newState;\n            });\n        },\n        [setDisplayedFilters, setFilterValues]\n    );\n    const showFilter = useCallback(\n        (filterName: string, defaultValue: any) => {\n            setDisplayedFilters(previousState => ({\n                ...previousState,\n                [filterName]: true,\n            }));\n            setFilterValues(previousState => ({\n                ...previousState,\n                [filterName]: defaultValue,\n            }));\n        },\n        [setDisplayedFilters, setFilterValues]\n    );\n    const setFilters = useCallback(\n        (filters, displayedFilters) => {\n            setFilterValues(removeEmpty(filters));\n            setDisplayedFilters(displayedFilters);\n            setPage(1);\n        },\n        [setDisplayedFilters, setFilterValues, setPage]\n    );\n    // handle filter prop change\n    useEffect(() => {\n        if (!isEqual(filter, filterRef.current)) {\n            filterRef.current = filter;\n            setFilterValues(filter);\n        }\n    });\n\n    const {\n        data,\n        total,\n        pageInfo,\n        error,\n        isFetching,\n        isLoading,\n        refetch,\n    } = useGetManyReference(\n        reference,\n        {\n            target,\n            id: get(record, source),\n            pagination: { page, perPage },\n            sort,\n            filter: filterValues,\n        },\n        {\n            keepPreviousData: true,\n            onError: error =>\n                notify(\n                    typeof error === 'string'\n                        ? error\n                        : error.message || 'ra.notification.http_error',\n                    {\n                        type: 'warning',\n                        messageArgs: {\n                            _:\n                                typeof error === 'string'\n                                    ? error\n                                    : error && error.message\n                                    ? error.message\n                                    : undefined,\n                        },\n                    }\n                ),\n        }\n    );\n\n    return {\n        sort,\n        data,\n        defaultTitle: null,\n        displayedFilters,\n        error,\n        filterValues,\n        hideFilter,\n        isFetching,\n        isLoading,\n        onSelect: selectionModifiers.select,\n        onToggleItem: selectionModifiers.toggle,\n        onUnselectItems: selectionModifiers.clearSelection,\n        page,\n        perPage,\n        refetch,\n        resource: reference,\n        selectedIds,\n        setFilters,\n        setPage,\n        setPerPage,\n        hasNextPage: pageInfo\n            ? pageInfo.hasNextPage\n            : total != null\n            ? page * perPage < total\n            : undefined,\n        hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : page > 1,\n        setSort,\n        showFilter,\n        total,\n    };\n};\n","import get from 'lodash/get';\n\nimport { useGetManyReference } from '../../dataProvider';\nimport { useNotify } from '../../notification';\nimport { RaRecord } from '../../types';\nimport { UseReferenceResult } from '../useReference';\n\nexport interface UseReferenceOneFieldControllerParams {\n    record?: RaRecord;\n    reference: string;\n    source?: string;\n    target: string;\n}\n\n/**\n * Fetch a reference record in a one-to-one relationship, and return it when available\n *\n * The reference prop should be the name of one of the <Resource> components\n * added as <Admin> child.\n *\n * @example\n *\n * const { data, isLoading, error } = useReferenceOneFieldController({\n *     record: { id: 7, name: 'James Joyce'}\n *     reference: 'bios',\n *     target: 'author_id',\n * });\n *\n * @typedef {Object} UseReferenceOneFieldControllerParams\n * @prop {Object} props.record The current resource record\n * @prop {string} props.reference The linked resource name\n * @prop {string} props.target The target resource key\n * @prop {string} props.source The key current record identifier ('id' by default)\n *\n * @returns {UseReferenceResult} The request state. Destructure as { referenceRecord, isLoading, error }.\n */\nexport const useReferenceOneFieldController = (\n    props: UseReferenceOneFieldControllerParams\n): UseReferenceResult => {\n    const { reference, record, target, source = 'id' } = props;\n    const notify = useNotify();\n\n    const { data, error, isFetching, isLoading, refetch } = useGetManyReference(\n        reference,\n        {\n            target,\n            id: get(record, source),\n            pagination: { page: 1, perPage: 1 },\n            sort: { field: 'id', order: 'ASC' },\n            filter: {},\n        },\n        {\n            enabled: !!record,\n            onError: error =>\n                notify(\n                    typeof error === 'string'\n                        ? error\n                        : error.message || 'ra.notification.http_error',\n                    {\n                        type: 'warning',\n                        messageArgs: {\n                            _:\n                                typeof error === 'string'\n                                    ? error\n                                    : error && error.message\n                                    ? error.message\n                                    : undefined,\n                        },\n                    }\n                ),\n        }\n    );\n\n    return {\n        referenceRecord: data ? data[0] : undefined,\n        error,\n        isFetching,\n        isLoading,\n        refetch,\n    };\n};\n","import { RaRecord, Translate } from '../../types';\nimport { MatchingReferencesError } from './types';\nimport { ControllerRenderProps } from 'react-hook-form';\n\ninterface GetStatusForInputParams<RecordType extends RaRecord = RaRecord> {\n    field: Pick<ControllerRenderProps, 'value'>;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecord: RecordType;\n    translate: Translate;\n}\n\nconst isMatchingReferencesError = (\n    matchingReferences?: any\n): matchingReferences is MatchingReferencesError =>\n    matchingReferences && matchingReferences.error !== undefined;\n\nexport const getStatusForInput = <RecordType extends RaRecord = RaRecord>({\n    field,\n    matchingReferences,\n    referenceRecord,\n    translate = x => x,\n}: GetStatusForInputParams<RecordType>) => {\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n    const selectedReferenceError =\n        field.value && !referenceRecord\n            ? translate('ra.input.references.single_missing', {\n                  _: 'ra.input.references.single_missing',\n              })\n            : null;\n\n    return {\n        waiting:\n            (field.value && selectedReferenceError && !matchingReferences) ||\n            (!field.value && !matchingReferences),\n        error:\n            (field.value &&\n                selectedReferenceError &&\n                matchingReferencesError) ||\n            (!field.value && matchingReferencesError)\n                ? field.value\n                    ? selectedReferenceError\n                    : matchingReferencesError\n                : null,\n        warning: selectedReferenceError || matchingReferencesError,\n        choices: Array.isArray(matchingReferences)\n            ? matchingReferences\n            : [referenceRecord].filter(choice => choice),\n    };\n};\n\nexport const REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport const REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport const REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\n\nexport const getSelectedReferencesStatus = <RecordType extends RaRecord = any>(\n    field: Pick<ControllerRenderProps, 'value'>,\n    referenceRecords: RecordType[]\n) =>\n    !field.value || field.value.length === referenceRecords.length\n        ? REFERENCES_STATUS_READY\n        : referenceRecords.length > 0\n        ? REFERENCES_STATUS_INCOMPLETE\n        : REFERENCES_STATUS_EMPTY;\n\ninterface GetStatusForArrayInputParams<RecordType extends RaRecord = any> {\n    field: ControllerRenderProps;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecords: RecordType[];\n    translate: Translate;\n}\n\nexport const getStatusForArrayInput = <RecordType extends RaRecord = any>({\n    field,\n    matchingReferences,\n    referenceRecords,\n    translate = x => x,\n}: GetStatusForArrayInputParams<RecordType>) => {\n    // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n    // or \"incomplete\" (Not all of the reference data was found)\n    // or \"ready\" (all references data was found or there is no references from input.value)\n    const selectedReferencesDataStatus = getSelectedReferencesStatus(\n        field,\n        referenceRecords\n    );\n\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n\n    const choices = Array.isArray(matchingReferences)\n        ? referenceRecords.concat(\n              matchingReferences.filter(\n                  choice =>\n                      referenceRecords.findIndex(c => c.id === choice.id) === -1\n              )\n          )\n        : referenceRecords;\n\n    return {\n        waiting:\n            (!matchingReferences &&\n                field.value &&\n                selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ||\n            (!matchingReferences && !field.value),\n        error:\n            matchingReferencesError &&\n            (!field.value ||\n                (field.value &&\n                    selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))\n                ? translate('ra.input.references.all_missing', {\n                      _: 'ra.input.references.all_missing',\n                  })\n                : null,\n        warning:\n            matchingReferencesError ||\n            (field.value &&\n                selectedReferencesDataStatus !== REFERENCES_STATUS_READY)\n                ? matchingReferencesError ||\n                  translate('ra.input.references.many_missing', {\n                      _: 'ra.input.references.many_missing',\n                  })\n                : null,\n        choices,\n    };\n};\n","import { useCallback, useMemo } from 'react';\nimport { useWatch } from 'react-hook-form';\n\nimport { FilterPayload, RaRecord, SortPayload } from '../../types';\nimport { useGetList, useGetManyAggregate } from '../../dataProvider';\nimport { useReferenceParams } from './useReferenceParams';\nimport { ChoicesContextValue } from '../../form';\nimport { UseQueryOptions } from 'react-query';\n\n/**\n * Prepare data for the ReferenceArrayInput components\n *\n * @example\n *\n * const { allChoices, availableChoices, selectedChoices, error, isFetching, isLoading } = useReferenceArrayInputController({\n *      record: { referenceIds: ['id1', 'id2']};\n *      reference: 'reference';\n *      resource: 'resource';\n *      source: 'referenceIds';\n * });\n *\n * @param {Object} props\n * @param {Object} props.record The current resource record\n * @param {string} props.reference The linked resource name\n * @param {string} props.resource The current resource name\n * @param {string} props.source The key of the linked resource identifier\n *\n * @param {Props} props\n *\n * @return {Object} controllerProps Fetched data and callbacks for the ReferenceArrayInput components\n */\nexport const useReferenceArrayInputController = <\n    RecordType extends RaRecord = any\n>(\n    props: UseReferenceArrayInputParams<RecordType>\n): ChoicesContextValue<RecordType> => {\n    const {\n        debounce,\n        enableGetChoices,\n        filter,\n        page: initialPage = 1,\n        perPage: initialPerPage = 25,\n        sort: initialSort = { field: 'id', order: 'DESC' },\n        queryOptions = {},\n        reference,\n        source,\n    } = props;\n    const value = useWatch({ name: source });\n\n    /**\n     * Get the records related to the current value (with getMany)\n     */\n    const {\n        data: referenceRecords,\n        error: errorGetMany,\n        isLoading: isLoadingGetMany,\n        isFetching: isFetchingGetMany,\n        refetch: refetchGetMany,\n    } = useGetManyAggregate<RecordType>(\n        reference,\n        {\n            ids: value || EmptyArray,\n        },\n        {\n            enabled: value != null && value.length > 0,\n        }\n    );\n\n    const [params, paramsModifiers] = useReferenceParams({\n        resource: reference,\n        page: initialPage,\n        perPage: initialPerPage,\n        sort: initialSort,\n        debounce,\n        filter,\n    });\n\n    // filter out not found references - happens when the dataProvider doesn't guarantee referential integrity\n    const finalReferenceRecords = referenceRecords\n        ? referenceRecords.filter(Boolean)\n        : [];\n\n    const isGetMatchingEnabled = enableGetChoices\n        ? enableGetChoices(params.filterValues)\n        : true;\n\n    const {\n        data: matchingReferences,\n        total,\n        pageInfo,\n        error: errorGetList,\n        isLoading: isLoadingGetList,\n        isFetching: isFetchingGetList,\n        refetch: refetchGetMatching,\n    } = useGetList<RecordType>(\n        reference,\n        {\n            pagination: {\n                page: params.page,\n                perPage: params.perPage,\n            },\n            sort: { field: params.sort, order: params.order },\n            filter: { ...params.filter, ...filter },\n        },\n        { retry: false, enabled: isGetMatchingEnabled, ...queryOptions }\n    );\n\n    // We merge the currently selected records with the matching ones, otherwise\n    // the component displaying the currently selected records may fail\n    const finalMatchingReferences =\n        matchingReferences && matchingReferences.length > 0\n            ? mergeReferences(matchingReferences, finalReferenceRecords)\n            : finalReferenceRecords.length > 0\n            ? finalReferenceRecords\n            : matchingReferences;\n\n    const refetch = useCallback(() => {\n        refetchGetMany();\n        refetchGetMatching();\n    }, [refetchGetMany, refetchGetMatching]);\n\n    const currentSort = useMemo(\n        () => ({\n            field: params.sort,\n            order: params.order,\n        }),\n        [params.sort, params.order]\n    );\n    return {\n        sort: currentSort,\n        allChoices: finalMatchingReferences,\n        availableChoices: matchingReferences,\n        selectedChoices: finalReferenceRecords,\n        displayedFilters: params.displayedFilters,\n        error: errorGetMany || errorGetList,\n        filter,\n        filterValues: params.filterValues,\n        hideFilter: paramsModifiers.hideFilter,\n        isFetching: isFetchingGetMany || isFetchingGetList,\n        isLoading: isLoadingGetMany || isLoadingGetList,\n        page: params.page,\n        perPage: params.perPage,\n        refetch,\n        resource: reference,\n        setFilters: paramsModifiers.setFilters,\n        setPage: paramsModifiers.setPage,\n        setPerPage: paramsModifiers.setPerPage,\n        setSort: paramsModifiers.setSort,\n        showFilter: paramsModifiers.showFilter,\n        source,\n        total: total,\n        hasNextPage: pageInfo\n            ? pageInfo.hasNextPage\n            : total != null\n            ? params.page * params.perPage < total\n            : undefined,\n        hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,\n    };\n};\n\nconst EmptyArray = [];\n\n// concatenate and deduplicate two lists of records\nconst mergeReferences = <RecordType extends RaRecord = any>(\n    ref1: RecordType[],\n    ref2: RecordType[]\n): RecordType[] => {\n    const res = [...ref1];\n    const ids = ref1.map(ref => ref.id);\n    ref2.forEach(ref => {\n        if (!ids.includes(ref.id)) {\n            ids.push(ref.id);\n            res.push(ref);\n        }\n    });\n    return res;\n};\n\nexport interface UseReferenceArrayInputParams<\n    RecordType extends RaRecord = any\n> {\n    debounce?: number;\n    filter?: FilterPayload;\n    queryOptions?: UseQueryOptions<{\n        data: RecordType[];\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    }>;\n    page?: number;\n    perPage?: number;\n    record?: RecordType;\n    reference: string;\n    resource?: string;\n    sort?: SortPayload;\n    source: string;\n    enableGetChoices?: (filters: any) => boolean;\n}\n","import { useCallback, useMemo, useState, useRef } from 'react';\nimport lodashDebounce from 'lodash/debounce';\n\nimport { SortPayload, FilterPayload } from '../../types';\nimport removeEmpty from '../../util/removeEmpty';\nimport {\n    queryReducer,\n    HIDE_FILTER,\n    SET_FILTER,\n    SET_PAGE,\n    SET_PER_PAGE,\n    SET_SORT,\n    SHOW_FILTER,\n    SORT_ASC,\n} from '../list';\n\n/**\n * Get the reference inputs parameters (page, sort, filters) and modifiers.\n *\n * @returns {Array} A tuple [parameters, modifiers].\n * Destructure as [\n *    { page, perPage, sort, order, filter, filterValues, displayedFilters, requestSignature },\n *    { setFilters, hideFilter, showFilter, setPage, setPerPage, setSort }\n * ]\n *\n * @example\n *\n * const [referenceParams, referenceParamsActions] = useReferenceParams({\n *      resource: 'posts',\n *      filterDefaultValues: {\n *          published: true\n *      },\n *      sort: {\n *          field: 'published_at',\n *          order: 'DESC'\n *      },\n *      perPage: 25\n * });\n *\n * const {\n *      page,\n *      perPage,\n *      sort,\n *      order,\n *      filter,\n *      filterValues,\n *      displayedFilters,\n *      requestSignature\n * } = referenceParams;\n *\n * const {\n *      setFilters,\n *      hideFilter,\n *      showFilter,\n *      setPage,\n *      setPerPage,\n *      setSort,\n * } = referenceParamsActions;\n */\nexport const useReferenceParams = ({\n    resource,\n    filter,\n    sort = defaultSort,\n    page = 1,\n    perPage = 10,\n    debounce = 500,\n}: ReferenceParamsOptions): [Parameters, Modifiers] => {\n    const [params, setParams] = useState(defaultParams);\n    const tempParams = useRef<ReferenceParams>();\n\n    const requestSignature = [\n        resource,\n        JSON.stringify(params),\n        JSON.stringify(filter),\n        JSON.stringify(sort),\n        page,\n        perPage,\n    ];\n\n    const query = useMemo(\n        () =>\n            getQuery({\n                params: params,\n                filterDefaultValues: filter,\n                sort,\n                page,\n                perPage,\n            }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const changeParams = useCallback(action => {\n        if (!tempParams.current) {\n            // no other changeParams action dispatched this tick\n            tempParams.current = queryReducer(query, action);\n            // schedule side effects for next tick\n            setTimeout(() => {\n                setParams(tempParams.current);\n                tempParams.current = undefined;\n            }, 0);\n        } else {\n            // side effects already scheduled, just change the params\n            tempParams.current = queryReducer(tempParams.current, action);\n        }\n    }, requestSignature); // eslint-disable-line react-hooks/exhaustive-deps\n\n    const setSort = useCallback(\n        (sort: SortPayload) =>\n            changeParams({\n                type: SET_SORT,\n                payload: sort,\n            }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const setPage = useCallback(\n        (newPage: number) => changeParams({ type: SET_PAGE, payload: newPage }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const setPerPage = useCallback(\n        (newPerPage: number) =>\n            changeParams({ type: SET_PER_PAGE, payload: newPerPage }),\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const filterValues = query.filter || emptyObject;\n    const displayedFilterValues = query.displayedFilters || emptyObject;\n\n    const debouncedSetFilters = lodashDebounce((filter, displayedFilters) => {\n        changeParams({\n            type: SET_FILTER,\n            payload: {\n                filter: removeEmpty(filter),\n                displayedFilters,\n            },\n        });\n    }, debounce);\n\n    const setFilters = useCallback(\n        (filter, displayedFilters, debounce = true) => {\n            debounce\n                ? debouncedSetFilters(filter, displayedFilters)\n                : changeParams({\n                      type: SET_FILTER,\n                      payload: {\n                          filter: removeEmpty(filter),\n                          displayedFilters,\n                      },\n                  });\n        },\n        requestSignature // eslint-disable-line react-hooks/exhaustive-deps\n    );\n\n    const hideFilter = useCallback((filterName: string) => {\n        changeParams({\n            type: HIDE_FILTER,\n            payload: filterName,\n        });\n    }, requestSignature); // eslint-disable-line react-hooks/exhaustive-deps\n\n    const showFilter = useCallback((filterName: string, defaultValue: any) => {\n        changeParams({\n            type: SHOW_FILTER,\n            payload: {\n                filterName,\n                defaultValue,\n            },\n        });\n    }, requestSignature); // eslint-disable-line react-hooks/exhaustive-deps\n    return [\n        {\n            displayedFilters: displayedFilterValues,\n            filterValues,\n            requestSignature,\n            ...query,\n        },\n        {\n            changeParams,\n            setPage,\n            setPerPage,\n            setSort,\n            setFilters,\n            hideFilter,\n            showFilter,\n        },\n    ];\n};\n\nexport const validQueryParams = [\n    'page',\n    'perPage',\n    'sort',\n    'order',\n    'filter',\n    'displayedFilters',\n];\n\n/**\n * Merge list params from 2 different sources:\n *   - the params stored in the local state\n *   - the props passed to the List component (including the filter defaultValues)\n */\nexport const getQuery = ({\n    params,\n    filterDefaultValues,\n    sort,\n    page,\n    perPage,\n}) => {\n    const query: Partial<ReferenceParams> = hasCustomParams(params)\n        ? { ...params }\n        : { filter: filterDefaultValues || {} };\n\n    if (!query.sort) {\n        query.sort = sort.field;\n        query.order = sort.order;\n    }\n    if (query.page == null) {\n        query.page = page;\n    }\n    if (query.perPage == null) {\n        query.perPage = perPage;\n    }\n    if (query.page == null) {\n        query.page = 1;\n    }\n\n    return {\n        ...query,\n        page: getNumberOrDefault(query.page, 1),\n        perPage: getNumberOrDefault(query.perPage, 10),\n    } as ReferenceParams;\n};\n\n/**\n * Check if user has already set custom sort, page, or filters for this list\n *\n * User params come from the Redux store as the params props. By default,\n * this object is:\n *\n * { filter: {}, order: null, page: 1, perPage: null, sort: null }\n *\n * To check if the user has custom params, we must compare the params\n * to these initial values.\n *\n * @param {Object} params\n */\nexport const hasCustomParams = (params: ReferenceParams) => {\n    return (\n        params &&\n        params.filter &&\n        (Object.keys(params.filter).length > 0 ||\n            params.order != null ||\n            params.page !== 1 ||\n            params.perPage != null ||\n            params.sort != null)\n    );\n};\n\nexport const getNumberOrDefault = (\n    possibleNumber: string | number | undefined,\n    defaultValue: number\n) => {\n    const parsedNumber =\n        typeof possibleNumber === 'string'\n            ? parseInt(possibleNumber, 10)\n            : possibleNumber;\n\n    return isNaN(parsedNumber) ? defaultValue : parsedNumber;\n};\n\nexport interface ReferenceParamsOptions {\n    resource: string;\n    page?: number;\n    perPage?: number;\n    sort?: SortPayload;\n    // default value for a filter when displayed but not yet set\n    filter?: FilterPayload;\n    debounce?: number;\n}\n\nexport interface ReferenceParams {\n    sort: string;\n    order: string;\n    page: number;\n    perPage: number;\n    filter: any;\n    displayedFilters: any;\n}\n\ninterface Parameters extends ReferenceParams {\n    filterValues: object;\n    displayedFilters: {\n        [key: string]: boolean;\n    };\n    requestSignature: any[];\n}\n\ninterface Modifiers {\n    changeParams: (action: any) => void;\n    setPage: (page: number) => void;\n    setPerPage: (pageSize: number) => void;\n    setSort: (sort: SortPayload) => void;\n    setFilters: (filters: any, displayedFilters: any) => void;\n    hideFilter: (filterName: string) => void;\n    showFilter: (filterName: string, defaultValue: any) => void;\n}\n\nconst emptyObject = {};\n\nconst defaultSort = {\n    field: 'id',\n    order: SORT_ASC,\n};\n\nconst defaultParams = {};\n","import { useCallback, useMemo } from 'react';\nimport { useWatch } from 'react-hook-form';\nimport { useGetList } from '../../dataProvider';\nimport { FilterPayload, RaRecord, SortPayload } from '../../types';\nimport { useReference } from '../useReference';\nimport { ChoicesContextValue } from '../../form';\nimport { useReferenceParams } from './useReferenceParams';\nimport { UseQueryOptions } from 'react-query';\n\nconst defaultReferenceSource = (resource: string, source: string) =>\n    `${resource}@${source}`;\n\n/**\n * A hook for choosing a reference record. Useful for foreign keys.\n *\n * This hook fetches the possible values in the reference resource\n * (using `dataProvider.getList()`), it returns the possible choices\n * as the `choices` attribute.\n *\n * @example\n * const {\n *      choices, // the available reference resource\n * } = useReferenceInputController({\n *      input, // the input props\n *      resource: 'comments',\n *      reference: 'posts',\n *      source: 'post_id',\n * });\n *\n * The hook also allow to filter results. It returns a `setFilters`\n * function. It uses the value to create a filter for the query.\n * You can also add a permanentFilter to further filter the result:\n *\n * @example\n * const {\n *      choices, // the available reference resource\n *      setFilter,\n * } = useReferenceInputController({\n *      input, // the input props\n *      resource: 'comments',\n *      reference: 'posts',\n *      source: 'post_id',\n *      permanentFilter: {\n *          author: 'john'\n *      },\n * });\n */\nexport const useReferenceInputController = <RecordType extends RaRecord = any>(\n    props: UseReferenceInputControllerParams\n): ChoicesContextValue<RecordType> => {\n    const {\n        debounce,\n        enableGetChoices,\n        filter,\n        page: initialPage = 1,\n        perPage: initialPerPage = 25,\n        sort: initialSort,\n        queryOptions = {},\n        reference,\n        source,\n    } = props;\n\n    const [params, paramsModifiers] = useReferenceParams({\n        resource: reference,\n        page: initialPage,\n        perPage: initialPerPage,\n        sort: initialSort,\n        debounce,\n        filter,\n    });\n\n    // selection logic\n    const currentValue = useWatch({ name: source });\n\n    const isGetMatchingEnabled = enableGetChoices\n        ? enableGetChoices(params.filterValues)\n        : true;\n\n    // fetch possible values\n    const {\n        data: possibleValuesData = [],\n        total,\n        pageInfo,\n        isFetching: possibleValuesFetching,\n        isLoading: possibleValuesLoading,\n        error: possibleValuesError,\n        refetch: refetchGetList,\n    } = useGetList<RecordType>(\n        reference,\n        {\n            pagination: {\n                page: params.page,\n                perPage: params.perPage,\n            },\n            sort: { field: params.sort, order: params.order },\n            filter: { ...params.filter, ...filter },\n        },\n        {\n            enabled: isGetMatchingEnabled,\n            ...queryOptions,\n        }\n    );\n\n    // fetch current value\n    const {\n        referenceRecord,\n        refetch: refetchReference,\n        error: referenceError,\n        isLoading: referenceLoading,\n        isFetching: referenceFetching,\n    } = useReference<RecordType>({\n        id: currentValue,\n        reference,\n    });\n    // add current value to possible sources\n    let finalData: RecordType[], finalTotal: number;\n    if (\n        !referenceRecord ||\n        possibleValuesData.find(record => record.id === currentValue)\n    ) {\n        finalData = possibleValuesData;\n        finalTotal = total;\n    } else {\n        finalData = [referenceRecord, ...possibleValuesData];\n        finalTotal = total == null ? undefined : total + 1;\n    }\n\n    const refetch = useCallback(() => {\n        refetchGetList();\n        refetchReference();\n    }, [refetchGetList, refetchReference]);\n\n    const currentSort = useMemo(\n        () => ({\n            field: params.sort,\n            order: params.order,\n        }),\n        [params.sort, params.order]\n    );\n    return {\n        sort: currentSort,\n        allChoices: finalData,\n        availableChoices: possibleValuesData,\n        selectedChoices: [referenceRecord],\n        displayedFilters: params.displayedFilters,\n        error: referenceError || possibleValuesError,\n        filter: params.filter,\n        filterValues: params.filterValues,\n        hideFilter: paramsModifiers.hideFilter,\n        isFetching: referenceFetching || possibleValuesFetching,\n        isLoading: referenceLoading || possibleValuesLoading,\n        page: params.page,\n        perPage: params.perPage,\n        refetch,\n        resource: reference,\n        setFilters: paramsModifiers.setFilters,\n        setPage: paramsModifiers.setPage,\n        setPerPage: paramsModifiers.setPerPage,\n        setSort: paramsModifiers.setSort,\n        showFilter: paramsModifiers.showFilter,\n        source,\n        total: finalTotal,\n        hasNextPage: pageInfo\n            ? pageInfo.hasNextPage\n            : total != null\n            ? params.page * params.perPage < total\n            : undefined,\n        hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,\n    };\n};\n\nexport interface UseReferenceInputControllerParams<\n    RecordType extends RaRecord = any\n> {\n    debounce?: number;\n    filter?: FilterPayload;\n    queryOptions?: UseQueryOptions<{\n        data: RecordType[];\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    }>;\n    page?: number;\n    perPage?: number;\n    record?: RaRecord;\n    reference: string;\n    // @deprecated ignored\n    referenceSource?: typeof defaultReferenceSource;\n    resource?: string;\n    sort?: SortPayload;\n    source: string;\n    enableGetChoices?: (filters: any) => boolean;\n}\n","import { RaRecord, Identifier } from '../types';\nimport { UseGetManyHookValue, useGetManyAggregate } from '../dataProvider';\n\ninterface UseReferenceProps {\n    id: Identifier;\n    reference: string;\n}\n\nexport interface UseReferenceResult<RecordType extends RaRecord = any> {\n    isLoading: boolean;\n    isFetching: boolean;\n    referenceRecord?: RecordType;\n    error?: any;\n    refetch: UseGetManyHookValue<RecordType>['refetch'];\n}\n\n/**\n * @typedef UseReferenceResult\n * @type {Object}\n * @property {boolean} isFetching: boolean indicating if the reference is loading\n * @property {boolean} isLoading: boolean indicating if the reference has loaded at least once\n * @property {Object} referenceRecord: the referenced record.\n */\n\n/**\n * Fetch reference record, and return it when available\n *\n * The reference prop should be the name of one of the <Resource> components\n * added as <Admin> child.\n *\n * @example\n *\n * const { isLoading, referenceRecord } = useReference({\n *     id: 7,\n *     reference: 'users',\n * });\n *\n * @param {Object} option\n * @param {string} option.reference The linked resource name\n * @param {string} option.id The id of the reference\n *\n * @returns {UseReferenceResult} The reference record\n */\nexport const useReference = <RecordType extends RaRecord = any>({\n    reference,\n    id,\n}: UseReferenceProps): UseReferenceResult<RecordType> => {\n    const { data, error, isLoading, isFetching, refetch } = useGetManyAggregate<\n        RecordType\n    >(reference, { ids: [id] });\n    return {\n        referenceRecord: error ? undefined : data ? data[0] : undefined,\n        refetch,\n        error,\n        isLoading,\n        isFetching,\n    };\n};\n","import * as React from 'react';\nimport { ReactElement } from 'react';\n\nimport { RaRecord } from '../../types';\nimport { useShowController, ShowControllerProps } from './useShowController';\nimport { ShowContextProvider } from './ShowContextProvider';\n\n/**\n * Call useShowController and put the value in a ShowContext\n *\n * Base class for <Show> components, without UI.\n *\n * Accepts any props accepted by useShowController:\n * - id: The record identifier\n * - resource: The resource\n *\n * @example // Custom show layout\n *\n * const PostShow = () => (\n *     <ShowBase resource=\"posts\">\n *         <Grid container>\n *             <Grid item xs={8}>\n *                 <SimpleForm>\n *                     ...\n *                 </SimpleForm>\n *             </Grid>\n *             <Grid item xs={4}>\n *                 Show instructions...\n *             </Grid>\n *         </Grid>\n *         <div>\n *             Post related links...\n *         </div>\n *     </ShowBase>\n * );\n */\nexport const ShowBase = <RecordType extends RaRecord = any>({\n    children,\n    ...props\n}: { children: ReactElement } & ShowControllerProps<RecordType>) => (\n    <ShowContextProvider value={useShowController<RecordType>(props)}>\n        {children}\n    </ShowContextProvider>\n);\n","import { useParams } from 'react-router-dom';\nimport { UseQueryOptions } from 'react-query';\n\nimport { useAuthenticated } from '../../auth';\nimport { RaRecord } from '../../types';\nimport { useGetOne, useRefresh, UseGetOneHookValue } from '../../dataProvider';\nimport { useTranslate } from '../../i18n';\nimport { useRedirect } from '../../routing';\nimport { useNotify } from '../../notification';\nimport { useResourceContext, useGetResourceLabel } from '../../core';\n\n/**\n * Prepare data for the Show view.\n *\n * useShowController does a few things:\n * - it grabs the id from the URL and the resource name from the ResourceContext,\n * - it fetches the record via useGetOne,\n * - it prepares the page title.\n *\n * @param {Object} props The props passed to the Show component.\n *\n * @return {Object} controllerProps Fetched data and callbacks for the Show view\n *\n * @example\n *\n * import { useShowController } from 'react-admin';\n * import ShowView from './ShowView';\n *\n * const MyShow = () => {\n *     const controllerProps = useShowController();\n *     return <ShowView {...controllerProps} />;\n * };\n *\n * @example // useShowController can also take its parameters from props\n *\n * import { useShowController } from 'react-admin';\n * import ShowView from './ShowView';\n *\n * const MyShow = () => {\n *     const controllerProps = useShowController({ resource: 'posts', id: 1234 });\n *     return <ShowView {...controllerProps} />;\n * };\n */\nexport const useShowController = <RecordType extends RaRecord = any>(\n    props: ShowControllerProps<RecordType> = {}\n): ShowControllerResult<RecordType> => {\n    const { disableAuthentication, id: propsId, queryOptions = {} } = props;\n\n    useAuthenticated({ enabled: !disableAuthentication });\n\n    const resource = useResourceContext(props);\n    const translate = useTranslate();\n    const notify = useNotify();\n    const redirect = useRedirect();\n    const refresh = useRefresh();\n    const { id: routeId } = useParams<'id'>();\n    const id = propsId || decodeURIComponent(routeId);\n\n    const { data: record, error, isLoading, isFetching, refetch } = useGetOne<\n        RecordType\n    >(\n        resource,\n        { id },\n        {\n            onError: () => {\n                notify('ra.notification.item_doesnt_exist', {\n                    type: 'warning',\n                });\n                redirect('list', resource);\n                refresh();\n            },\n            retry: false,\n            ...queryOptions,\n        }\n    );\n\n    // eslint-disable-next-line eqeqeq\n    if (record && record.id && record.id != id) {\n        throw new Error(\n            `useShowController: Fetched record's id attribute (${record.id}) must match the requested 'id' (${id})`\n        );\n    }\n\n    const getResourceLabel = useGetResourceLabel();\n    const defaultTitle = translate('ra.page.show', {\n        name: getResourceLabel(resource, 1),\n        id,\n        record,\n    });\n\n    return {\n        defaultTitle,\n        error,\n        isLoading,\n        isFetching,\n        record,\n        refetch,\n        resource,\n    };\n};\n\nexport interface ShowControllerProps<RecordType extends RaRecord = any> {\n    disableAuthentication?: boolean;\n    id?: RecordType['id'];\n    queryOptions?: UseQueryOptions<RecordType>;\n    resource?: string;\n}\n\nexport interface ShowControllerResult<RecordType extends RaRecord = any> {\n    defaultTitle: string;\n    // Necessary for actions (EditActions) which expect a data prop containing the record\n    // @deprecated - to be removed in 4.0d\n    data?: RecordType;\n    error?: any;\n    isFetching: boolean;\n    isLoading: boolean;\n    resource: string;\n    record?: RecordType;\n    refetch: UseGetOneHookValue<RecordType>['refetch'];\n}\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { RaRecord } from '../../types';\nimport { RecordContextProvider } from '../record/RecordContext';\nimport { ShowContext } from './ShowContext';\nimport { ShowControllerResult } from './useShowController';\n\n/**\n * Create a Show Context.\n *\n * @example\n *\n * const MyShow = (props) => {\n *     const controllerProps = useShowController(props);\n *     return (\n *         <ShowContextProvider value={controllerProps}>\n *             <MyShowView>\n *         </ShowContextProvider>\n *     );\n * };\n *\n * const MyShowView = () => {\n *     const record = useRecordContext();\n * }\n *\n * @see ShowContext\n * @see RecordContext\n */\nexport const ShowContextProvider = ({\n    children,\n    value,\n}: {\n    children: ReactNode;\n    value: ShowControllerResult;\n}) => (\n    <ShowContext.Provider value={value}>\n        <RecordContextProvider<Partial<RaRecord>> value={value && value.record}>\n            {children}\n        </RecordContextProvider>\n    </ShowContext.Provider>\n);\n","import { createContext } from 'react';\nimport { ShowControllerResult } from './useShowController';\n\n/**\n * Context to store the result of the useShowController() hook.\n *\n * Use the useShowContext() hook to read the context. That's what the Show components do in react-admin.\n *\n * @example\n *\n * import { useShowController, ShowContextProvider } from 'ra-core';\n *\n * const Show = props => {\n *     const controllerProps = useShowController(props);\n *     return (\n *         <ShowContextProvider value={controllerProps}>\n *             ...\n *         </ShowContextProvider>\n *     );\n * };\n */\nexport const ShowContext = createContext<ShowControllerResult>({\n    record: null,\n    defaultTitle: null,\n    isFetching: null,\n    isLoading: null,\n    refetch: null,\n    resource: null,\n});\n\nShowContext.displayName = 'ShowContext';\n","import {\n    useShowController,\n    ShowControllerProps,\n    ShowControllerResult,\n} from './useShowController';\n\n/**\n * Render prop version of the useShowController hook\n *\n * @see useShowController\n * @example\n *\n * const ShowView = () => <div>...</div>\n * const MyShow = () => (\n *     <ShowController>\n *         {controllerProps => <ShowView {...controllerProps} {...props} />}\n *     </ShowController>\n * );\n */\nexport const ShowController = ({\n    children,\n    ...props\n}: {\n    children: (params: ShowControllerResult) => JSX.Element;\n} & ShowControllerProps) => {\n    const controllerProps = useShowController(props);\n    return children(controllerProps);\n};\n","import { useContext, useMemo } from 'react';\nimport defaults from 'lodash/defaults';\n\nimport { RaRecord } from '../../types';\nimport { ShowContext } from './ShowContext';\nimport { ShowControllerResult } from './useShowController';\n\n/**\n * Hook to read the show controller props from the ShowContext.\n *\n * Mostly used within a <ShowContext.Provider> (e.g. as a descendent of <Show>).\n *\n * But you can also use it without a <ShowContext.Provider>. In this case, it is up to you\n * to pass all the necessary props.\n *\n * The given props will take precedence over context values.\n *\n * @typedef {Object} ShowControllerResult\n *\n * @returns {ShowControllerResult} create controller props\n *\n * @see useShowController for how it is filled\n *\n */\nexport const useShowContext = <RecordType extends RaRecord = any>(\n    props?: Partial<ShowControllerResult<RecordType>>\n): Partial<ShowControllerResult<RecordType>> => {\n    // Can't find a way to specify the RecordType when ShowContext is declared\n    // @ts-ignore\n    const context = useContext<ShowControllerResult<RecordType>>(ShowContext);\n\n    // Props take precedence over the context\n    return useMemo(\n        () =>\n            defaults(\n                {},\n                props != null ? extractShowContextProps(props) : {},\n                context\n            ),\n        [context, props]\n    );\n};\n\n/**\n * Extract only the show controller props\n *\n * @param {Object} props props passed to the useShowContext hook\n *\n * @returns {ShowControllerResult} show controller props\n */\nconst extractShowContextProps = ({\n    record,\n    data,\n    defaultTitle,\n    isFetching,\n    isLoading,\n    resource,\n}: any) => ({\n    // Necessary for actions (EditActions) which expect a data prop containing the record\n    // @deprecated - to be removed in 4.0d\n    record: record || data,\n    data: record || data,\n    defaultTitle,\n    isFetching,\n    isLoading,\n    resource,\n});\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { useWatch } from 'react-hook-form';\nimport get from 'lodash/get';\n\nimport warning from '../util/warning';\n/**\n * Get the current (edited) value of the record from the form and pass it\n * to a child function\n *\n * @example\n *\n * const PostEdit = (props) => (\n *     <Edit {...props}>\n *         <SimpleForm>\n *             <BooleanInput source=\"hasEmail\" />\n *             <FormDataConsumer>\n *                 {({ formData, ...rest }) => formData.hasEmail &&\n *                      <TextInput source=\"email\" {...rest} />\n *                 }\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * @example\n *\n * const OrderEdit = (props) => (\n *     <Edit {...props}>\n *         <SimpleForm>\n *             <SelectInput source=\"country\" choices={countries} />\n *             <FormDataConsumer>\n *                 {({ formData, ...rest }) =>\n *                      <SelectInput\n *                          source=\"city\"\n *                          choices={getCitiesFor(formData.country)}\n *                          {...rest}\n *                      />\n *                 }\n *             </FormDataConsumer>\n *         </SimpleForm>\n *     </Edit>\n * );\n */\nconst FormDataConsumer = (props: ConnectedProps) => {\n    const formData = useWatch();\n\n    return <FormDataConsumerView formData={formData} {...props} />;\n};\n\nexport const FormDataConsumerView = (props: Props) => {\n    const { children, form, formData, source, index, ...rest } = props;\n    let scopedFormData = formData;\n    let getSource;\n    let getSourceHasBeenCalled = false;\n    let ret;\n\n    // If we have an index, we are in an iterator like component (such as the SimpleFormIterator)\n    if (typeof index !== 'undefined') {\n        scopedFormData = get(formData, source);\n        getSource = (scopedSource: string) => {\n            getSourceHasBeenCalled = true;\n            return `${source}.${scopedSource}`;\n        };\n        ret = children({ formData, scopedFormData, getSource, ...rest });\n    } else {\n        ret = children({ formData, ...rest });\n    }\n\n    warning(\n        typeof index !== 'undefined' && ret && !getSourceHasBeenCalled,\n        `You're using a FormDataConsumer inside an ArrayInput and you did not call the getSource function supplied by the FormDataConsumer component. This is required for your inputs to get the proper source.\n\n<ArrayInput source=\"users\">\n    <SimpleFormIterator>\n        <TextInput source=\"name\" />\n\n        <FormDataConsumer>\n            {({\n                formData, // The whole form data\n                scopedFormData, // The data for this item of the ArrayInput\n                getSource, // A function to get the valid source inside an ArrayInput\n                ...rest,\n            }) =>\n                scopedFormData.name ? (\n                    <SelectInput\n                        source={getSource('role')} // Will translate to \"users[0].role\"\n                        choices={[{id: 1, name: 'Admin'}, {id: 2, name: 'User'},\n                        {...rest}\n                    />\n                ) : null\n            }\n        </FormDataConsumer>\n    </SimpleFormIterator>\n</ArrayInput>`\n    );\n\n    return ret === undefined ? null : ret;\n};\n\nexport default FormDataConsumer;\n\nexport interface FormDataConsumerRenderParams {\n    formData: any;\n    scopedFormData?: any;\n    getSource?: (source: string) => string;\n}\n\nexport type FormDataConsumerRender = (\n    params: FormDataConsumerRenderParams\n) => ReactNode;\n\ninterface ConnectedProps {\n    children: FormDataConsumerRender;\n    form?: string;\n    record?: any;\n    source?: string;\n    [key: string]: any;\n}\n\ninterface Props extends ConnectedProps {\n    formData: any;\n    index?: number;\n}\n","import { createContext } from 'react';\n\nexport const FormGroupsContext = createContext<FormGroupsContextValue>(\n    undefined\n);\n\nexport type FormGroupSubscriber = () => void;\n\nexport type FormGroupsContextValue = {\n    registerGroup: (name: string) => void;\n    unregisterGroup: (name: string) => void;\n    registerField: (source: string, group?: string) => void;\n    unregisterField: (source: string, group?: string) => void;\n    getGroupFields: (name: string) => string[];\n    /**\n     * Subscribe to any changes of the group content (fields added or removed).\n     * Subscribers can get the current fields of the group by calling getGroupFields.\n     * Returns a function to unsubscribe.\n     */\n    subscribe: (name: string, subscriber: FormGroupSubscriber) => () => void;\n};\n","import * as React from 'react';\nimport {\n    ValidationErrorMessage,\n    ValidationErrorMessageWithArgs,\n} from './validate';\nimport { useTranslate } from '../i18n';\n\nexport interface ValidationErrorProps {\n    error: ValidationErrorMessage;\n}\n\nconst ValidationError = (props: ValidationErrorProps) => {\n    const { error } = props;\n    const translate = useTranslate();\n    if ((error as ValidationErrorMessageWithArgs).message) {\n        const { message, args } = error as ValidationErrorMessageWithArgs;\n        return <>{translate(message, { _: message, ...args })}</>;\n    }\n\n    return <>{translate(error as string, { _: error })}</>;\n};\n\nexport default ValidationError;\n","import { FieldValues } from 'react-hook-form';\nimport _ from 'lodash';\n\n// Flattening an object into path keys:\n// https://github.com/lodash/lodash/issues/2240#issuecomment-418820848\nexport const flattenKeys = (obj, path = []) =>\n    !_.isObject(obj)\n        ? { [path.join('.')]: obj }\n        : _.reduce(\n              obj,\n              (cum, next, key) =>\n                  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                  _.merge(cum, flattenKeys(next, [...path, key])),\n              {}\n          );\n\n/**\n * Convert a simple validation function that returns an object matching the form shape with errors\n * to a validation resolver compatible with react-hook-form.\n *\n * @example\n * const validate = (values: any) => {\n *     if (values.username == null || values.username.trim() === '') {\n *         return { username: 'Required' };\n *     }\n * }\n *\n * const validationResolver = getSimpleValidationResolver(validate);\n *\n * const UserForm = () => (\n *     <Form\n *         defaultValues={{ username: 'John' }}\n *         validationResolver={validationResolver}\n *     >\n *         <TextField source=\"username\" />\n *     </Form>\n * );\n */\nexport const getSimpleValidationResolver = (validate: ValidateForm) => async (\n    data: FieldValues\n) => {\n    const errors = await validate(data);\n\n    if (!errors || Object.getOwnPropertyNames(errors).length === 0) {\n        return { values: data, errors: {} };\n    }\n    const flattenedErrors = flattenKeys(errors);\n\n    return {\n        values: {},\n        errors: Object.keys(flattenedErrors).reduce(\n            (acc, field) => ({\n                ...acc,\n                [field]: {\n                    type: 'manual',\n                    message: flattenedErrors[field],\n                },\n            }),\n            {} as FieldValues\n        ),\n    };\n};\n\nexport type ValidateForm = (\n    data: FieldValues\n) => FieldValues | Promise<FieldValues>;\n","import { createContext } from 'react';\nimport { FilterPayload, RaRecord, SortPayload } from '../../types';\n\n/**\n * Context to store choices and functions to retrieve them.\n *\n * Use the useChoicesContext() hook to read the context.\n */\nexport const ChoicesContext = createContext<ChoicesContextValue>(undefined);\n\nexport type ChoicesContextValue<RecordType extends RaRecord = any> = {\n    allChoices: RecordType[];\n    availableChoices: RecordType[];\n    displayedFilters: any;\n    error?: any;\n    filter?: FilterPayload;\n    filterValues: any;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n    hideFilter: (filterName: string) => void;\n    isFetching: boolean;\n    isLoading: boolean;\n    page: number;\n    perPage: number;\n    refetch: () => void;\n    resource: string;\n    selectedChoices: RecordType[];\n    setFilters: (\n        filters: any,\n        displayedFilters: any,\n        debounce?: boolean\n    ) => void;\n    setPage: (page: number) => void;\n    setPerPage: (page: number) => void;\n    setSort: (sort: SortPayload) => void;\n    showFilter: (filterName: string, defaultValue: any) => void;\n    sort: SortPayload;\n    source: string;\n    total: number;\n};\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { ChoicesContext, ChoicesContextValue } from './ChoicesContext';\n\nexport const ChoicesContextProvider = ({\n    children,\n    value,\n}: {\n    children: ReactNode;\n    value: ChoicesContextValue;\n}) => (\n    <ChoicesContext.Provider value={value}>{children}</ChoicesContext.Provider>\n);\n","import { useContext, useMemo } from 'react';\nimport { RaRecord } from '../../types';\nimport { useList } from '../../controller';\nimport { ChoicesContext, ChoicesContextValue } from './ChoicesContext';\n\nexport const useChoicesContext = <ChoicesType extends RaRecord = RaRecord>(\n    options: Partial<ChoicesContextValue> & { choices?: ChoicesType[] } = {}\n): ChoicesContextValue => {\n    const context = useContext(ChoicesContext) as ChoicesContextValue<\n        ChoicesType\n    >;\n    const { data, ...list } = useList<ChoicesType>({ data: options.choices });\n    const result = useMemo(\n        () => ({\n            allChoices: context?.allChoices ?? data,\n            availableChoices:\n                context?.availableChoices ?? options.availableChoices ?? data,\n            selectedChoices:\n                context?.selectedChoices ?? options.selectedChoices ?? data,\n            displayedFilters:\n                context?.displayedFilters ??\n                options.displayedFilters ??\n                list.displayedFilters,\n            error: context?.error ?? options.error ?? list.error,\n            filter: context?.filter ?? options.filter ?? list.filter,\n            filterValues:\n                context?.filterValues ??\n                options.filterValues ??\n                list.filterValues,\n            hasNextPage:\n                context?.hasNextPage ?? options.hasNextPage ?? list.hasNextPage,\n            hasPreviousPage:\n                context?.hasPreviousPage ??\n                options.hasPreviousPage ??\n                list.hasPreviousPage,\n            hideFilter:\n                context?.hideFilter ?? options.hideFilter ?? list.hideFilter,\n            isFetching:\n                context?.isFetching ?? options.isFetching ?? list.isFetching,\n            isLoading:\n                context?.isLoading ?? options.isLoading ?? list.isLoading,\n            page: context?.page ?? options.page ?? list.page,\n            perPage: context?.perPage ?? options.perPage ?? list.perPage,\n            refetch: context?.refetch ?? options.refetch ?? list.refetch,\n            resource: context?.resource ?? options.resource ?? list.resource,\n            setFilters:\n                context?.setFilters ?? options.setFilters ?? list.setFilters,\n            setPage: context?.setPage ?? options.setPage ?? list.setPage,\n            setPerPage:\n                context?.setPerPage ?? options.setPerPage ?? list.setPerPage,\n            setSort: context?.setSort ?? options.setSort ?? list.setSort,\n            showFilter:\n                context?.showFilter ?? options.showFilter ?? list.showFilter,\n            sort: context?.sort ?? options.sort ?? list.sort,\n            source: context?.source ?? options.source,\n            total: context?.total ?? options.total ?? list.total,\n        }),\n        [context, data, list, options]\n    );\n\n    return result;\n};\n","import * as React from 'react';\nimport { ReactNode } from 'react';\nimport { FormProvider, FieldValues, UseFormProps } from 'react-hook-form';\n\nimport { FormGroupsProvider } from './FormGroupsProvider';\nimport { RaRecord } from '../types';\nimport { useRecordContext, OptionalRecordContextProvider } from '../controller';\nimport { ValidateForm } from './getSimpleValidationResolver';\nimport { useAugmentedForm } from './useAugmentedForm';\n\n/**\n * Creates a form element, initialized with the current record, calling the saveContext on submit\n *\n * Wrapper around react-hook-form's useForm, FormContextProvider, and <form>.\n * Also sets up a FormGroupContext, and handles submission validation.\n *\n * @example\n *\n * const MyForm = ({ record, defaultValues, validate }) => (\n *    <Form record={record} defaultValues={defaultValues} validate={validate}>\n *        <Stack>\n *            <TextInput source=\"title\" />\n *            <SaveButton />\n *        </Stack>\n *    </Form>\n * );\n *\n * @typedef {Object} Props the props you can use\n * @prop {Object} defaultValues\n * @prop {Function} validate\n * @prop {Function} save\n *\n * @see useForm\n * @see FormGroupContext\n *\n * @link https://react-hook-form.com/api/useformcontext\n */\nexport const Form = (props: FormProps) => {\n    const { children, id, className, noValidate = false } = props;\n    const record = useRecordContext(props);\n    const { form, formHandleSubmit } = useAugmentedForm(props);\n\n    return (\n        <OptionalRecordContextProvider value={record}>\n            <FormProvider {...form}>\n                <FormGroupsProvider>\n                    <form\n                        onSubmit={formHandleSubmit}\n                        noValidate={noValidate}\n                        id={id}\n                        className={className}\n                    >\n                        {children}\n                    </form>\n                </FormGroupsProvider>\n            </FormProvider>\n        </OptionalRecordContextProvider>\n    );\n};\n\nexport type FormProps = FormOwnProps &\n    Omit<UseFormProps, 'onSubmit'> & {\n        validate?: ValidateForm;\n        noValidate?: boolean;\n    };\n\nexport interface FormOwnProps {\n    children: ReactNode;\n    className?: string;\n    defaultValues?: any;\n    formRootPathname?: string;\n    id?: string;\n    record?: Partial<RaRecord>;\n    onSubmit?: (data: FieldValues) => any | Promise<any>;\n    warnWhenUnsavedChanges?: boolean;\n}\n","import * as React from 'react';\nimport { ReactNode, useMemo, useRef } from 'react';\nimport {\n    FormGroupsContext,\n    FormGroupsContextValue,\n    FormGroupSubscriber,\n} from './FormGroupsContext';\n\n/**\n * This component provides functions through context to manage form groups,\n * allowing to link or unlink an input to a group.\n * @see FormGroupContextProvider\n * @see useFormGroup\n * @see useFormGroups\n */\nexport const FormGroupsProvider = ({ children }: { children: ReactNode }) => {\n    const formGroups = useRef<{ [key: string]: string[] }>({});\n    const subscribers = useRef<{\n        [key: string]: FormGroupSubscriber[];\n    }>({});\n\n    const formContextValue = useMemo<FormGroupsContextValue>(\n        () => ({\n            /**\n             * Register a subscriber function for the specified group. The subscriber\n             * will be called whenever the group content changes (fields added or removed).\n             */\n            subscribe: (group, subscriber) => {\n                if (!subscribers.current[group]) {\n                    subscribers.current[group] = [];\n                }\n                subscribers.current[group].push(subscriber);\n\n                return () => {\n                    subscribers.current[group] = subscribers.current[\n                        group\n                    ].filter(s => s !== subscriber);\n                };\n            },\n            getGroupFields: name => formGroups.current[name] || [],\n            registerGroup: name => {\n                formGroups.current[name] = formGroups.current[name] || [];\n            },\n            unregisterGroup: name => {\n                delete formGroups[name];\n            },\n            registerField: (source, group) => {\n                if (group != null) {\n                    if (!(formGroups.current[group] || []).includes(source)) {\n                        formGroups.current[group] = [\n                            ...(formGroups.current[group] || []),\n                            source,\n                        ];\n                        // Notify subscribers that the group fields have changed\n                        if (subscribers.current[group]) {\n                            subscribers.current[group].forEach(subscriber =>\n                                subscriber()\n                            );\n                        }\n                    }\n                }\n            },\n            unregisterField: (source, group) => {\n                if (group != null) {\n                    if (!formGroups.current[group]) {\n                        console.warn(`Invalid form group ${group}`);\n                    } else {\n                        const fields = new Set(formGroups.current[group]);\n                        fields.delete(source);\n                        formGroups.current[group] = Array.from(fields);\n\n                        // Notify subscribers that the group fields have changed\n                        if (subscribers.current[group]) {\n                            subscribers.current[group].forEach(subscriber =>\n                                subscriber()\n                            );\n                        }\n                    }\n                }\n            },\n        }),\n        []\n    );\n\n    return (\n        <FormGroupsContext.Provider value={formContextValue}>\n            {children}\n        </FormGroupsContext.Provider>\n    );\n};\n","import { BaseSyntheticEvent, useCallback, useMemo, useEffect } from 'react';\nimport { FieldValues, useForm, UseFormProps } from 'react-hook-form';\n\nimport { RaRecord } from '../types';\nimport { useSaveContext } from '../controller';\nimport { useRecordContext } from '../controller';\nimport getFormInitialValues from './getFormInitialValues';\nimport {\n    getSimpleValidationResolver,\n    ValidateForm,\n} from './getSimpleValidationResolver';\nimport { setSubmissionErrors } from './setSubmissionErrors';\nimport { useNotify } from '../notification';\nimport { useIsFormInvalid } from './useIsFormInvalid';\nimport { useWarnWhenUnsavedChanges } from './useWarnWhenUnsavedChanges';\n\n/**\n * Wrapper around react-hook-form's useForm\n *\n * This hook adds the following features to react-hook-form's useForm:\n *\n * - form initialization based on RecordContext\n * - validation based on a validate function\n * - notification on invalid form\n * - stop form submission event propagation\n */\nexport const useAugmentedForm = (props: UseAugmentedFormProps) => {\n    const {\n        context,\n        criteriaMode = 'firstError',\n        defaultValues,\n        delayError,\n        formRootPathname,\n        mode,\n        resolver,\n        reValidateMode = 'onChange',\n        onSubmit,\n        shouldFocusError,\n        shouldUnregister,\n        shouldUseNativeValidation,\n        warnWhenUnsavedChanges,\n        validate,\n    } = props;\n    const record = useRecordContext(props);\n    const saveContext = useSaveContext();\n\n    const defaultValuesIncludingRecord = useMemo(\n        () => getFormInitialValues(defaultValues, record),\n        [JSON.stringify({ defaultValues, record })] // eslint-disable-line\n    );\n\n    const finalResolver = resolver\n        ? resolver\n        : validate\n        ? getSimpleValidationResolver(validate)\n        : undefined;\n\n    const form = useForm({\n        context,\n        criteriaMode,\n        defaultValues: defaultValuesIncludingRecord,\n        delayError,\n        mode,\n        reValidateMode,\n        resolver: finalResolver,\n        shouldFocusError,\n        shouldUnregister,\n        shouldUseNativeValidation,\n    });\n\n    // initialize form with record\n    useEffect(() => {\n        if (!record) {\n            return;\n        }\n        const initialValues = getFormInitialValues(defaultValues, record);\n        form.reset(initialValues);\n    }, [form.reset, JSON.stringify(record, defaultValues)]); // eslint-disable-line react-hooks/exhaustive-deps\n\n    // notify on invalid form\n    const isInvalid = useIsFormInvalid(form.control);\n    const notify = useNotify();\n    useEffect(() => {\n        if (isInvalid) {\n            notify('ra.message.invalid_form', { type: 'warning' });\n        }\n    }, [isInvalid, notify]);\n\n    // warn when unsaved change\n    useWarnWhenUnsavedChanges(\n        warnWhenUnsavedChanges,\n        formRootPathname,\n        form.control\n    );\n\n    // submit callbacks\n    const handleSubmit = useCallback(\n        async values => {\n            let errors;\n\n            if (onSubmit) {\n                errors = await onSubmit(values);\n            }\n            if (onSubmit == null && saveContext?.save) {\n                errors = await saveContext.save(values);\n            }\n            if (errors != null) {\n                setSubmissionErrors(errors, form.setError);\n            }\n        },\n        [form, onSubmit, saveContext]\n    );\n\n    const formHandleSubmit = useCallback(\n        (event: BaseSyntheticEvent) => {\n            // Prevent outer forms to receive the event\n            event.stopPropagation();\n            form.handleSubmit(handleSubmit)(event);\n            return;\n        },\n        [form, handleSubmit]\n    );\n\n    return {\n        form,\n        handleSubmit,\n        formHandleSubmit,\n        isInvalid,\n    };\n};\n\nexport type UseAugmentedFormProps = UseFormOwnProps &\n    Omit<UseFormProps, 'onSubmit'> & {\n        validate?: ValidateForm;\n    };\n\nexport interface UseFormOwnProps {\n    defaultValues?: any;\n    formRootPathname?: string;\n    record?: Partial<RaRecord>;\n    onSubmit?: (data: FieldValues) => any | Promise<any>;\n    warnWhenUnsavedChanges?: boolean;\n}\n","import merge from 'lodash/merge';\nimport { RaRecord } from '../types';\n\nexport default function getFormInitialValues(\n    defaultValues: DefaultValue,\n    record: Partial<RaRecord>\n) {\n    const finalInitialValues = merge(\n        {},\n        getValues(defaultValues, record),\n        record\n    );\n    return finalInitialValues;\n}\n\nfunction getValues(values, record) {\n    if (typeof values === 'object') {\n        return values;\n    }\n\n    if (typeof values === 'function') {\n        return values(record);\n    }\n\n    return {};\n}\n\ninterface DefaultValueObject {\n    [key: string]: any;\n}\ntype DefaultValueFunction = (record: RaRecord) => DefaultValueObject;\ntype DefaultValue = DefaultValueObject | DefaultValueFunction;\n","import { FieldValues, UseFormSetError } from 'react-hook-form';\n\n/**\n * This internal function is used to convert an object matching the form shape with errors to a\n * format compatible with react-hook-form. It's used to handle submission errors. Only useful when\n * you are implementing a custom form without leveraging our Form component.\n *\n * @example\n * const MyForm = () => {\n *     const { register, handleSubmit, setError } = useForm();\n *     const onSubmit = data => {\n *         return saveAsync(data).catch(error => setSubmissionErrors(error.body.details));\n *     };\n *\n *     return (\n *         <form onSubmit={handleSubmit(onSubmit)}>\n *             ...\n *         </form>\n *     );\n * };\n */\nexport const setSubmissionErrors = (\n    errors: FieldValues,\n    setError: UseFormSetError<FieldValues>\n) => {\n    const setErrorFromArray = (errors: any[], rootPath: string) => {\n        errors.forEach((error, index) => {\n            if (typeof error === 'object') {\n                setErrorFromObject(error, `${rootPath}.${index}.`);\n                return;\n            }\n            if (Array.isArray(error)) {\n                setErrorFromArray(error, `${rootPath}.${index}.`);\n                return;\n            }\n            setError(`${rootPath}.${index}`, {\n                type: 'server',\n                message: error.toString(),\n            });\n        });\n    };\n    const setErrorFromObject = (errors: any, rootPath: string) => {\n        Object.entries(errors).forEach(([name, error]) => {\n            if (typeof error === 'object') {\n                setErrorFromObject(error, `${rootPath}${name}.`);\n                return;\n            }\n            if (Array.isArray(error)) {\n                setErrorFromArray(error, `${rootPath}${name}.`);\n                return;\n            }\n            setError(`${rootPath}${name}`, {\n                type: 'server',\n                message: error.toString(),\n            });\n        });\n    };\n    setErrorFromObject(errors, '');\n};\n","import { useEffect, useState, useRef } from 'react';\nimport { useFormState, Control } from 'react-hook-form';\n\n/**\n * This hook returns a boolean indicating whether the form is invalid.\n * We use this to display an error message on submit in Form and SaveButton.\n *\n * We can't do the form validity check in the form submit handler\n * as the form state may not have been updated yet when onSubmit validation mode is enabled\n * or when the form hasn't been touched at all.\n */\nexport const useIsFormInvalid = (control?: Control) => {\n    const [isInvalid, setIsInvalid] = useState(false);\n    const { isValid, submitCount, errors } = useFormState(\n        control ? { control } : undefined\n    );\n    const submitCountRef = useRef(submitCount);\n\n    useEffect(() => {\n        // Checking the submit count allows us to only display the notification after users\n        // tried to submit\n        if (submitCount > submitCountRef.current) {\n            submitCountRef.current = submitCount;\n\n            // For some reason, the validation state might not be sync yet on first submit\n            // so we need to check if there are actually some errors even though the isValid is false\n            if (Object.keys(errors).length > 0 && !isValid) {\n                setIsInvalid(true);\n            } else {\n                setIsInvalid(false);\n            }\n        }\n    }, [errors, isValid, submitCount]);\n\n    return isInvalid;\n};\n","import { useContext, useEffect, useRef } from 'react';\nimport { useFormState, Control } from 'react-hook-form';\nimport { UNSAFE_NavigationContext, useLocation } from 'react-router-dom';\nimport { History, Transition } from 'history';\nimport { useTranslate } from '../i18n';\n\n/**\n * Display a confirmation dialog if the form has unsaved changes.\n * - If the user confirms, the navigation continues and the changes are lost.\n * - If the user cancels, the navigation is cancelled and the changes are kept.\n */\nexport const useWarnWhenUnsavedChanges = (\n    enable: boolean,\n    formRootPathname?: string,\n    control?: Control\n) => {\n    // react-router v6 does not yet provide a way to block navigation\n    // This is planned for a future release\n    // See https://github.com/remix-run/react-router/issues/8139\n    const navigator = useContext(UNSAFE_NavigationContext).navigator as History;\n    const location = useLocation();\n    const translate = useTranslate();\n    const { isSubmitSuccessful, isSubmitting, dirtyFields } = useFormState(\n        control ? { control } : undefined\n    );\n    const isDirty = Object.keys(dirtyFields).length > 0;\n    const initialLocation = useRef(formRootPathname || location.pathname);\n\n    useEffect(() => {\n        if (!enable || !isDirty) return;\n\n        let unblock = navigator.block((tx: Transition) => {\n            const newLocationIsInsideForm = tx.location.pathname.startsWith(\n                initialLocation.current\n            );\n\n            if (\n                !isSubmitting &&\n                (newLocationIsInsideForm ||\n                    isSubmitSuccessful ||\n                    window.confirm(translate('ra.message.unsaved_changes')))\n            ) {\n                unblock();\n                tx.retry();\n            }\n        });\n\n        return unblock;\n    }, [\n        enable,\n        location,\n        navigator,\n        isDirty,\n        isSubmitting,\n        isSubmitSuccessful,\n        translate,\n    ]);\n};\n","import lodashMemoize from 'lodash/memoize';\n\n/* eslint-disable no-underscore-dangle */\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\nconst EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\n\nconst isEmpty = (value: any) =>\n    typeof value === 'undefined' ||\n    value === null ||\n    value === '' ||\n    (Array.isArray(value) && value.length === 0);\n\nexport interface ValidationErrorMessageWithArgs {\n    message: string;\n    args: {\n        [key: string]: ValidationErrorMessageWithArgs | any;\n    };\n}\n\nexport type ValidationErrorMessage = string | ValidationErrorMessageWithArgs;\n\nexport type Validator = (\n    value: any,\n    values: any,\n    props: any\n) =>\n    | ValidationErrorMessage\n    | null\n    | undefined\n    | Promise<ValidationErrorMessage | null | undefined>;\n\n// type predicate, see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\nfunction isValidationErrorMessageWithArgs(\n    error: ReturnType<Validator>\n): error is ValidationErrorMessageWithArgs {\n    return error.hasOwnProperty('message');\n}\n\ninterface MessageFuncParams {\n    args: any;\n    value: any;\n    values: any;\n}\n\ntype MessageFunc = (params: MessageFuncParams) => ValidationErrorMessage;\n\nconst getMessage = (\n    message: string | MessageFunc,\n    messageArgs: any,\n    value: any,\n    values: any\n) =>\n    typeof message === 'function'\n        ? message({\n              args: messageArgs,\n              value,\n              values,\n          })\n        : messageArgs\n        ? {\n              message,\n              args: messageArgs,\n          }\n        : message;\n\ntype Memoize = <T extends (...args: any[]) => any>(\n    func: T,\n    resolver?: (...args: any[]) => any\n) => T;\n\n// If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\nconst memoize: Memoize = (fn: any) =>\n    lodashMemoize(fn, (...args) => JSON.stringify(args));\n\nconst isFunction = value => typeof value === 'function';\n\nexport const combine2Validators = (\n    validator1: Validator,\n    validator2: Validator\n): Validator => {\n    return (value, values, meta) => {\n        const result1 = validator1(value, values, meta);\n        if (!result1) {\n            return validator2(value, values, meta);\n        }\n        if (\n            typeof result1 === 'string' ||\n            isValidationErrorMessageWithArgs(result1)\n        ) {\n            return result1;\n        }\n\n        return result1.then(resolvedResult1 => {\n            if (!resolvedResult1) {\n                return validator2(value, values, meta);\n            }\n            return resolvedResult1;\n        });\n    };\n};\n\n// Compose multiple validators into a single one for use with react-hook-form\nexport const composeValidators = (...validators) => {\n    const allValidators = (Array.isArray(validators[0])\n        ? validators[0]\n        : validators\n    ).filter(isFunction) as Validator[];\n    return allValidators.reduce(combine2Validators, () => null);\n};\n\n// Compose multiple validators into a single one for use with react-hook-form\nexport const composeSyncValidators = (...validators) => (\n    value,\n    values,\n    meta\n) => {\n    const allValidators = (Array.isArray(validators[0])\n        ? validators[0]\n        : validators\n    ).filter(isFunction) as Validator[];\n\n    for (const validator of allValidators) {\n        const error = validator(value, values, meta);\n\n        if (error) {\n            return error;\n        }\n    }\n};\n\n/**\n * Required validator\n *\n * Returns an error if the value is null, undefined, or empty\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const titleValidators = [required('The title is required')];\n * <TextInput name=\"title\" validate={titleValidators} />\n */\nexport const required = memoize((message = 'ra.validation.required') =>\n    Object.assign(\n        (value, values) =>\n            isEmpty(value)\n                ? getMessage(message, undefined, value, values)\n                : undefined,\n        { isRequired: true }\n    )\n);\n\n/**\n * Minimum length validator\n *\n * Returns an error if the value has a length less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\n */\nexport const minLength = memoize(\n    (min, message = 'ra.validation.minLength') => (value, values) =>\n        !isEmpty(value) && value.length < min\n            ? getMessage(message, { min }, value, values)\n            : undefined\n);\n\n/**\n * Maximum length validator\n *\n * Returns an error if the value has a length higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\n * <TextInput name=\"name\" validate={nameValidators} />\n */\nexport const maxLength = memoize(\n    (max, message = 'ra.validation.maxLength') => (value, values) =>\n        !isEmpty(value) && value.length > max\n            ? getMessage(message, { max }, value, values)\n            : undefined\n);\n\n/**\n * Minimum validator\n *\n * Returns an error if the value is less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [minValue(5, 'Should be more than 5')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport const minValue = memoize(\n    (min, message = 'ra.validation.minValue') => (value, values) =>\n        !isEmpty(value) && value < min\n            ? getMessage(message, { min }, value, values)\n            : undefined\n);\n\n/**\n * Maximum validator\n *\n * Returns an error if the value is higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport const maxValue = memoize(\n    (max, message = 'ra.validation.maxValue') => (value, values) =>\n        !isEmpty(value) && value > max\n            ? getMessage(message, { max }, value, values)\n            : undefined\n);\n\n/**\n * Number validator\n *\n * Returns an error if the value is not a number\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const ageValidators = [number('Must be a number')];\n * <TextInput name=\"age\" validate={ageValidators} />\n */\nexport const number = memoize(\n    (message = 'ra.validation.number') => (value, values) =>\n        !isEmpty(value) && isNaN(Number(value))\n            ? getMessage(message, undefined, value, values)\n            : undefined\n);\n\n/**\n * Regular expression validator\n *\n * Returns an error if the value does not match the pattern given as parameter\n *\n * @param {RegExp} pattern\n * @param {string|Function} message\n *\n * @example\n *\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\n * <TextInput name=\"zip\" validate={zipValidators} />\n */\nexport const regex = lodashMemoize(\n    (pattern, message = 'ra.validation.regex') => (value, values?) =>\n        !isEmpty(value) && typeof value === 'string' && !pattern.test(value)\n            ? getMessage(message, { pattern }, value, values)\n            : undefined,\n    (pattern, message) => {\n        return pattern.toString() + message;\n    }\n);\n\n/**\n * Email validator\n *\n * Returns an error if the value is not a valid email\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const emailValidators = [email('Must be an email')];\n * <TextInput name=\"email\" validate={emailValidators} />\n */\nexport const email = memoize((message = 'ra.validation.email') =>\n    regex(EMAIL_REGEX, message)\n);\n\nconst oneOfTypeMessage: MessageFunc = ({ args }) => ({\n    message: 'ra.validation.oneOf',\n    args,\n});\n\n/**\n * Choices validator\n *\n * Returns an error if the value is not among the list passed as parameter\n *\n * @param {array} list\n * @param {string|Function} message\n *\n * @example\n *\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\n * <TextInput name=\"gender\" validate={genderValidators} />\n */\nexport const choices = memoize(\n    (list, message = oneOfTypeMessage) => (value, values) =>\n        !isEmpty(value) && list.indexOf(value) === -1\n            ? getMessage(message, { list }, value, values)\n            : undefined\n);\n\n/**\n * Given a validator, returns a boolean indicating whether the field is required or not.\n */\nexport const isRequired = validate => {\n    if (validate && validate.isRequired) {\n        return true;\n    }\n    if (Array.isArray(validate)) {\n        return !!validate.find(it => it.isRequired);\n    }\n    return false;\n};\n","import { createContext } from 'react';\n\n/**\n * Context allowing inputs to register to a specific group.\n * This enables other components in the group to access group properties such as its\n * validation (valid/invalid) or whether its inputs have been updated (dirty/pristine).\n *\n * This should only be used through a FormGroupContextProvider.\n */\nexport const FormGroupContext = createContext<FormGroupContextValue>(undefined);\n\nexport type FormGroupContextValue = string;\n","import * as React from 'react';\nimport { ReactNode, useEffect } from 'react';\nimport { FormGroupContext } from './FormGroupContext';\nimport { useFormGroups } from './useFormGroups';\n\n/**\n * This provider allows its input children to register to a specific group.\n * This enables other components in the group to access group properties such as its\n * validation (valid/invalid) or whether its inputs have been updated (dirty/pristine).\n *\n * @example\n * import { Edit, SimpleForm, TextInput, FormGroupContextProvider, useFormGroup } from 'react-admin';\n * import { Accordion, AccordionDetails, AccordionSummary, Typography } from '@mui/material';\n *\n * const PostEdit = (props) => (\n *     <Edit {...props}>\n *         <SimpleForm>\n *             <TextInput source=\"title\" />\n *             <FormGroupContextProvider name=\"options\">\n *                 <Accordion>\n *                     <AccordionSummary\n *                         expandIcon={<ExpandMoreIcon />}\n *                         aria-controls=\"options-content\"\n *                         id=\"options-header\"\n *                     >\n *                         <AccordionSectionTitle name=\"options\">Options</AccordionSectionTitle>\n *                     </AccordionSummary>\n *                     <AccordionDetails id=\"options-content\" aria-labelledby=\"options-header\">\n *                         <TextInput source=\"teaser\" validate={minLength(20)} />\n *                     </AccordionDetails>\n *                 </Accordion>\n *             </FormGroupContextProvider>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * const AccordionSectionTitle = ({ children, name }) => {\n *     const formGroupState = useFormGroup(name);\n *     return (\n *         <Typography color={formGroupState.invalid && formGroupState.dirty ? 'error' : 'inherit'}>\n *             {children}\n *         </Typography>\n *     );\n * }\n *\n * @param props The component props\n * @param {ReactNode} props.children The form group content\n * @param {String} props.name The form group name\n */\nexport const FormGroupContextProvider = ({\n    children,\n    name,\n}: {\n    children: ReactNode;\n    name: string;\n}) => {\n    const formGroups = useFormGroups();\n\n    useEffect(() => {\n        if (\n            !formGroups ||\n            !formGroups.registerGroup ||\n            !formGroups.unregisterGroup\n        ) {\n            console.warn(\n                `The FormGroupContextProvider can only be used inside a FormContext such as provided by the SimpleForm and TabbedForm components`\n            );\n            return;\n        }\n        formGroups.registerGroup(name);\n\n        return () => {\n            formGroups.unregisterGroup(name);\n        };\n    }, [formGroups, name]);\n\n    return (\n        <FormGroupContext.Provider value={name}>\n            {children}\n        </FormGroupContext.Provider>\n    );\n};\n","import { useContext } from 'react';\nimport { FormGroupsContext } from './FormGroupsContext';\n\n/**\n * Retrieve the form groups management context. Used by inputs to register themselves into a form group.\n */\nexport const useFormGroups = () => {\n    const context = useContext(FormGroupsContext);\n    return context;\n};\n","import { useEffect } from 'react';\nimport { useFormContext } from 'react-hook-form';\nimport get from 'lodash/get';\nimport { useRecordContext } from '../controller';\nimport { InputProps } from './useInput';\n\n/*\n * This hook updates the input default value whenever the record changes\n * It applies either the record value if it has one or the defaultValue if it was specified\n */\nexport const useApplyInputDefaultValues = (props: Partial<InputProps>) => {\n    const { defaultValue, source } = props;\n    const record = useRecordContext(props);\n    const { getValues, resetField } = useFormContext();\n    const recordValue = get(record, source);\n    const formValue = get(getValues(), source);\n\n    useEffect(() => {\n        if (defaultValue == null) return;\n        if (formValue == null && recordValue == null) {\n            // special case for ArrayInput: since we use get(record, source),\n            // if source is like foo.23.bar, this effect will run.\n            // but we only want to set the default value for the subfield bar\n            // if the record actually has a value for foo.23\n            const pathContainsIndex = source\n                .split('.')\n                .some(pathPart => numericRegex.test(pathPart));\n            if (pathContainsIndex) {\n                const parentPath = source.split('.').slice(0, -1).join('.');\n                const parentValue = get(getValues(), parentPath);\n                if (parentValue == null) {\n                    // the parent is undefined, so we don't want to set the default value\n                    return;\n                }\n            }\n            resetField(source, { defaultValue });\n        }\n    });\n};\n\nconst numericRegex = /^\\d+$/;\n","import * as React from 'react';\nimport { ReactElement, isValidElement, useCallback } from 'react';\nimport get from 'lodash/get';\n\nimport { useTranslate } from '../i18n';\nimport { RaRecord } from '../types';\nimport { RecordContextProvider } from '../controller';\n\nexport type OptionTextElement = ReactElement<{\n    record: RaRecord;\n}>;\nexport type OptionTextFunc = (choice: any) => string | OptionTextElement;\nexport type OptionText = OptionTextElement | OptionTextFunc | string;\n\nexport interface ChoicesProps {\n    choices?: any[];\n    isFetching?: boolean;\n    isLoading?: boolean;\n    optionValue?: string;\n    optionText?: OptionText;\n    translateChoice?: boolean;\n}\n\nexport interface UseChoicesOptions {\n    optionValue?: string;\n    optionText?: OptionText;\n    disableValue?: string;\n    translateChoice?: boolean;\n}\n\n/*\n * Returns helper functions for choices handling.\n *\n * @param optionText Either a string defining the property to use to get the choice text, a function or a React element\n * @param optionValue The property to use to get the choice value\n * @param translateChoice A boolean indicating whether to option text should be translated\n *\n * @returns An object with helper functions:\n * - getChoiceText: Returns the choice text or a React element\n * - getChoiceValue: Returns the choice value\n */\nexport const useChoices = ({\n    optionText = 'name',\n    optionValue = 'id',\n    disableValue = 'disabled',\n    translateChoice = true,\n}: UseChoicesOptions) => {\n    const translate = useTranslate();\n\n    const getChoiceText = useCallback(\n        choice => {\n            if (isValidElement<{ record: any }>(optionText)) {\n                return (\n                    <RecordContextProvider value={choice}>\n                        {optionText}\n                    </RecordContextProvider>\n                );\n            }\n            const choiceName =\n                typeof optionText === 'function'\n                    ? optionText(choice)\n                    : get(choice, optionText);\n\n            return isValidElement(choiceName)\n                ? choiceName\n                : translateChoice\n                ? translate(String(choiceName), { _: choiceName })\n                : String(choiceName);\n        },\n        [optionText, translate, translateChoice]\n    );\n\n    const getChoiceValue = useCallback(choice => get(choice, optionValue), [\n        optionValue,\n    ]);\n\n    const getDisableValue = useCallback(choice => get(choice, disableValue), [\n        disableValue,\n    ]);\n\n    return {\n        getChoiceText,\n        getChoiceValue,\n        getDisableValue,\n    };\n};\n","import { useCallback, useEffect, useState } from 'react';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport { useFormState } from 'react-hook-form';\nimport { useFormGroups } from './useFormGroups';\n\ntype FieldState = {\n    name: string;\n    error?: any;\n    isDirty: boolean;\n    isTouched: boolean;\n    isValid: boolean;\n};\n\ntype FormGroupState = {\n    errors: object;\n    isDirty: boolean;\n    isTouched: boolean;\n    isValid: boolean;\n};\n\n/**\n * Retrieve a specific form group data such as its validation status (valid/invalid) or\n * or whether its inputs have been updated (dirty/pristine)\n *\n * @example\n * import { Edit, SimpleForm, TextInput, FormGroupContextProvider, useFormGroup, minLength } from 'react-admin';\n * import { Accordion, AccordionDetails, AccordionSummary, Typography } from '@mui/material';\n * import ExpandMoreIcon from '@mui/icons-material/ExpandMoreIcon';\n *\n * const PostEdit = (props) => (\n *     <Edit {...props}>\n *         <SimpleForm>\n *             <TextInput source=\"title\" />\n *             <FormGroupContextProvider name=\"options\">\n *                 <Accordion>\n *                     <AccordionSummary\n *                         expandIcon={<ExpandMoreIcon />}\n *                         aria-controls=\"options-content\"\n *                         id=\"options-header\"\n *                     >\n *                         <AccordionSectionTitle name=\"options\">Options</AccordionSectionTitle>\n *                     </AccordionSummary>\n *                     <AccordionDetails id=\"options-content\" aria-labelledby=\"options-header\">\n *                         <TextInput source=\"teaser\" validate={minLength(20)} />\n *                     </AccordionDetails>\n *                 </Accordion>\n *             </FormGroupContextProvider>\n *         </SimpleForm>\n *     </Edit>\n * );\n *\n * const AccordionSectionTitle = ({ children, name }) => {\n *     const formGroupState = useFormGroup(name);\n *     return (\n *         <Typography color={!formGroupState.isValid && formGroupState.isDirty ? 'error' : 'inherit'}>\n *             {children}\n *         </Typography>\n *     );\n * }\n *\n * @param {string} name The form group name\n * @returns {FormGroupState} The form group state\n */\nexport const useFormGroup = (name: string): FormGroupState => {\n    const { dirtyFields, touchedFields, errors } = useFormState();\n    const formGroups = useFormGroups();\n    const [state, setState] = useState<FormGroupState>({\n        errors: undefined,\n        isDirty: false,\n        isTouched: false,\n        isValid: true,\n    });\n\n    const updateGroupState = useCallback(() => {\n        const fields = formGroups.getGroupFields(name);\n        const fieldStates = fields\n            .map<FieldState>(field => {\n                return {\n                    name: field,\n                    error: get(errors, field, undefined),\n                    isDirty: get(dirtyFields, field, false),\n                    isValid: get(errors, field, undefined) == undefined, // eslint-disable-line\n                    isTouched: get(touchedFields, field, false),\n                };\n            })\n            .filter(fieldState => fieldState != undefined); // eslint-disable-line\n\n        const newState = getFormGroupState(fieldStates);\n        setState(oldState => {\n            if (!isEqual(oldState, newState)) {\n                return newState;\n            }\n\n            return oldState;\n        });\n    }, [dirtyFields, errors, touchedFields, formGroups, name]);\n\n    useEffect(\n        () => {\n            updateGroupState();\n        },\n        // eslint-disable-next-line\n        [\n            // eslint-disable-next-line\n            JSON.stringify({ dirtyFields, errors, touchedFields }),\n            updateGroupState,\n        ]\n    );\n\n    useEffect(() => {\n        // Whenever the group content changes (input are added or removed)\n        // we must update its state\n        return formGroups.subscribe(name, () => {\n            updateGroupState();\n        });\n    }, [formGroups, name, updateGroupState]);\n\n    return state;\n};\n\n/**\n * Get the state of a form group\n *\n * @param {FieldState[]} fieldStates A map of field states from react-hook-form where the key is the field name.\n * @returns {FormGroupState} The state of the group.\n */\nexport const getFormGroupState = (\n    fieldStates: FieldState[]\n): FormGroupState => {\n    return fieldStates.reduce(\n        (acc, fieldState) => {\n            let errors = acc.errors || {};\n\n            if (fieldState.error) {\n                errors[fieldState.name] = fieldState.error;\n            }\n\n            const newState = {\n                isDirty: acc.isDirty || fieldState.isDirty,\n                errors,\n                isTouched: acc.isTouched || fieldState.isTouched,\n                isValid: acc.isValid && fieldState.isValid,\n            };\n\n            return newState;\n        },\n        {\n            isDirty: false,\n            errors: undefined,\n            isValid: true,\n            isTouched: false,\n        }\n    );\n};\n","import { useContext } from 'react';\nimport { FormGroupContext } from './FormGroupContext';\n\n/**\n * Retrieve the name of the form group the consumer belongs to. May be undefined if the consumer is not inside a form group.\n */\nexport const useFormGroupContext = () => {\n    const context = useContext(FormGroupContext);\n    return context;\n};\n","import {\n    ValidationErrorMessage,\n    ValidationErrorMessageWithArgs,\n} from './validate';\nimport { useTranslate } from '../i18n';\n\n/**\n * This internal hook returns a function that can translate an error message.\n * It handles simple string errors and those which have a message and args.\n * Only useful if you are implementing custom inputs without leveraging our useInput hook.\n *\n * @example\n * const MyInput = props => {\n *      const { field, fieldState } = useController(props);\n *      useEffect(() => {\n *          if (fieldState.error) {\n *              const errorMessage = useGetValidationErrorMessage(fieldState.error);\n *              alert(errorMessage);\n *          }\n *      }, [fieldState.error]);\n *\n *      return (\n *          <input {...field} />\n *      );\n * }\n *\n * @see ValidationErrorMessage\n * @see ValidationErrorMessageWithArgs\n */\nexport const useGetValidationErrorMessage = () => {\n    const translate = useTranslate();\n\n    return (error: ValidationErrorMessage) => {\n        if ((error as ValidationErrorMessageWithArgs).message != null) {\n            const { message, args } = error as ValidationErrorMessageWithArgs;\n            return translate(message, { _: message, ...args });\n        }\n        return translate(error as string, { _: error });\n    };\n};\n","import { useEffect } from 'react';\nimport { useFormContext } from 'react-hook-form';\nimport getFormInitialValues from './getFormInitialValues';\n\n/**\n * Restore the record values which should override any default values specified on the form.\n */\nexport const useInitializeFormWithRecord = (defaultValues, record) => {\n    const { reset } = useFormContext();\n\n    useEffect(() => {\n        if (!record) {\n            return;\n        }\n        const initialValues = getFormInitialValues(defaultValues, record);\n        reset(initialValues);\n    }, [reset, JSON.stringify(record, defaultValues)]); // eslint-disable-line react-hooks/exhaustive-deps\n};\n","import { ReactElement, useEffect } from 'react';\nimport {\n    ControllerFieldState,\n    ControllerRenderProps,\n    useController,\n    UseControllerProps,\n    UseControllerReturn,\n    useFormContext,\n    UseFormStateReturn,\n} from 'react-hook-form';\nimport get from 'lodash/get';\n\nimport { useRecordContext } from '../controller';\nimport { composeValidators, Validator } from './validate';\nimport isRequired from './isRequired';\nimport { useFormGroupContext } from './useFormGroupContext';\nimport { useGetValidationErrorMessage } from './useGetValidationErrorMessage';\nimport { useFormGroups } from './useFormGroups';\nimport { useApplyInputDefaultValues } from './useApplyInputDefaultValues';\n\nexport const useInput = (props: InputProps): UseInputValue => {\n    const {\n        defaultValue,\n        format,\n        id,\n        isRequired: isRequiredOption,\n        name,\n        onBlur,\n        onChange,\n        parse,\n        source,\n        validate,\n        ...options\n    } = props;\n    const finalName = name || source;\n    const formGroupName = useFormGroupContext();\n    const formGroups = useFormGroups();\n    const record = useRecordContext();\n    const getValidationErrorMessage = useGetValidationErrorMessage();\n    const formContext = useFormContext();\n\n    useEffect(() => {\n        if (!formGroups || formGroupName == null) {\n            return;\n        }\n\n        formGroups.registerField(source, formGroupName);\n\n        return () => {\n            formGroups.unregisterField(source, formGroupName);\n        };\n    }, [formGroups, formGroupName, source]);\n\n    const sanitizedValidate = Array.isArray(validate)\n        ? composeValidators(validate)\n        : validate;\n\n    // Fetch the defaultValue from the record if available or apply the provided defaultValue.\n    // This ensures dynamically added inputs have their value set correctly (ArrayInput for example).\n    // We don't do this for the form level defaultValues so that it works as it should in react-hook-form\n    // (i.e. field level defaultValue override form level defaultValues for this field).\n    const { field: controllerField, fieldState, formState } = useController({\n        name: finalName,\n        defaultValue: get(record, source, defaultValue),\n        rules: {\n            validate: async value => {\n                if (!sanitizedValidate) return true;\n                const error = await sanitizedValidate(\n                    value,\n                    formContext.getValues(),\n                    props\n                );\n\n                if (!error) return true;\n                return getValidationErrorMessage(error);\n            },\n        },\n        ...options,\n    });\n\n    // Because our forms may receive an asynchronously loaded record for instance,\n    // they may reset their default values which would override the input default value.\n    // This hook ensures that the input default value is applied when a new record is loaded but has\n    // no value for the input.\n    useApplyInputDefaultValues(props);\n\n    const field = {\n        ...controllerField,\n        value: format ? format(controllerField.value) : controllerField.value,\n        onBlur: (...event: any[]) => {\n            if (onBlur) {\n                onBlur(...event);\n            }\n            controllerField.onBlur();\n        },\n        onChange: (...event: any[]) => {\n            if (onChange) {\n                onChange(...event);\n            }\n            const eventOrValue = (typeof event[0]?.target?.checked ===\n                'boolean' && event[0]?.target?.value === 'on'\n                ? event[0].target.checked\n                : event[0]?.target?.value ?? event[0]) as any;\n            controllerField.onChange(\n                parse ? parse(eventOrValue) : eventOrValue\n            );\n        },\n    };\n\n    return {\n        id: id || source,\n        field,\n        fieldState,\n        formState,\n        isRequired: isRequiredOption || isRequired(validate),\n    };\n};\n\nexport type InputProps<ValueType = any> = Omit<\n    UseControllerProps,\n    'name' | 'defaultValue' | 'rules'\n> &\n    Partial<UseControllerReturn> & {\n        alwaysOn?: any;\n        defaultValue?: any;\n        format?: (value: ValueType) => any;\n        id?: string;\n        isRequired?: boolean;\n        label?: string | ReactElement | false;\n        helperText?: string | ReactElement | false;\n        name?: string;\n        onBlur?: (...event: any[]) => void;\n        onChange?: (...event: any[]) => void;\n        parse?: (value: any) => ValueType;\n        resource?: string;\n        source: string;\n        validate?: Validator | Validator[];\n    };\n\nexport type UseInputValue = {\n    id: string;\n    isRequired: boolean;\n    field: ControllerRenderProps;\n    formState: UseFormStateReturn<Record<string, string>>;\n    fieldState: ControllerFieldState;\n};\n","const isRequired = validate => {\n    if (validate && validate.isRequired) {\n        return true;\n    }\n    if (Array.isArray(validate)) {\n        return validate.some(it => it.isRequired);\n    }\n    return false;\n};\n\nexport default isRequired;\n","import { useCallback, isValidElement, ReactElement } from 'react';\nimport set from 'lodash/set';\nimport { useChoices, OptionText, UseChoicesOptions } from './useChoices';\nimport { useTranslate } from '../i18n';\n\n/*\n * Returns helper functions for suggestions handling.\n *\n * @param allowDuplicates A boolean indicating whether a suggestion can be added several times\n * @param choices An array of available choices\n * @param emptyText The text to use for the empty suggestion. Defaults to an empty string\n * @param emptyValue The value to use for the empty suggestion. Defaults to `null`\n * @param limitChoicesToValue A boolean indicating whether the initial suggestions should be limited to the currently selected one(s)\n * @param matchSuggestion Optional unless `optionText` is a React element. Function which check whether a choice matches a filter. Must return a boolean.\n * @param optionText Either a string defining the property to use to get the choice text, a function or a React element\n * @param optionValue The property to use to get the choice value\n * @param selectedItem The currently selected item. May be an array of selected items\n * @param suggestionLimit The maximum number of suggestions returned\n * @param translateChoice A boolean indicating whether to option text should be translated\n *\n * @returns An object with helper functions:\n * - getChoiceText: Returns the choice text or a React element\n * - getChoiceValue: Returns the choice value\n * - getSuggestions: A function taking a filter value (string) and returning the matching suggestions\n */\nexport const useSuggestions = ({\n    allowCreate,\n    choices,\n    createText = 'ra.action.create',\n    createValue = '@@create',\n    emptyText = '',\n    emptyValue = null,\n    limitChoicesToValue,\n    matchSuggestion,\n    optionText,\n    optionValue,\n    selectedItem,\n    suggestionLimit = 0,\n    translateChoice,\n}: UseSuggestionsOptions) => {\n    const translate = useTranslate();\n    const { getChoiceText, getChoiceValue } = useChoices({\n        optionText,\n        optionValue,\n        translateChoice,\n    });\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const getSuggestions = useCallback(\n        getSuggestionsFactory({\n            allowCreate,\n            choices,\n            createText,\n            createValue,\n            emptyText: translate(emptyText, { _: emptyText }),\n            emptyValue,\n            getChoiceText,\n            getChoiceValue,\n            limitChoicesToValue,\n            matchSuggestion,\n            optionText,\n            optionValue,\n            selectedItem,\n            suggestionLimit,\n        }),\n        [\n            allowCreate,\n            choices,\n            createText,\n            createValue,\n            emptyText,\n            emptyValue,\n            getChoiceText,\n            getChoiceValue,\n            limitChoicesToValue,\n            matchSuggestion,\n            optionText,\n            optionValue,\n            selectedItem,\n            suggestionLimit,\n            translate,\n        ]\n    );\n\n    return {\n        getChoiceText,\n        getChoiceValue,\n        getSuggestions,\n    };\n};\n\nconst escapeRegExp = value =>\n    value ? value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') : ''; // $& means the whole matched string\n\nexport interface UseSuggestionsOptions extends UseChoicesOptions {\n    allowCreate?: boolean;\n    allowDuplicates?: boolean;\n    choices: any[];\n    createText?: string;\n    createValue?: any;\n    emptyText?: string;\n    emptyValue?: any;\n    limitChoicesToValue?: boolean;\n    matchSuggestion?: (\n        filter: string,\n        suggestion: any,\n        exact?: boolean\n    ) => boolean;\n    suggestionLimit?: number;\n    selectedItem?: any | any[];\n}\n\n/**\n * Default matcher implementation which check whether the suggestion text matches the filter.\n */\nconst defaultMatchSuggestion = getChoiceText => (\n    filter,\n    suggestion,\n    exact = false\n) => {\n    const suggestionText = getChoiceText(suggestion);\n\n    const isReactElement = isValidElement(suggestionText);\n    const regex = escapeRegExp(filter);\n\n    return isReactElement\n        ? false\n        : suggestionText &&\n              !!suggestionText.match(\n                  // We must escape any RegExp reserved characters to avoid errors\n                  // For example, the filter might contain * which must be escaped as \\*\n                  new RegExp(exact ? `^${regex}$` : regex, 'i')\n              );\n};\n\n/**\n * Get the suggestions to display after applying a fuzzy search on the available choices\n *\n * @example\n *\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n */\nexport const getSuggestionsFactory = ({\n    allowCreate = false,\n    choices = [],\n    createText = 'ra.action.create',\n    createValue = '@@create',\n    emptyText = '',\n    emptyValue = null,\n    optionText = 'name',\n    optionValue = 'id',\n    getChoiceText,\n    getChoiceValue,\n    limitChoicesToValue = false,\n    matchSuggestion = defaultMatchSuggestion(getChoiceText),\n    selectedItem,\n    suggestionLimit = 0,\n}: UseSuggestionsOptions & {\n    getChoiceText: (choice: any) => string | ReactElement;\n    getChoiceValue: (choice: any) => string;\n}) => filter => {\n    let suggestions = [];\n    // if an item is selected and matches the filter\n    if (\n        selectedItem &&\n        !Array.isArray(selectedItem) &&\n        matchSuggestion(filter, selectedItem)\n    ) {\n        if (limitChoicesToValue) {\n            // display only the selected item\n            suggestions = choices.filter(\n                choice =>\n                    getChoiceValue(choice) === getChoiceValue(selectedItem)\n            );\n        } else {\n            suggestions = [...choices];\n        }\n    } else {\n        suggestions = choices.filter(\n            choice =>\n                matchSuggestion(filter, choice) ||\n                (selectedItem != null &&\n                    (!Array.isArray(selectedItem)\n                        ? getChoiceValue(choice) ===\n                          getChoiceValue(selectedItem)\n                        : selectedItem.some(\n                              selected =>\n                                  getChoiceValue(choice) ===\n                                  getChoiceValue(selected)\n                          )))\n        );\n    }\n\n    suggestions = limitSuggestions(suggestions, suggestionLimit);\n\n    const hasExactMatch = suggestions.some(suggestion =>\n        matchSuggestion(filter, suggestion, true)\n    );\n\n    if (allowCreate) {\n        const filterIsSelectedItem =\n            // If the selectedItem is an array (for example AutocompleteArrayInput)\n            // we shouldn't try to match\n            !!selectedItem && !Array.isArray(selectedItem)\n                ? matchSuggestion(filter, selectedItem, true)\n                : false;\n        if (!hasExactMatch && !filterIsSelectedItem) {\n            suggestions.push(\n                getSuggestion({\n                    optionText,\n                    optionValue,\n                    text: createText,\n                    value: createValue,\n                })\n            );\n        }\n    }\n\n    // Only keep unique items. Necessary because we might have fetched\n    // the currently selected choice in addition of the possible choices\n    // that may also contain it\n    const result = suggestions.filter(\n        (suggestion, index) => suggestions.indexOf(suggestion) === index\n    );\n    return result;\n};\n\n/**\n * @example\n *\n * limitSuggestions(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n *  1\n * );\n *\n * // Will return [{ id: 1, name: 'foo' }]\n *\n * @param suggestions List of suggestions\n * @param limit\n */\nconst limitSuggestions = (suggestions: any[], limit: any = 0) =>\n    Number.isInteger(limit) && limit > 0\n        ? suggestions.slice(0, limit)\n        : suggestions;\n\n/**\n * addSuggestion(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n * );\n *\n * // Will return [{ id: null, name: '' }, { id: 1, name: 'foo' }, , { id: 2, name: 'bar' }]\n *\n * @param suggestions List of suggestions\n * @param options\n * @param options.optionText\n */\nconst getSuggestion = ({\n    optionText = 'name',\n    optionValue = 'id',\n    text = '',\n    value = null,\n}: {\n    optionText: OptionText;\n    optionValue: string;\n    text: string;\n    value: any;\n}) => {\n    const suggestion = {};\n    set(suggestion, optionValue, value);\n    if (typeof optionText === 'string') {\n        set(suggestion, optionText, text);\n    }\n\n    return suggestion;\n};\n","import { ReactNode, ReactElement, ComponentType } from 'react';\n\nimport { WithPermissionsChildrenParams } from './auth/WithPermissions';\nimport { AuthActionType } from './auth/types';\n\n/**\n * data types\n */\n\nexport type Identifier = string | number;\n\nexport interface RaRecord {\n    id: Identifier;\n    [key: string]: any;\n}\n\nexport interface SortPayload {\n    field: string;\n    order: string;\n}\nexport interface FilterPayload {\n    [k: string]: any;\n}\nexport interface PaginationPayload {\n    page: number;\n    perPage: number;\n}\nexport type ValidUntil = Date;\n/**\n * i18nProvider types\n */\n\nexport const I18N_TRANSLATE = 'I18N_TRANSLATE';\nexport const I18N_CHANGE_LOCALE = 'I18N_CHANGE_LOCALE';\n\nexport type Translate = (key: string, options?: any) => string;\n\nexport type I18nProvider = {\n    translate: Translate;\n    changeLocale: (locale: string, options?: any) => Promise<void>;\n    getLocale: () => string;\n    [key: string]: any;\n};\n\nexport interface UserIdentity {\n    id: Identifier;\n    fullName?: string;\n    avatar?: string;\n    [key: string]: any;\n}\n\n/**\n * authProvider types\n */\nexport type AuthProvider = {\n    login: (params: any) => Promise<any>;\n    logout: (params: any) => Promise<void | false | string>;\n    checkAuth: (params: any) => Promise<void>;\n    checkError: (error: any) => Promise<void>;\n    getIdentity?: () => Promise<UserIdentity>;\n    getPermissions: (params: any) => Promise<any>;\n    [key: string]: any;\n};\n\nexport type LegacyAuthProvider = (\n    type: AuthActionType,\n    params?: any\n) => Promise<any>;\n\n/**\n * dataProvider types\n */\n\nexport type DataProvider<ResourceType extends string = string> = {\n    getList: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: GetListParams\n    ) => Promise<GetListResult<RecordType>>;\n\n    getOne: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: GetOneParams\n    ) => Promise<GetOneResult<RecordType>>;\n\n    getMany: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: GetManyParams\n    ) => Promise<GetManyResult<RecordType>>;\n\n    getManyReference: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: GetManyReferenceParams\n    ) => Promise<GetManyReferenceResult<RecordType>>;\n\n    update: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: UpdateParams\n    ) => Promise<UpdateResult<RecordType>>;\n\n    updateMany: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: UpdateManyParams\n    ) => Promise<UpdateManyResult<RecordType>>;\n\n    create: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: CreateParams\n    ) => Promise<CreateResult<RecordType>>;\n\n    delete: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: DeleteParams<RecordType>\n    ) => Promise<DeleteResult<RecordType>>;\n\n    deleteMany: <RecordType extends RaRecord = any>(\n        resource: ResourceType,\n        params: DeleteManyParams<RecordType>\n    ) => Promise<DeleteManyResult<RecordType>>;\n\n    [key: string]: any;\n};\n\nexport interface GetListParams {\n    pagination: PaginationPayload;\n    sort: SortPayload;\n    filter: any;\n    meta?: any;\n}\nexport interface GetListResult<RecordType extends RaRecord = any> {\n    data: RecordType[];\n    total?: number;\n    pageInfo?: {\n        hasNextPage?: boolean;\n        hasPreviousPage?: boolean;\n    };\n}\n\nexport interface GetOneParams<RecordType extends RaRecord = any> {\n    id: RecordType['id'];\n    meta?: any;\n}\nexport interface GetOneResult<RecordType extends RaRecord = any> {\n    data: RecordType;\n}\n\nexport interface GetManyParams {\n    ids: Identifier[];\n    meta?: any;\n}\nexport interface GetManyResult<RecordType extends RaRecord = any> {\n    data: RecordType[];\n}\n\nexport interface GetManyReferenceParams {\n    target: string;\n    id: Identifier;\n    pagination: PaginationPayload;\n    sort: SortPayload;\n    filter: any;\n    meta?: any;\n}\nexport interface GetManyReferenceResult<RecordType extends RaRecord = any> {\n    data: RecordType[];\n    total?: number;\n    pageInfo?: {\n        hasNextPage?: boolean;\n        hasPreviousPage?: boolean;\n    };\n}\n\nexport interface UpdateParams<T = any> {\n    id: Identifier;\n    data: Partial<T>;\n    previousData: T;\n    meta?: any;\n}\nexport interface UpdateResult<RecordType extends RaRecord = any> {\n    data: RecordType;\n}\n\nexport interface UpdateManyParams<T = any> {\n    ids: Identifier[];\n    data: T;\n    meta?: any;\n}\nexport interface UpdateManyResult<RecordType extends RaRecord = any> {\n    data?: RecordType['id'][];\n}\n\nexport interface CreateParams<T = any> {\n    data: T;\n    meta?: any;\n}\nexport interface CreateResult<RecordType extends RaRecord = any> {\n    data: RecordType;\n}\n\nexport interface DeleteParams<RecordType extends RaRecord = any> {\n    id: Identifier;\n    previousData?: RecordType;\n    meta?: any;\n}\nexport interface DeleteResult<RecordType extends RaRecord = any> {\n    data: RecordType;\n}\n\nexport interface DeleteManyParams<RecordType extends RaRecord = any> {\n    ids: RecordType['id'][];\n    meta?: any;\n}\nexport interface DeleteManyResult<RecordType extends RaRecord = any> {\n    data?: RecordType['id'][];\n}\n\nexport type DataProviderResult<RecordType extends RaRecord = any> =\n    | CreateResult<RecordType>\n    | DeleteResult<RecordType>\n    | DeleteManyResult\n    | GetListResult<RecordType>\n    | GetManyResult<RecordType>\n    | GetManyReferenceResult<RecordType>\n    | GetOneResult<RecordType>\n    | UpdateResult<RecordType>\n    | UpdateManyResult;\n\nexport type MutationMode = 'pessimistic' | 'optimistic' | 'undoable';\nexport type OnSuccess = (\n    response?: any,\n    variables?: any,\n    context?: any\n) => void;\nexport type onError = (error?: any, variables?: any, context?: any) => void;\nexport type TransformData = (\n    data: any,\n    options?: { previousData: any }\n) => any | Promise<any>;\n\nexport interface UseDataProviderOptions {\n    action?: string;\n    fetch?: string;\n    meta?: object;\n    mutationMode?: MutationMode;\n    onSuccess?: OnSuccess;\n    onError?: onError;\n    enabled?: boolean;\n}\n\nexport type LegacyDataProvider = (\n    type: string,\n    resource: string,\n    params: any\n) => Promise<any>;\n\nexport interface ResourceDefinition {\n    readonly name: string;\n    readonly options?: any;\n    readonly hasList?: boolean;\n    readonly hasEdit?: boolean;\n    readonly hasShow?: boolean;\n    readonly hasCreate?: boolean;\n    readonly icon?: any;\n}\n\n/**\n * Misc types\n */\n\nexport type Dispatch<T> = T extends (...args: infer A) => any\n    ? (...args: A) => void\n    : never;\n\nexport type ResourceElement = ReactElement<ResourceProps>;\nexport type RenderResourcesFunction = (\n    permissions: any\n) => ResourceElement[] | Promise<ResourceElement[]>;\nexport type AdminChildren = RenderResourcesFunction | ReactNode;\n\nexport type TitleComponent = string | ReactElement<any>;\nexport type CatchAllComponent = ComponentType<{ title?: TitleComponent }>;\n\nexport type LoginComponent = ComponentType<{}> | ReactElement<any>;\nexport type DashboardComponent = ComponentType<WithPermissionsChildrenParams>;\n\nexport interface CoreLayoutProps {\n    children?: ReactNode;\n    dashboard?: DashboardComponent;\n    menu?: ComponentType<{\n        hasDashboard?: boolean;\n    }>;\n    title?: TitleComponent;\n}\n\nexport type LayoutComponent = ComponentType<CoreLayoutProps>;\nexport type LoadingComponent = ComponentType<{\n    loadingPrimary?: string;\n    loadingSecondary?: string;\n}>;\n\nexport interface ResourceComponentInjectedProps {\n    permissions?: any;\n    resource?: string;\n    options?: any;\n    hasList?: boolean;\n    hasEdit?: boolean;\n    hasShow?: boolean;\n    hasCreate?: boolean;\n}\n\nexport interface ResourceOptions {\n    label?: string;\n    [key: string]: any;\n}\n\nexport interface ResourceProps {\n    intent?: 'route' | 'registration';\n    name: string;\n    list?: ComponentType<any> | ReactElement;\n    create?: ComponentType<any> | ReactElement;\n    edit?: ComponentType<any> | ReactElement;\n    show?: ComponentType<any> | ReactElement;\n    icon?: ComponentType<any>;\n    options?: ResourceOptions;\n}\n\nexport type Exporter = (\n    data: any,\n    fetchRelatedRecords: (\n        data: any,\n        field: string,\n        resource: string\n    ) => Promise<any>,\n    dataProvider: DataProvider,\n    resource?: string\n) => void | Promise<void>;\n\nexport type SetOnSave = (\n    onSave?: (values: object, redirect: any) => void\n) => void;\n\nexport type FormFunctions = {\n    setOnSave?: SetOnSave;\n};\n"],"mappings":"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","names":[]}