import * as react_query from 'react-query';
import { QueryClient, UseQueryOptions, UseQueryResult, UseMutationOptions, MutateOptions, UseMutationResult } from 'react-query';
import { History, Location as Location$1 } from 'history';
import * as react from 'react';
import { ReactNode, ComponentType, ReactElement, MutableRefObject, LegacyRef, RefCallback, ReactEventHandler, SyntheticEvent, Reducer, BaseSyntheticEvent } from 'react';
import { Location, To } from 'react-router-dom';
import { stringify } from 'query-string';
import EventEmitter from 'eventemitter3';
import * as react_hook_form from 'react-hook-form';
import { ControllerRenderProps, FieldValues, UseFormProps, UseFormSetError, UseControllerProps, UseControllerReturn, UseFormStateReturn, ControllerFieldState, Control } from 'react-hook-form';
import * as lodash from 'lodash';

interface Store {
    setup: () => void;
    teardown: () => void;
    getItem: <T = any>(key: string, defaultValue?: T) => T;
    setItem: <T = any>(key: string, value: T) => void;
    removeItem: (key: string) => void;
    reset: () => void;
    subscribe: (key: string, callback: (value: any) => void) => () => void;
}

/**
 * Store using localStorage, or memory storage in incognito mode
 *
 * @example
 *
 * import { localStorageProvider } from 'react-admin';
 *
 * const App = () => (
 *    <Admin store={localStorageProvider()}>
 *       ...
 *   </Admin>
 * );
 */
declare const localStorageStore: (version?: string) => Store;
declare class LocalStorageShim {
    valuesMap: any;
    getItem(key: string): string;
    setItem(key: string, value: string): void;
    removeItem(key: string): void;
    clear(): void;
    key(i: any): string;
    get length(): any;
}
declare const getStorage: () => LocalStorageShim | Storage;

/**
 * Store using memory
 *
 * @example
 *
 * import { memoryStore } from 'react-admin';
 *
 * const App = () => (
 *    <Admin store={memoryStore()}>
 *       ...
 *   </Admin>
 * );
 */
declare const memoryStore: (storage?: any) => Store;

declare const StoreContext: react.Context<Store>;

declare const StoreContextProvider: ({ value: Store, children, }: StoreContextProviderProps) => JSX.Element;
interface StoreContextProviderProps {
    value: Store;
    children: react.ReactNode;
}

/**
 * A component to set store state for a key on mount declaratively
 *
 * To use it, just wrap any component that need to use the corresponding
 * store item with <StoreSetter name="my.key" value="myvalue">.
 * This wrapping needs to be done to ensure that the corresponding store item
 * is set before rendering the wrapped component.
 *
 * Tip: <StoreSetter> is a great helper for mocking the store in
 * unit tests. Prefer it to calling the Store manually.
 *
 * @example
 *
 *     <StoreSetter name="list.density" value="small">
 *         <MyStoreDependentComponent />
 *     </StoreSetter>
 *
 * @example // Using <StoreSetter> is equivalent to using `useStoreContext` and setting its value directly.
 *
 * const [, setDensity] = useStore('list.density');
 *
 * useEffect(() => {
 *     setDensity('small');
 * }, []);
 *
 * @param {Props}    props
 * @param {string}   props.name Store item key. Required. Separate with dots to namespace, e.g. 'posts.list.columns'
 * @param {any}      props.value Store item value. Required.
 * @param {children} props.children Children are rendered as is, on mount
 */
declare const StoreSetter: ({ value, name, children }: StoreSetterProps) => JSX.Element;
interface StoreSetterProps {
    name: string;
    value: any;
    children: ReactNode;
}

/**
 * Read and write a value from the Store
 *
 * useState-like hook using the global Store for persistence.
 * Each time a store value is changed, all components using this value will be re-rendered.
 *
 * @param {string} key Name of the store key. Separate with dots to namespace, e.g. 'posts.list.columns'.
 * @param {any} defaultValue Default value
 *
 * @return {Object} A value and a setter for the value, in an array - just like for useState()
 *
 * @example
 * import { useStore } from 'react-admin';
 *
 * const PostList = props => {
 *     const [density] = useStore('posts.list.density', 'small');
 *
 *     return (
 *         <List {...props}>
 *             <Datagrid size={density}>
 *                 ...
 *             </Datagrid>
 *         </List>
 *     );
 * }
 *
 * // Clicking on this button will trigger a rerender of the PostList!
 * const ChangeDensity: FC<any> = () => {
 *     const [density, setDensity] = useStore('posts.list.density', 'small');
 *
 *     const changeDensity = (): void => {
 *         setDensity(density === 'small' ? 'medium' : 'small');
 *     };
 *
 *     return (
 *         <Button onClick={changeDensity}>
 *             {`Change density (current ${density})`}
 *         </Button>
 *     );
 * };
 */
declare const useStore: <T = any>(key: string, defaultValue?: T) => useStoreResult<T>;
declare type useStoreResult<T = any> = [
    T,
    (value: T | ((value: T) => void), defaultValue?: T) => void
];

/**
 * Get the Store stored in the StoreContext
 */
declare const useStoreContext: () => Store;

/**
 * Get a callback to remove an item from the store
 *
 * @example
 * import { useRemoveFromStore } from 'react-admin';
 *
 * const ResetDatagridPrefs = () {
 *    const removeItem = useRemoveFromStore();
 *
 *    const hancleClick = () => {
 *        removeItem('datagrid.prefs');
 *    };
 *
 *    return <Button onClick={hancleClick}>Reset datagrid preferences</Button>;
 * }
 */
declare const useRemoveFromStore: (hookTimeKey?: string) => (key?: string) => void;

/**
 * Get a callback to remove all items from the store
 *
 * @example
 * import { useResetStore } from 'react-admin';
 *
 * const ResetPrefs = () {
 *    const reset = useResetStore();
 *
 *    const handleClick = () => {
 *        reset();
 *    };
 *
 *    return <Button onClick={handleClick}>Reset preferences</Button>;
 * }
 */
declare const useResetStore: () => () => void;

interface WithPermissionsChildrenParams {
    permissions: any;
}
declare type WithPermissionsChildren = (params: WithPermissionsChildrenParams) => ReactElement;
interface WithPermissionsProps {
    authParams?: object;
    children?: WithPermissionsChildren;
    component?: ComponentType<any>;
    location?: Location;
    render?: WithPermissionsChildren;
    staticContext?: object;
    [key: string]: any;
}
declare const _default$d: ComponentType<WithPermissionsProps>;

declare type UserCheck = (payload: object, pathName: string, routeParams?: object) => void;
declare const AUTH_LOGIN = "AUTH_LOGIN";
declare const AUTH_CHECK = "AUTH_CHECK";
declare const AUTH_ERROR = "AUTH_ERROR";
declare const AUTH_LOGOUT = "AUTH_LOGOUT";
declare const AUTH_GET_PERMISSIONS = "AUTH_GET_PERMISSIONS";
declare type AuthActionType = typeof AUTH_LOGIN | typeof AUTH_LOGOUT | typeof AUTH_ERROR | typeof AUTH_CHECK | typeof AUTH_GET_PERMISSIONS;

/**
 * data types
 */
declare type Identifier = string | number;
interface RaRecord {
    id: Identifier;
    [key: string]: any;
}
interface SortPayload {
    field: string;
    order: string;
}
interface FilterPayload {
    [k: string]: any;
}
interface PaginationPayload {
    page: number;
    perPage: number;
}
declare type ValidUntil = Date;
/**
 * i18nProvider types
 */
declare const I18N_TRANSLATE = "I18N_TRANSLATE";
declare const I18N_CHANGE_LOCALE = "I18N_CHANGE_LOCALE";
declare type Translate = (key: string, options?: any) => string;
declare type I18nProvider = {
    translate: Translate;
    changeLocale: (locale: string, options?: any) => Promise<void>;
    getLocale: () => string;
    [key: string]: any;
};
interface UserIdentity {
    id: Identifier;
    fullName?: string;
    avatar?: string;
    [key: string]: any;
}
/**
 * authProvider types
 */
declare type AuthProvider = {
    login: (params: any) => Promise<any>;
    logout: (params: any) => Promise<void | false | string>;
    checkAuth: (params: any) => Promise<void>;
    checkError: (error: any) => Promise<void>;
    getIdentity?: () => Promise<UserIdentity>;
    getPermissions: (params: any) => Promise<any>;
    [key: string]: any;
};
declare type LegacyAuthProvider = (type: AuthActionType, params?: any) => Promise<any>;
/**
 * dataProvider types
 */
declare type DataProvider<ResourceType extends string = string> = {
    getList: <RecordType extends RaRecord = any>(resource: ResourceType, params: GetListParams) => Promise<GetListResult<RecordType>>;
    getOne: <RecordType extends RaRecord = any>(resource: ResourceType, params: GetOneParams) => Promise<GetOneResult<RecordType>>;
    getMany: <RecordType extends RaRecord = any>(resource: ResourceType, params: GetManyParams) => Promise<GetManyResult<RecordType>>;
    getManyReference: <RecordType extends RaRecord = any>(resource: ResourceType, params: GetManyReferenceParams) => Promise<GetManyReferenceResult<RecordType>>;
    update: <RecordType extends RaRecord = any>(resource: ResourceType, params: UpdateParams) => Promise<UpdateResult<RecordType>>;
    updateMany: <RecordType extends RaRecord = any>(resource: ResourceType, params: UpdateManyParams) => Promise<UpdateManyResult<RecordType>>;
    create: <RecordType extends RaRecord = any>(resource: ResourceType, params: CreateParams) => Promise<CreateResult<RecordType>>;
    delete: <RecordType extends RaRecord = any>(resource: ResourceType, params: DeleteParams<RecordType>) => Promise<DeleteResult<RecordType>>;
    deleteMany: <RecordType extends RaRecord = any>(resource: ResourceType, params: DeleteManyParams<RecordType>) => Promise<DeleteManyResult<RecordType>>;
    [key: string]: any;
};
interface GetListParams {
    pagination: PaginationPayload;
    sort: SortPayload;
    filter: any;
    meta?: any;
}
interface GetListResult<RecordType extends RaRecord = any> {
    data: RecordType[];
    total?: number;
    pageInfo?: {
        hasNextPage?: boolean;
        hasPreviousPage?: boolean;
    };
}
interface GetOneParams<RecordType extends RaRecord = any> {
    id: RecordType['id'];
    meta?: any;
}
interface GetOneResult<RecordType extends RaRecord = any> {
    data: RecordType;
}
interface GetManyParams {
    ids: Identifier[];
    meta?: any;
}
interface GetManyResult<RecordType extends RaRecord = any> {
    data: RecordType[];
}
interface GetManyReferenceParams {
    target: string;
    id: Identifier;
    pagination: PaginationPayload;
    sort: SortPayload;
    filter: any;
    meta?: any;
}
interface GetManyReferenceResult<RecordType extends RaRecord = any> {
    data: RecordType[];
    total?: number;
    pageInfo?: {
        hasNextPage?: boolean;
        hasPreviousPage?: boolean;
    };
}
interface UpdateParams<T = any> {
    id: Identifier;
    data: Partial<T>;
    previousData: T;
    meta?: any;
}
interface UpdateResult<RecordType extends RaRecord = any> {
    data: RecordType;
}
interface UpdateManyParams<T = any> {
    ids: Identifier[];
    data: T;
    meta?: any;
}
interface UpdateManyResult<RecordType extends RaRecord = any> {
    data?: RecordType['id'][];
}
interface CreateParams<T = any> {
    data: T;
    meta?: any;
}
interface CreateResult<RecordType extends RaRecord = any> {
    data: RecordType;
}
interface DeleteParams<RecordType extends RaRecord = any> {
    id: Identifier;
    previousData?: RecordType;
    meta?: any;
}
interface DeleteResult<RecordType extends RaRecord = any> {
    data: RecordType;
}
interface DeleteManyParams<RecordType extends RaRecord = any> {
    ids: RecordType['id'][];
    meta?: any;
}
interface DeleteManyResult<RecordType extends RaRecord = any> {
    data?: RecordType['id'][];
}
declare type DataProviderResult<RecordType extends RaRecord = any> = CreateResult<RecordType> | DeleteResult<RecordType> | DeleteManyResult | GetListResult<RecordType> | GetManyResult<RecordType> | GetManyReferenceResult<RecordType> | GetOneResult<RecordType> | UpdateResult<RecordType> | UpdateManyResult;
declare type MutationMode = 'pessimistic' | 'optimistic' | 'undoable';
declare type OnSuccess = (response?: any, variables?: any, context?: any) => void;
declare type onError = (error?: any, variables?: any, context?: any) => void;
declare type TransformData = (data: any, options?: {
    previousData: any;
}) => any | Promise<any>;
interface UseDataProviderOptions {
    action?: string;
    fetch?: string;
    meta?: object;
    mutationMode?: MutationMode;
    onSuccess?: OnSuccess;
    onError?: onError;
    enabled?: boolean;
}
declare type LegacyDataProvider = (type: string, resource: string, params: any) => Promise<any>;
interface ResourceDefinition {
    readonly name: string;
    readonly options?: any;
    readonly hasList?: boolean;
    readonly hasEdit?: boolean;
    readonly hasShow?: boolean;
    readonly hasCreate?: boolean;
    readonly icon?: any;
}
/**
 * Misc types
 */
declare type Dispatch<T> = T extends (...args: infer A) => any ? (...args: A) => void : never;
declare type ResourceElement = ReactElement<ResourceProps>;
declare type RenderResourcesFunction = (permissions: any) => ResourceElement[] | Promise<ResourceElement[]>;
declare type AdminChildren = RenderResourcesFunction | ReactNode;
declare type TitleComponent = string | ReactElement<any>;
declare type CatchAllComponent = ComponentType<{
    title?: TitleComponent;
}>;
declare type LoginComponent = ComponentType<{}> | ReactElement<any>;
declare type DashboardComponent = ComponentType<WithPermissionsChildrenParams>;
interface CoreLayoutProps {
    children?: ReactNode;
    dashboard?: DashboardComponent;
    menu?: ComponentType<{
        hasDashboard?: boolean;
    }>;
    title?: TitleComponent;
}
declare type LayoutComponent = ComponentType<CoreLayoutProps>;
declare type LoadingComponent = ComponentType<{
    loadingPrimary?: string;
    loadingSecondary?: string;
}>;
interface ResourceComponentInjectedProps {
    permissions?: any;
    resource?: string;
    options?: any;
    hasList?: boolean;
    hasEdit?: boolean;
    hasShow?: boolean;
    hasCreate?: boolean;
}
interface ResourceOptions {
    label?: string;
    [key: string]: any;
}
interface ResourceProps {
    intent?: 'route' | 'registration';
    name: string;
    list?: ComponentType<any> | ReactElement;
    create?: ComponentType<any> | ReactElement;
    edit?: ComponentType<any> | ReactElement;
    show?: ComponentType<any> | ReactElement;
    icon?: ComponentType<any>;
    options?: ResourceOptions;
}
declare type Exporter = (data: any, fetchRelatedRecords: (data: any, field: string, resource: string) => Promise<any>, dataProvider: DataProvider, resource?: string) => void | Promise<void>;
declare type SetOnSave = (onSave?: (values: object, redirect: any) => void) => void;
declare type FormFunctions = {
    setOnSave?: SetOnSave;
};

interface CoreAdminContextProps {
    authProvider?: AuthProvider | LegacyAuthProvider;
    basename?: string;
    children?: AdminChildren;
    dashboard?: DashboardComponent;
    dataProvider?: DataProvider | LegacyDataProvider;
    store?: Store;
    queryClient?: QueryClient;
    /**
     * @deprecated Wrap your Admin inside a Router to change the routing strategy
     */
    history?: History;
    i18nProvider?: I18nProvider;
    theme?: object;
}
declare const CoreAdminContext: {
    (props: CoreAdminContextProps): JSX.Element;
    defaultProps: {
        dataProvider: {
            create: () => Promise<{
                data: any;
            }>;
            delete: () => Promise<{
                data: any;
            }>;
            deleteMany: () => Promise<{
                data: any[];
            }>;
            getList: () => Promise<{
                data: any[];
                total: number;
            }>;
            getMany: () => Promise<{
                data: any[];
            }>;
            getManyReference: () => Promise<{
                data: any[];
                total: number;
            }>;
            getOne: () => Promise<{
                data: any;
            }>;
            update: () => Promise<{
                data: any;
            }>;
            updateMany: () => Promise<{
                data: any[];
            }>;
        };
        store: Store;
    };
};

declare type ChildrenFunction = () => ComponentType[];
interface CoreAdminUIProps {
    catchAll?: CatchAllComponent;
    children?: AdminChildren;
    dashboard?: DashboardComponent;
    disableTelemetry?: boolean;
    layout?: LayoutComponent;
    loading?: LoadingComponent;
    loginPage?: LoginComponent | boolean;
    /**
     * @deprecated use a custom layout instead
     */
    menu?: ComponentType;
    requireAuth?: boolean;
    ready?: ComponentType;
    title?: TitleComponent;
}
declare const CoreAdminUI: (props: CoreAdminUIProps) => JSX.Element;

/**
 * Main admin component, entry point to the application.
 *
 * Initializes the various contexts (auth, data, i18n, router)
 * and defines the main routes.
 *
 * Expects a list of resources as children, or a function returning a list of
 * resources based on the permissions.
 *
 * @example
 *
 * // static list of resources
 *
 * import {
 *     CoreAdmin,
 *     Resource,
 *     ListGuesser,
 *     useDataProvider,
 * } from 'ra-core';
 *
 * const App = () => (
 *     <CoreAdmin dataProvider={myDataProvider}>
 *         <Resource name="posts" list={ListGuesser} />
 *     </CoreAdmin>
 * );
 *
 * // dynamic list of resources based on permissions
 *
 * import {
 *     CoreAdmin,
 *     Resource,
 *     ListGuesser,
 *     useDataProvider,
 * } from 'ra-core';
 *
 * const App = () => (
 *     <CoreAdmin dataProvider={myDataProvider}>
 *         {permissions => [
 *             <Resource name="posts" key="posts" list={ListGuesser} />,
 *         ]}
 *     </CoreAdmin>
 * );
 *
 * // If you have to build a dynamic list of resources using a side effect,
 * // you can't use <CoreAdmin>. But as it delegates to sub components,
 * // it's relatively straightforward to replace it:
 *
 * import * as React from 'react';
 * import { useEffect, useState } from 'react';
 * import {
 *     CoreAdminContext,
 *     CoreAdminUI,
 *     Resource,
 *     ListGuesser,
 *     useDataProvider,
 * } from 'ra-core';
 *
 * const App = () => (
 *     <CoreAdminContext dataProvider={myDataProvider}>
 *         <UI />
 *     </CoreAdminContext>
 * );
 *
 * const UI = () => {
 *     const [resources, setResources] = useState([]);
 *     const dataProvider = useDataProvider();
 *     useEffect(() => {
 *         dataProvider.introspect().then(r => setResources(r));
 *     }, []);
 *
 *     return (
 *         <CoreAdminUI>
 *             {resources.map(resource => (
 *                 <Resource name={resource.name} key={resource.key} list={ListGuesser} />
 *             ))}
 *         </CoreAdminUI>
 *     );
 * };
 */
declare const CoreAdmin: (props: CoreAdminProps) => JSX.Element;
declare type CoreAdminProps = CoreAdminContextProps & CoreAdminUIProps;

declare const CoreAdminRoutes: {
    (props: CoreAdminRoutesProps): JSX.Element;
    defaultProps: {
        customRoutes: any[];
    };
};
interface CoreAdminRoutesProps extends CoreLayoutProps {
    layout: LayoutComponent;
    catchAll: CatchAllComponent;
    children?: AdminChildren;
    loading: LoadingComponent;
    requireAuth?: boolean;
    ready?: ComponentType;
}

/**
 * This component allows you to provide custom routes to the Admin.
 * @param props The component props
 * @param props.children The custom routes.
 * @param props.noLayout A boolean indicating whether to render the routes outside the Layout. Defaults to false.
 * @returns Nothing. This is a configuration component.
 */
declare const CustomRoutes: {
    (props: CustomRoutesProps): any;
    raName: string;
};
declare type CustomRoutesProps = {
    children: ReactNode;
    noLayout?: boolean;
};

declare const Resource: {
    (props: ResourceProps): JSX.Element;
    raName: string;
    registerResource({ create, edit, icon, list, name, options, show, }: ResourceProps): {
        name: string;
        options: ResourceOptions;
        hasList: boolean;
        hasCreate: boolean;
        hasEdit: boolean;
        hasShow: boolean;
        icon: react.ComponentType<any>;
    };
};

/**
 * Context to store the current resource name.
 *
 * Use the useResource() hook to read the context. That's what most components do in react-admin.
 *
 * @example
 *
 * import { useResourceContext, useTranslate } from 'ra-core';
 *
 * const MyCustomEditTitle = props => {
 *     const name = useResourceContext(props);
 *
 *     return (
 *         <h1>{translate(`${name}.name`)}</h1>
 *     );
 * };
 */
declare const ResourceContext: react.Context<string>;
declare type ResourceContextValue = string;

/**
 * Create a Resource Context with the resource name
 *
 * Some react-admin components rely on the resource name to be available in the context.
 * This component provides it.
 *
 * If the value is empty, the context is not provided.
 *
 * @param {string} value the resource name
 * @example
 *
 * import { ResourceContextProvider } from 'react-admin';
 *
 * const MyComponent = () => (
 *    <ResourceContextProvider value="posts">
 *       <MyResourceSpecificComponent />
 *   </ResourceContextProvider>
 * );
 */
declare const ResourceContextProvider: ({ children, value, }: {
    children: ReactElement;
    value?: ResourceContextValue;
}) => JSX.Element;

declare type ResourceDefinitions = {
    [name: string]: ResourceDefinition;
};
declare type ResourceDefinitionContextValue = {
    definitions: ResourceDefinitions;
    register: (config: ResourceDefinition) => void;
    unregister: (config: ResourceDefinition) => void;
};
declare const ResourceDefinitionContext: react.Context<ResourceDefinitionContextValue>;
/**
 * Context to store the current resource Definition.
 *
 * Use the useResourceDefinition() hook to read the context.
 *
 * @example
 *
 * import { useResourceDefinition, useTranslate } from 'ra-core';
 *
 * const PostMenuItem = () => {
 *     const { name, icon } = useResourceDefinition({ resource: 'posts' });
 *
 *     return (
 *          <MenuItem>
 *              <ListItemIcon>{icon}</ListItemIcon>
 *              {name}
 *          </MenuItem>
 *     );
 * };
 */
declare const ResourceDefinitionContextProvider: ({ definitions: defaultDefinitions, children, }: {
    definitions?: {};
    children: any;
}) => JSX.Element;

/**
 * A hook which returns function to get a translated resource name. It will use the label option of the `Resource` component if it was provided.
 *
 * @returns {GetResourceLabel} A function which takes a resource name and an optional number indicating the number of items (used for pluralization) and returns a translated string.
 * @example
 * const Menu = () => {
 *     const resources = useResourceDefinitions();
 *     const getResourceLabel = useGetResourceLabel();
 *
 *     return (
 *         <ul>
 *             {Object.keys(resources).map(name => (
 *                 <li key={name}>
 *                     {getResourceLabel(name, 2)}
 *                 </li>
 *             ))}
 *         </ul>
 *     )
 * }
 */
declare const useGetResourceLabel: () => GetResourceLabel;
declare type GetResourceLabel = (resource: string, count?: number) => string;

declare const useResourceDefinitionContext: () => ResourceDefinitionContextValue;

/**
 * Hook to read the resource from the ResourceContext.
 *
 * Must be used within a <ResourceContextProvider> (e.g. as a descendent of <Resource>
 * or any reference related components), or called with a resource prop.
 *
 * @example
 *
 * const ResourceName = (props) => {
 *   const resource = useResourceContext(props);
 *   const getResourceLabel = useGetResourceLabel();
 *   return <>{getResourceLabel(resource, 1)}</>;
 * }
 *
 * // use it in a resource context
 * const MyComponent = () => (
 *   <ResourceContextProvider value="posts">
 *     <ResourceName />
 *     ...
 *   </ResourceContextProvider>
 * );
 *
 * // override resource via props
 * const MyComponent = () => (
 *   <>
 *     <ResourceName resource="posts"/>
 *     ...
 *   </>
 * );
 *
 * @returns {ResourceContextValue} The resource name, e.g. 'posts'
 */
declare const useResourceContext: <ResourceInformationsType extends Partial<{
    resource: string;
}>>(props?: ResourceInformationsType) => ResourceContextValue;

/**
 * Hook to get the definition of a given resource
 *
 * @example // Get the current resource definition (based on ResourceContext)
 *
 * const definition = useResourceDefinition();
 * console.log(definition);
 * // {
 * //   name: 'posts',
 * //   hasList: true,
 * //   hasEdit: true,
 * //   hasShow: true,
 * //   hasCreate: true,
 * //   options: {},
 * //   icon: PostIcon,
 * // }
 *
 * @example // Pass a resource prop to check a different resource definition
 *
 * const definition = useResourceDefinition({ resource: 'posts' });
 */
declare const useResourceDefinition: (props?: UseResourceDefinitionOptions) => ResourceDefinition;
interface UseResourceDefinitionOptions {
    readonly resource?: string;
    readonly hasList?: boolean;
    readonly hasEdit?: boolean;
    readonly hasShow?: boolean;
    readonly hasCreate?: boolean;
}

/**
 * Get the definition of the all resources
 *
 * @example
 *
 * const definitions = useResourceDefinitions();
 * console.log(definitions.posts);
 * // {
 * //   name: 'posts',
 * //   hasList: true,
 * //   hasEdit: true,
 * //   hasShow: true,
 * //   hasCreate: true,
 * //   options: {},
 * //   icon: PostIcon,
 * // }
 */
declare const useResourceDefinitions: () => ResourceDefinitions;

declare const AuthContext: react.Context<AuthProvider>;

/**
 * Get the authProvider stored in the context
 */
declare const useAuthProvider: () => AuthProvider;

interface State$3 {
    isLoading: boolean;
    authenticated?: boolean;
}
/**
 * Hook for getting the authentication status
 *
 * Calls the authProvider.checkAuth() method asynchronously.
 *
 * The return value updates according to the authProvider request state:
 *
 * - isLoading: true just after mount, while the authProvider is being called. false once the authProvider has answered.
 * - authenticated: true while loading. then true or false depending on the authProvider response.
 *
 * To avoid rendering a component and force waiting for the authProvider response, use the useAuthState() hook
 * instead of the useAuthenticated() hook.
 *
 * You can render different content depending on the authenticated status.
 *
 * @see useAuthenticated()
 *
 * @param {Object} params Any params you want to pass to the authProvider
 *
 * @returns The current auth check state. Destructure as { authenticated, error, isLoading }.
 *
 * @example
 * import { useAuthState, Loading } from 'react-admin';
 *
 * const MyPage = () => {
 *     const { isLoading, authenticated } = useAuthState();
 *     if (isLoading) {
 *         return <Loading />;
 *     }
 *     if (authenticated) {
 *        return <AuthenticatedContent />;
 *     }
 *     return <AnonymousContent />;
 * };
 */
declare const useAuthState: (params?: any) => State$3;

interface State$2<Permissions, Error> {
    isLoading: boolean;
    permissions?: Permissions;
    error?: Error;
}
/**
 * Hook for getting user permissions
 *
 * Calls the authProvider.getPermissions() method asynchronously.
 * If the authProvider returns a rejected promise, returns empty permissions.
 *
 * The return value updates according to the request state:
 *
 * - start: { isLoading: true }
 * - success: { permissions: [any], isLoading: false }
 * - error: { error: [error from provider], isLoading: false }
 *
 * Useful to enable features based on user permissions
 *
 * @param {Object} params Any params you want to pass to the authProvider
 *
 * @returns The current auth check state. Destructure as { permissions, error, isLoading }.
 *
 * @example
 *     import { usePermissions } from 'react-admin';
 *
 *     const PostDetail = props => {
 *         const { isLoading, permissions } = usePermissions();
 *         if (!isLoading && permissions == 'editor') {
 *             return <PostEdit {...props} />
 *         } else {
 *             return <PostShow {...props} />
 *         }
 *     };
 */
declare const usePermissions: <Permissions_1 = any, Error_1 = any>(params?: {}) => State$2<Permissions_1, Error_1>;

interface State$1 {
    permissions?: any;
    error?: any;
}
/**
 * Hook for getting user permissions without the loading state.
 *
 * When compared to usePermissions, this hook doesn't cause a re-render
 * when the permissions haven't changed since the last call.
 *
 * This hook doesn't handle the loading state.
 *
 * @see usePermissions
 *
 * Calls the authProvider.getPermissions() method asynchronously.
 * If the authProvider returns a rejected promise, returns empty permissions.
 *
 * The return value updates according to the request state:
 *
 * - start:   { permissions: [previously fetched permissions for these params] }
 * - success: { permissions: [permissions returned by the authProvider (usually the same as on start)] }
 * - error:   { error: [error from provider] }
 *
 * Useful to enable features based on user permissions
 *
 * @param {Object} params Any params you want to pass to the authProvider
 *
 * @returns The current auth check state. Destructure as { permissions, error }.
 *
 * @example
 *     import { usePermissionsOptimized } from 'react-admin';
 *
 *     const PostDetail = props => {
 *         const { permissions } = usePermissionsOptimized();
 *         if (permissions !== 'editor') {
 *             return <Redirect to={`posts/${props.id}/show`} />
 *         } else {
 *             return <PostEdit {...props} />
 *         }
 *     };
 */
declare const usePermissionsOptimized: (params?: {}) => State$1;

/**
 * Get a callback for calling the authProvider.login() method
 * and redirect to the previous authenticated page (or the home page) on success.
 *
 * @see useAuthProvider
 *
 * @returns {Function} login callback
 *
 * @example
 *
 * import { useLogin } from 'react-admin';
 *
 * const LoginButton = () => {
 *     const [loading, setLoading] = useState(false);
 *     const login = useLogin();
 *     const handleClick = {
 *         setLoading(true);
 *         login({ username: 'john', password: 'p@ssw0rd' }, '/posts')
 *             .then(() => setLoading(false));
 *     }
 *     return <button onClick={handleClick}>Login</button>;
 * }
 */
declare const useLogin: () => Login;
/**
 * Log a user in by calling the authProvider.login() method
 *
 * @param {Object} params Login parameters to pass to the authProvider. May contain username/email, password, etc
 * @param {string} pathName The path to redirect to after login. By default, redirects to the home page, or to the last page visited after disconnection.
 *
 * @return {Promise} The authProvider response
 */
declare type Login = (params: any, pathName?: string) => Promise<any>;

/**
 * Get a callback for calling the authProvider.logout() method,
 * redirect to the login page, and clear the store.
 *
 * @see useAuthProvider
 *
 * @returns {Function} logout callback
 *
 * @example
 *
 * import { useLogout } from 'react-admin';
 *
 * const LogoutButton = () => {
 *     const logout = useLogout();
 *     const handleClick = () => logout();
 *     return <button onClick={handleClick}>Logout</button>;
 * }
 */
declare const useLogout: () => Logout;
/**
 * Log the current user out by calling the authProvider.logout() method,
 * and redirect them to the login screen.
 *
 * @param {Object} params The parameters to pass to the authProvider
 * @param {string} redirectTo The path name to redirect the user to (optional, defaults to login)
 * @param {boolean} redirectToCurrentLocationAfterLogin Whether the button shall record the current location to redirect to it after login. true by default.
 *
 * @return {Promise} The authProvider response
 */
declare type Logout = (params?: any, redirectTo?: string, redirectToCurrentLocationAfterLogin?: boolean) => Promise<any>;

/**
 * Return the current user identity by calling authProvider.getIdentity() on mount
 *
 * The return value updates according to the call state:
 *
 * - mount: { isLoading: true }
 * - success: { identity: Identity, isLoading: false }
 * - error: { error: Error, isLoading: false }
 *
 * The implementation is left to the authProvider.
 *
 * @returns The current user identity. Destructure as { identity, error, isLoading }.
 *
 * @example
 *
 * import { useGetIdentity, useGetOne } from 'react-admin';
 *
 * const PostDetail = ({ id }) => {
 *     const { data: post, isLoading: postLoading } = useGetOne('posts', { id });
 *     const { identity, isLoading: identityLoading } = useGetIdentity();
 *     if (postLoading || identityLoading) return <>Loading...</>;
 *     if (!post.lockedBy || post.lockedBy === identity.id) {
 *         // post isn't locked, or is locked by me
 *         return <PostEdit post={post} />
 *     } else {
 *         // post is locked by someone else and cannot be edited
 *         return <PostShow post={post} />
 *     }
 * }
 */
declare const useGetIdentity: () => State;
interface State {
    isLoading: boolean;
    identity?: UserIdentity;
    error?: any;
}

/**
 * Get a callback for calling the authProvider.getPermissions() method.
 *
 * @see useAuthProvider
 *
 * @returns {Function} getPermissions callback
 *
 * This is a low level hook. See those more specialized hooks
 * offering state handling.
 *
 * @see usePermissions
 *
 * @example
 *
 * import { useGetPermissions } from 'react-admin';
 *
 * const Roles = () => {
 *     const [permissions, setPermissions] = useState([]);
 *     const getPermissions = useGetPermissions();
 *     useEffect(() => {
 *         getPermissions().then(permissions => setPermissions(permissions))
 *     }, [])
 *     return (
 *         <ul>
 *             {permissions.map((permission, key) => (
 *                 <li key={key}>{permission}</li>
 *             ))}
 *         </ul>
 *     );
 * }
 */
declare const useGetPermissions: () => GetPermissions;
/**
 * Proxy for calling authProvider.getPermissions()
 *
 * @param {Object} params The parameters to pass to the authProvider
 *
 * @return {Promise} The authProvider response
 */
declare type GetPermissions = (params?: any) => Promise<any>;

/**
 * Returns a callback used to call the authProvider.checkError() method
 * and an error from the dataProvider. If the authProvider rejects the call,
 * the hook logs the user out and shows a logged out notification.
 *
 * Used in the useDataProvider hook to check for access denied responses
 * (e.g. 401 or 403 responses) and trigger a logout.
 *
 * @see useLogout
 * @see useDataProvider
 *
 * @returns {Function} logoutIfAccessDenied callback
 *
 * @example
 *
 * import { useLogoutIfAccessDenied, useNotify, DataProviderContext } from 'react-admin';
 *
 * const FetchRestrictedResource = () => {
 *     const dataProvider = useContext(DataProviderContext);
 *     const logoutIfAccessDenied = useLogoutIfAccessDenied();
 *     const notify = useNotify()
 *     useEffect(() => {
 *         dataProvider.getOne('secret', { id: 123 })
 *             .catch(error => {
 *                  logoutIfAccessDenied(error);
 *                  notify('server error', 'warning');
 *              })
 *     }, []);
 *     // ...
 * }
 */
declare const useLogoutIfAccessDenied: () => LogoutIfAccessDenied;
/**
 * Call the authProvider.authError() method, using the error passed as argument.
 * If the authProvider rejects the call, logs the user out and shows a logged out notification.
 *
 * @param {Error} error An Error object (usually returned by the dataProvider)
 * @param {boolean} disableNotification Avoid showing a notification after the user is logged out. false by default.
 *
 * @return {Promise} Resolved to true if there was a logout, false otherwise
 */
declare type LogoutIfAccessDenied = (error?: any, 
/** @deprecated to disable the notification, authProvider.checkAuth() should return an object with an error property set to true */
disableNotification?: boolean) => Promise<boolean>;

declare const _default$c: (legacyAuthProvider: LegacyAuthProvider) => AuthProvider;

/**
 * Restrict access to children to authenticated users.
 * Redirects anonymous users to the login page.
 *
 * Use it to decorate your custom page components to require
 * authentication.
 *
 * You can set additional `authParams` at will if your authProvider
 * requires it.
 *
 * @see useAuthenticated
 *
 * @example
 *     import { Authenticated } from 'react-admin';
 *
 *     const CustomRoutes = [
 *         <Route path="/foo" render={() =>
 *             <Authenticated authParams={{ foo: 'bar' }}>
 *                 <Foo />
 *             </Authenticated>
 *         } />
 *     ];
 *     const App = () => (
 *         <Admin customRoutes={customRoutes}>
 *             ...
 *         </Admin>
 *     );
 */
declare const Authenticated: (props: AuthenticatedProps) => JSX.Element;
interface AuthenticatedProps {
    children: ReactNode;
    authParams?: object;
}

/**
 * Restrict access to authenticated users.
 * Redirect anonymous users to the login page.
 *
 * Use it in your custom page components to require
 * authentication.
 *
 * You can set additional `authParams` at will if your authProvider
 * requires it.
 *
 * @example
 *     import { useAuthenticated } from 'react-admin';
 *     const FooPage = () => {
 *         useAuthenticated();
 *         return <Foo />;
 *     }
 *     const CustomRoutes = [
 *         <Route path="/foo" render={() => <FooPage />} />
 *     ];
 *     const App = () => (
 *         <Admin customRoutes={customRoutes}>
 *             ...
 *         </Admin>
 *     );
 */
declare const useAuthenticated: <ParamsType = any>(options?: UseAuthenticatedOptions<ParamsType>) => void;
declare type UseAuthenticatedOptions<ParamsType> = {
    enabled?: boolean;
    params?: ParamsType;
};

/**
 * Get a callback for calling the authProvider.checkAuth() method.
 * In case of rejection, redirects to the login page, displays a notification,
 * and throws an error.
 *
 * This is a low level hook. See those more specialized hooks
 * for common authentication tasks, based on useCheckAuth.
 *
 * @see useAuthenticated
 * @see useAuthState
 *
 * @returns {Function} checkAuth callback
 *
 * @example
 *
 * import { useCheckAuth } from 'react-admin';
 *
 * const MyProtectedPage = () => {
 *     const checkAuth = useCheckAuth();
 *     useEffect(() => {
 *         checkAuth().catch(() => {});
 *     }, []);
 *     return <p>Private content: EZAEZEZAET</p>
 * } // tip: use useAuthenticated() hook instead
 *
 * const MyPage = () => {
 *     const checkAuth = useCheckAuth();
 *     const [authenticated, setAuthenticated] = useState(true); // optimistic auth
 *     useEffect(() => {
 *         checkAuth({}, false)
 *              .then(() => setAuthenticated(true))
 *              .catch(() => setAuthenticated(false));
 *     }, []);
 *     return authenticated ? <Bar /> : <BarNotAuthenticated />;
 * } // tip: use useAuthState() hook instead
 */
declare const useCheckAuth: () => CheckAuth;
/**
 * Check if the current user is authenticated by calling authProvider.checkAuth().
 * Logs the user out on failure.
 *
 * @param {Object} params The parameters to pass to the authProvider
 * @param {boolean} logoutOnFailure Whether the user should be logged out if the authProvider fails to authenticate them. True by default.
 * @param {string} redirectTo The login form url. Defaults to '/login'
 * @param {boolean} disableNotification Avoid showing a notification after the user is logged out. false by default.
 *
 * @return {Promise} Resolved to the authProvider response if the user passes the check, or rejected with an error otherwise
 */
declare type CheckAuth = (params?: any, logoutOnFailure?: boolean, redirectTo?: string, 
/** @deprecated to disable the notification, authProvider.checkAuth() should return an object with an error property set to true */
disableNotification?: boolean) => Promise<any>;

interface ConvertedDataProvider extends DataProvider {
    (type: string, resource: string, params: any): Promise<any>;
}
/**
 * Turn a function-based dataProvider to an object-based one
 *
 * Allows using legacy dataProviders transparently.
 *
 * @param {Function} legacyDataProvider A legacy dataProvider (type, resource, params) => Promise<any>
 *
 * @returns {Object} A dataProvider that react-admin can use
 */
declare const convertLegacyDataProvider: (legacyDataProvider: LegacyDataProvider) => ConvertedDataProvider;

declare const DataProviderContext: react.Context<DataProvider<string>>;

declare class HttpError extends Error {
    readonly message: any;
    readonly status: any;
    readonly body: any;
    constructor(message: any, status: any, body?: any);
}

interface Options extends RequestInit {
    user?: {
        authenticated?: boolean;
        token?: string;
    };
}
declare const createHeadersFromOptions: (options: Options) => Headers;
declare const fetchJson: (url: any, options?: Options) => Promise<{
    status: number;
    headers: Headers;
    body: string;
    json: any;
}>;
declare const queryParameters: typeof stringify;
declare const flattenObject: (value: any, path?: any[]) => any;

type fetch_Options = Options;
declare const fetch_createHeadersFromOptions: typeof createHeadersFromOptions;
declare const fetch_fetchJson: typeof fetchJson;
declare const fetch_queryParameters: typeof queryParameters;
declare const fetch_flattenObject: typeof flattenObject;
declare namespace fetch {
  export {
    fetch_Options as Options,
    fetch_createHeadersFromOptions as createHeadersFromOptions,
    fetch_fetchJson as fetchJson,
    fetch_queryParameters as queryParameters,
    fetch_flattenObject as flattenObject,
  };
}

declare const _default$b: EventEmitter<string | symbol, any>;

declare type DataProviderMatcher = (resource: string) => DataProvider;
/**
 * Combine multiple data providers into one.
 *
 * @param dataProviderMatcher A function that returns a data provider for a given resource.
 *
 * @example
 * const dataProvider = combineDataProviders(resource => {
 *    switch(resource) {
 *       case 'posts':
 *       case 'comments':
 *          return dataProvider1;
 *       case 'users':
 *          return dataProvider2;
 *       default:
 *         throw new Error('Unknown resource');
 *    }
 * });
 */
declare const combineDataProviders: (dataProviderMatcher: DataProviderMatcher) => DataProvider;

declare const GET_LIST = "GET_LIST";
declare const GET_ONE = "GET_ONE";
declare const GET_MANY = "GET_MANY";
declare const GET_MANY_REFERENCE = "GET_MANY_REFERENCE";
declare const CREATE = "CREATE";
declare const UPDATE = "UPDATE";
declare const UPDATE_MANY = "UPDATE_MANY";
declare const DELETE = "DELETE";
declare const DELETE_MANY = "DELETE_MANY";
declare const fetchActionsWithRecordResponse: string[];
declare const fetchActionsWithArrayOfIdentifiedRecordsResponse: string[];
declare const fetchActionsWithArrayOfRecordsResponse: string[];
declare const fetchActionsWithTotalResponse: string[];
declare const sanitizeFetchType: (fetchType: string) => string;

declare const defaultDataProvider: {
    create: () => Promise<{
        data: any;
    }>;
    delete: () => Promise<{
        data: any;
    }>;
    deleteMany: () => Promise<{
        data: any[];
    }>;
    getList: () => Promise<{
        data: any[];
        total: number;
    }>;
    getMany: () => Promise<{
        data: any[];
    }>;
    getManyReference: () => Promise<{
        data: any[];
        total: number;
    }>;
    getOne: () => Promise<{
        data: any;
    }>;
    update: () => Promise<{
        data: any;
    }>;
    updateMany: () => Promise<{
        data: any[];
    }>;
};

/**
 * A dataProvider meant to be used in tests only. You can override any of its methods by passing a partial dataProvider.
 */
declare const testDataProvider: (overrides?: Partial<DataProvider>) => DataProvider;

/**
 * Hook for getting a dataProvider
 *
 * Gets a dataProvider object, which behaves just like the real dataProvider
 * (same methods returning a Promise). But it's actually a Proxy object,
 * which validates the response format, and logs the user out upon error
 * if authProvider.checkError() rejects.
 *
 * @return dataProvider
 *
 * @example Basic usage
 *
 * import * as React from 'react';
 * import { useState } from 'react';
 * import { useDataProvider } from 'react-admin';
 *
 * const PostList = () => {
 *      const [posts, setPosts] = useState([])
 *      const dataProvider = useDataProvider();
 *      useEffect(() => {
 *          dataProvider.getList('posts', { filter: { status: 'pending' }})
 *            .then(({ data }) => setPosts(data));
 *      }, [])
 *
 *      return (
 *          <Fragment>
 *              {posts.map((post, key) => <PostDetail post={post} key={key} />)}
 *          </Fragment>
 *     );
 * }
 *
 * @example Handling all states (loading, error, success)
 *
 * import { useState, useEffect } from 'react';
 * import { useDataProvider } from 'react-admin';
 *
 * const UserProfile = ({ userId }) => {
 *     const dataProvider = useDataProvider();
 *     const [user, setUser] = useState();
 *     const [loading, setLoading] = useState(true);
 *     const [error, setError] = useState();
 *     useEffect(() => {
 *         dataProvider.getOne('users', { id: userId })
 *             .then(({ data }) => {
 *                 setUser(data);
 *                 setLoading(false);
 *             })
 *             .catch(error => {
 *                 setError(error);
 *                 setLoading(false);
 *             })
 *     }, []);
 *
 *     if (loading) return <Loading />;
 *     if (error) return <Error />
 *     if (!user) return null;
 *
 *     return (
 *         <ul>
 *             <li>Name: {user.name}</li>
 *             <li>Email: {user.email}</li>
 *         </ul>
 *     )
 * }
 */
declare const useDataProvider: <TDataProvider extends DataProvider<string> = DataProvider<string>>() => TDataProvider;

/**
 * Check if react-query has already fetched data for a query key.
 *
 * This hook is reactive.
 *
 * @example
 * const isCustomerLoaded = useIsDataLoaded(['customers', 'getOne', { id: customerId }]);
 *
 * @returns {boolean} true if the data is loaded, false otherwise
 */
declare const useIsDataLoaded: (queryKey: any, options?: {
    enabled?: boolean;
}) => boolean;

/**
 * Get the state of the dataProvider connection.
 *
 * Returns true if a query or a mutation is pending.
 *
 * Custom implementation because react-query's useIsFetching and useIsMutating
 * render each time the number of active queries changes, which is too often.
 *
 * @see useIsFetching
 * @see useIsMutating
 */
declare const useLoading: () => boolean;

/**
 * Hook for triggering a page refresh. Returns a callback function.
 *
 * The callback invalidates all queries and refetches the active ones.
 * Any component depending on react-query data will be re-rendered.
 *
 * @example
 *
 * const refresh = useRefresh();
 * const handleClick = () => {
 *     refresh();
 * };
 */
declare const useRefresh: () => () => void;

/**
 * Call the dataProvider.getOne() method and return the resolved value
 * as well as the loading state.
 *
 * The return value updates according to the request state:
 *
 * - start: { isLoading: true, isFetching: true, refetch }
 * - success: { data: [data from response], isLoading: false, refetch }
 * - error: { error: [error from response], isLoading: false, refetch }
 *
 * This hook will return the cached result when called a second time
 * with the same parameters, until the response arrives.
 *
 * @param resource The resource name, e.g. 'posts'
 * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }
 * @param {Options} options Options object to pass to the react-query queryClient.
 *
 * @typedef Params
 * @prop id a resource identifier, e.g. 123
 *
 * @typedef Options
 * @prop enabled Flag to conditionally run the query. If it's false, the query will not run
 * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }
 * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }
 *
 * @returns The current request state. Destructure as { data, error, isLoading, refetch }.
 *
 * @example
 *
 * import { useGetOne } from 'react-admin';
 *
 * const UserProfile = ({ record }) => {
 *     const { data, isLoading, error } = useGetOne('users', { id: record.id });
 *     if (isLoading) { return <Loading />; }
 *     if (error) { return <p>ERROR</p>; }
 *     return <div>User {data.username}</div>;
 * };
 */
declare const useGetOne: <RecordType extends RaRecord = any>(resource: string, { id, meta }: GetOneParams<RecordType>, options?: UseQueryOptions<RecordType, unknown, RecordType, react_query.QueryKey>) => UseGetOneHookValue<RecordType>;
declare type UseGetOneHookValue<RecordType extends RaRecord = any> = UseQueryResult<RecordType>;

/**
 * Call the dataProvider.getList() method and return the resolved result
 * as well as the loading state.
 *
 * The return value updates according to the request state:
 *
 * - start: { isLoading: true, refetch }
 * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }
 * - error: { error: [error from response], isLoading: false, refetch }
 *
 * This hook will return the cached result when called a second time
 * with the same parameters, until the response arrives.
 *
 * @param {string} resource The resource name, e.g. 'posts'
 * @param {Params} params The getList parameters { pagination, sort, filter, meta }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 *
 * @typedef Params
 * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }
 * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }
 * @prop params.filter The request filters, e.g. { title: 'hello, world' }
 * @prop params.meta Optional meta parameters
 *
 * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.
 *
 * @example
 *
 * import { useGetList } from 'react-admin';
 *
 * const LatestNews = () => {
 *     const { data, total, isLoading, error } = useGetList(
 *         'posts',
 *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }
 *     );
 *     if (isLoading) { return <Loading />; }
 *     if (error) { return <p>ERROR</p>; }
 *     return <ul>{data.map(item =>
 *         <li key={item.id}>{item.title}</li>
 *     )}</ul>;
 * };
 */
declare const useGetList: <RecordType extends RaRecord = any>(resource: string, params?: Partial<GetListParams>, options?: UseQueryOptions<GetListResult<RecordType>, Error, GetListResult<RecordType>, react_query.QueryKey>) => UseGetListHookValue<RecordType>;
declare type UseGetListHookValue<RecordType extends RaRecord = any> = UseQueryResult<RecordType[], Error> & {
    total?: number;
    pageInfo?: {
        hasNextPage?: boolean;
        hasPreviousPage?: boolean;
    };
};

/**
 * Call the dataProvider.getMany() method and return the resolved result
 * as well as the loading state.
 *
 * The return value updates according to the request state:
 *
 * - start: { isLoading: true, refetch }
 * - success: { data: [data from store], isLoading: false, refetch }
 * - error: { error: [error from response], isLoading: false, refetch }
 *
 * This hook will return the cached result when called a second time
 * with the same parameters, until the response arrives.
 *
 * @param {string} resource The resource name, e.g. 'posts'
 * @param {Params} params The getMany parameters { ids, meta }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 *
 * @typedef Params
 * @prop params.ids The ids to get, e.g. [123, 456, 789]
 * @prop params.meta Optional meta parameters
 *
 * @returns The current request state. Destructure as { data, error, isLoading, refetch }.
 *
 * @example
 *
 * import { useGetMany } from 'react-admin';
 *
 * const PostTags = ({ post }) => {
 *     const { data, isLoading, error } = useGetMany(
 *         'tags',
 *         { ids: post.tags },
 *     );
 *     if (isLoading) { return <Loading />; }
 *     if (error) { return <p>ERROR</p>; }
 *     return <ul>{data.map(tag =>
 *         <li key={tag.id}>{tag.name}</li>
 *     )}</ul>;
 * };
 */
declare const useGetMany: <RecordType extends RaRecord = any>(resource: string, params?: Partial<GetManyParams>, options?: UseQueryOptions<RecordType[], Error, RecordType[], react_query.QueryKey>) => UseGetManyHookValue<RecordType>;
declare type UseGetManyHookValue<RecordType extends RaRecord = any> = UseQueryResult<RecordType[], Error>;

/**
 * Call the dataProvider.getMany() method and return the resolved result
 * as well as the loading state.
 *
 * The return value updates according to the request state:
 *
 * - start: { isLoading: true, isFetching: true, refetch }
 * - success: { data: [data from response], isLoading: false, isFetching: false, refetch }
 * - error: { error: [error from response], isLoading: false, isFetching: false, refetch }
 *
 * This hook will return the cached result when called a second time
 * with the same parameters, until the response arrives.
 *
 * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:
 *
 * useGetManyAggregate('tags', [1, 2, 3]);
 * useGetManyAggregate('tags', [3, 4]);
 *
 * during the same tick, the hook will only call the dataProvider once with the following parameters:
 *
 * dataProvider.getMany('tags', [1, 2, 3, 4])
 *
 * @param resource The resource name, e.g. 'posts'
 * @param {Params} params The getMany parameters { ids, meta }
 * @param {Object} options Options object to pass to the dataProvider.
 * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run
 * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }
 * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }
 *
 * @typedef Params
 * @prop params.ids The ids to get, e.g. [123, 456, 789]
 * @prop params.meta Optional meta parameters

 * @returns The current request state. Destructure as { data, error, isLoading, isFetching, refetch }.
 *
 * @example
 *
 * import { useGetManyAggregate } from 'react-admin';
 *
 * const PostTags = ({ record }) => {
 *     const { data, isLoading, error } = useGetManyAggregate('tags', { ids: record.tagIds });
 *     if (isLoading) { return <Loading />; }
 *     if (error) { return <p>ERROR</p>; }
 *     return (
 *          <ul>
 *              {data.map(tag => (
 *                  <li key={tag.id}>{tag.name}</li>
 *              ))}
 *          </ul>
 *      );
 * };
 */
declare const useGetManyAggregate: <RecordType extends RaRecord = any>(resource: string, params: GetManyParams, options?: UseQueryOptions<RecordType[], Error, RecordType[], react_query.QueryKey>) => UseGetManyHookValue<RecordType>;

/**
 * Call the dataProvider.getManyReference() method and return the resolved result
 * as well as the loading state.
 *
 * The return value updates according to the request state:
 *
 * - start: { isLoading: true, refetch }
 * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }
 * - error: { error: [error from response], isLoading: false, refetch }
 *
 * This hook will return the cached result when called a second time
 * with the same parameters, until the response arrives.
 *
 * @param {string} resource The resource name, e.g. 'posts'
 * @param {Params} params The getManyReference parameters { target, id, pagination, sort, filter, meta }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 *
 * @typedef Params
 * @prop params.target The target resource key, e.g. 'post_id'
 * @prop params.id The identifier of the record to look for in target, e.g. '123'
 * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }
 * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }
 * @prop params.filter The request filters, e.g. { title: 'hello, world' }
 * @prop params.meta Optional meta parameters
 *
 *
 * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.
 *
 * @example
 *
 * import { useGetManyReference } from 'react-admin';
 *
 * const PostComments = ({ record }) => {
 *     // fetch all comments related to the current record
 *     const { data, isLoading, error } = useGetManyReference(
 *         'comments',
 *         { target: 'post_id', id: record.id, pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }
 *     );
 *     if (isLoading) { return <Loading />; }
 *     if (error) { return <p>ERROR</p>; }
 *     return <ul>{data.map(comment =>
 *         <li key={comment.id}>{comment.body}</li>
 *     )}</ul>;
 * };
 */
declare const useGetManyReference: <RecordType extends RaRecord = any>(resource: string, params?: Partial<GetManyReferenceParams>, options?: UseQueryOptions<{
    data: RecordType[];
    total: number;
}, Error, {
    data: RecordType[];
    total: number;
}, react_query.QueryKey>) => UseGetManyReferenceHookValue<RecordType>;
declare type UseGetManyReferenceHookValue<RecordType extends RaRecord = any> = UseQueryResult<RecordType[], Error> & {
    total?: number;
    pageInfo?: {
        hasNextPage?: boolean;
        hasPreviousPage?: boolean;
    };
};

/**
 * Get a callback to call the dataProvider.create() method, the result and the loading state.
 *
 * @param {string} resource
 * @param {Params} params The create parameters { data }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 *
 * @typedef Params
 * @prop params.data The record to create, e.g. { title: 'hello, world' }
 *
 * @returns The current mutation state. Destructure as [create, { data, error, isLoading }].
 *
 * The return value updates according to the request state:
 *
 * - initial: [create, { isLoading: false, isIdle: true }]
 * - start:   [create, { isLoading: true }]
 * - success: [create, { data: [data from response], isLoading: false, isSuccess: true }]
 * - error:   [create, { error: [error from response], isLoading: false, isError: true }]
 *
 * The create() function must be called with a resource and a parameter object: create(resource, { data, meta }, options)
 *
 * This hook uses react-query useMutation under the hood.
 * This means the state object contains mutate, isIdle, reset and other react-query methods.
 *
 * @see https://react-query.tanstack.com/reference/useMutation
 *
 * @example // set params when calling the create callback
 *
 * import { useCreate } from 'react-admin';
 *
 * const LikeButton = ({ record }) => {
 *     const like = { postId: record.id };
 *     const [create, { isLoading, error }] = useCreate();
 *     const handleClick = () => {
 *         create('likes', { data: like })
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={handleClick}>Like</button>;
 * };
 *
 * @example // set params when calling the hook
 *
 * import { useCreate } from 'react-admin';
 *
 * const LikeButton = ({ record }) => {
 *     const like = { postId: record.id };
 *     const [create, { isLoading, error }] = useCreate('likes', { data: like });
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={() => create()}>Like</button>;
 * };
 *
 * @example // TypeScript
 * const [create, { data }] = useCreate<Product>('products', { data: product });
 *                    \-- data is Product
 */
declare const useCreate: <RecordType extends RaRecord = any>(resource?: string, params?: Partial<CreateParams<Partial<RecordType>>>, options?: UseCreateOptions<RecordType>) => UseCreateResult<RecordType, boolean>;
interface UseCreateMutateParams<RecordType extends RaRecord = any> {
    resource?: string;
    data?: Partial<RecordType>;
    meta?: any;
}
declare type UseCreateOptions<RecordType extends RaRecord = any> = UseMutationOptions<RecordType, unknown, Partial<UseCreateMutateParams<RecordType>>>;
declare type UseCreateResult<RecordType extends RaRecord = any, TReturnPromise extends boolean = boolean> = [
    (resource?: string, params?: Partial<CreateParams<Partial<RecordType>>>, options?: MutateOptions<RecordType, unknown, Partial<UseCreateMutateParams<RecordType>>, unknown> & {
        returnPromise?: TReturnPromise;
    }) => Promise<TReturnPromise extends true ? RecordType : void>,
    UseMutationResult<RecordType, unknown, Partial<UseCreateMutateParams<RecordType>>, unknown>
];

/**
 * Get a callback to call the dataProvider.update() method, the result and the loading state.
 *
 * @param {string} resource
 * @param {Params} params The update parameters { id, data, previousData, meta }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }
 *
 * @typedef Params
 * @prop params.id The resource identifier, e.g. 123
 * @prop params.data The updates to merge into the record, e.g. { views: 10 }
 * @prop params.previousData The record before the update is applied
 * @prop params.meta Optional meta data
 *
 * @returns The current mutation state. Destructure as [update, { data, error, isLoading }].
 *
 * The return value updates according to the request state:
 *
 * - initial: [update, { isLoading: false, isIdle: true }]
 * - start:   [update, { isLoading: true }]
 * - success: [update, { data: [data from response], isLoading: false, isSuccess: true }]
 * - error:   [update, { error: [error from response], isLoading: false, isError: true }]
 *
 * The update() function must be called with a resource and a parameter object: update(resource, { id, data, previousData }, options)
 *
 * This hook uses react-query useMutation under the hood.
 * This means the state object contains mutate, isIdle, reset and other react-query methods.
 *
 * @see https://react-query.tanstack.com/reference/useMutation
 *
 * @example // set params when calling the update callback
 *
 * import { useUpdate } from 'react-admin';
 *
 * const IncreaseLikeButton = ({ record }) => {
 *     const diff = { likes: record.likes + 1 };
 *     const [update, { isLoading, error }] = useUpdate();
 *     const handleClick = () => {
 *         update('likes', { id: record.id, data: diff, previousData: record })
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={handleClick}>Like</div>;
 * };
 *
 * @example // set params when calling the hook
 *
 * import { useUpdate } from 'react-admin';
 *
 * const IncreaseLikeButton = ({ record }) => {
 *     const diff = { likes: record.likes + 1 };
 *     const [update, { isLoading, error }] = useUpdate('likes', { id: record.id, data: diff, previousData: record });
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={() => update()}>Like</button>;
 * };
 *
 * @example // TypeScript
 * const [update, { data }] = useUpdate<Product>('products', { id, data: diff, previousData: product });
 *                    \-- data is Product
 */
declare const useUpdate: <RecordType extends RaRecord = any>(resource?: string, params?: Partial<UpdateParams<RecordType>>, options?: UseUpdateOptions<RecordType>) => UseUpdateResult<RecordType, boolean>;
interface UseUpdateMutateParams<RecordType extends RaRecord = any> {
    resource?: string;
    id?: RecordType['id'];
    data?: Partial<RecordType>;
    previousData?: any;
    meta?: any;
}
declare type UseUpdateOptions<RecordType extends RaRecord = any> = UseMutationOptions<RecordType, unknown, Partial<UseUpdateMutateParams<RecordType>>> & {
    mutationMode?: MutationMode;
};
declare type UseUpdateResult<RecordType extends RaRecord = any, TReturnPromise extends boolean = boolean> = [
    (resource?: string, params?: Partial<UpdateParams<RecordType>>, options?: MutateOptions<RecordType, unknown, Partial<UseUpdateMutateParams<RecordType>>, unknown> & {
        mutationMode?: MutationMode;
        returnPromise?: TReturnPromise;
    }) => Promise<TReturnPromise extends true ? RecordType : void>,
    UseMutationResult<RecordType, unknown, Partial<UpdateParams<RecordType> & {
        resource?: string;
    }>, unknown>
];

/**
 * Get a callback to call the dataProvider.updateMany() method, the result and the loading state.
 *
 * @param {string} resource
 * @param {Params} params The updateMany parameters { ids, data, meta }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }
 *
 * @typedef Params
 * @prop params.ids The resource identifiers, e.g. [123, 456]
 * @prop params.data The updates to merge into the record, e.g. { views: 10 }
 * @prop params.meta Optional meta parameters
 *
 * @returns The current mutation state. Destructure as [updateMany, { data, error, isLoading }].
 *
 * The return value updates according to the request state:
 *
 * - initial: [updateMany, { isLoading: false, isIdle: true }]
 * - start:   [updateMany, { isLoading: true }]
 * - success: [updateMany, { data: [data from response], isLoading: false, isSuccess: true }]
 * - error:   [updateMany, { error: [error from response], isLoading: false, isError: true }]
 *
 * The updateMany() function must be called with a resource and a parameter object: updateMany(resource, { ids, data, previousData }, options)
 *
 * This hook uses react-query useMutation under the hood.
 * This means the state object contains mutate, isIdle, reset and other react-query methods.
 *
 * @see https://react-query.tanstack.com/reference/useMutation
 *
 * @example // set params when calling the updateMany callback
 *
 * import { useUpdateMany } from 'react-admin';
 *
 * const BulkResetViewsButton = ({ selectedIds }) => {
 *     const [updateMany, { isLoading, error }] = useUpdateMany();
 *     const handleClick = () => {
 *         updateMany('posts', { ids: selectedIds, data: { views: 0 } });
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={handleClick}>Reset views</button>;
 * };
 *
 * @example // set params when calling the hook
 *
 * import { useUpdateMany } from 'react-admin';
 *
 * const BulkResetViewsButton = ({ selectedIds }) => {
 *     const [updateMany, { isLoading, error }] = useUpdateMany('posts', { ids: selectedIds, data: { views: 0 } });
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={() => updateMany()}>Reset views</button>;
 * };
 */
declare const useUpdateMany: <RecordType extends RaRecord = any>(resource?: string, params?: Partial<UpdateManyParams<Partial<RecordType>>>, options?: UseUpdateManyOptions<RecordType>) => UseUpdateManyResult<RecordType>;
interface UseUpdateManyMutateParams<RecordType extends RaRecord = any> {
    resource?: string;
    ids?: Array<RecordType['id']>;
    data?: Partial<RecordType>;
    previousData?: any;
    meta?: any;
}
declare type UseUpdateManyOptions<RecordType extends RaRecord = any> = UseMutationOptions<Array<RecordType['id']>, unknown, Partial<UseUpdateManyMutateParams<RecordType>>> & {
    mutationMode?: MutationMode;
};
declare type UseUpdateManyResult<RecordType extends RaRecord = any> = [
    (resource?: string, params?: Partial<UpdateManyParams<RecordType>>, options?: MutateOptions<Array<RecordType['id']>, unknown, Partial<UseUpdateManyMutateParams<RecordType>>, unknown> & {
        mutationMode?: MutationMode;
    }) => Promise<void>,
    UseMutationResult<Array<RecordType['id']>, unknown, Partial<UpdateManyParams<Partial<RecordType>> & {
        resource?: string;
    }>, unknown>
];

/**
 * Get a callback to call the dataProvider.delete() method, the result and the loading state.
 *
 * @param {string} resource
 * @param {Params} params The delete parameters { id, previousData }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }
 *
 * @typedef Params
 * @prop params.id The resource identifier, e.g. 123
 * @prop params.previousData The record before the update is applied
 *
 * @returns The current mutation state. Destructure as [deleteOne, { data, error, isLoading }].
 *
 * The return value updates according to the request state:
 *
 * - initial: [deleteOne, { isLoading: false, isIdle: true }]
 * - start:   [deleteOne, { isLoading: true }]
 * - success: [deleteOne, { data: [data from response], isLoading: false, isSuccess: true }]
 * - error:   [deleteOne, { error: [error from response], isLoading: false, isError: true }]
 *
 * The deleteOne() function must be called with a resource and a parameter object: deleteOne(resource, { id, previousData, meta }, options)
 *
 * This hook uses react-query useMutation under the hood.
 * This means the state object contains mutate, isIdle, reset and other react-query methods.
 *
 * @see https://react-query.tanstack.com/reference/useMutation
 *
 * @example // set params when calling the deleteOne callback
 *
 * import { useDelete } from 'react-admin';
 *
 * const DeleteButton = ({ record }) => {
 *     const [deleteOne, { isLoading, error }] = useDelete();
 *     const handleClick = () => {
 *         deleteOne('likes', { id: record.id }, record)
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={handleClick}>Delete</div>;
 * };
 *
 * @example // set params when calling the hook
 *
 * import { useDelete } from 'react-admin';
 *
 * const DeleteButton = ({ record }) => {
 *     const [deleteOne, { isLoading, error }] = useDelete('likes', { id: record.id }, record);
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={() => deleteOne()}>Delete</button>;
 * };
 *
 * @example // TypeScript
 * const [delete, { data }] = useDelete<Product>('products', { id, previousData: product });
 *                    \-- data is Product
 */
declare const useDelete: <RecordType extends RaRecord = any>(resource?: string, params?: Partial<DeleteParams<RecordType>>, options?: UseDeleteOptions<RecordType>) => UseDeleteResult<RecordType>;
interface UseDeleteMutateParams<RecordType extends RaRecord = any> {
    resource?: string;
    id?: RecordType['id'];
    data?: Partial<RecordType>;
    previousData?: any;
    meta?: any;
}
declare type UseDeleteOptions<RecordType extends RaRecord = any> = UseMutationOptions<RecordType, unknown, Partial<UseDeleteMutateParams<RecordType>>> & {
    mutationMode?: MutationMode;
};
declare type UseDeleteResult<RecordType extends RaRecord = any> = [
    (resource?: string, params?: Partial<DeleteParams<RecordType>>, options?: MutateOptions<RecordType, unknown, Partial<UseDeleteMutateParams<RecordType>>, unknown> & {
        mutationMode?: MutationMode;
    }) => Promise<void>,
    UseMutationResult<RecordType, unknown, Partial<DeleteParams<RecordType> & {
        resource?: string;
    }>, unknown>
];

/**
 * Get a callback to call the dataProvider.delete() method, the result and the loading state.
 *
 * @param {string} resource
 * @param {Params} params The delete parameters { ids }
 * @param {Object} options Options object to pass to the queryClient.
 * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }
 * May include a mutation mode (optimistic/pessimistic/undoable), e.g. { mutationMode: 'undoable' }
 *
 * @typedef Params
 * @prop params.ids The resource identifiers, e.g. [123, 456]
 *
 * @returns The current mutation state. Destructure as [deleteMany, { data, error, isLoading }].
 *
 * The return value updates according to the request state:
 *
 * - initial: [deleteMany, { isLoading: false, isIdle: true }]
 * - start:   [deleteMany, { isLoading: true }]
 * - success: [deleteMany, { data: [data from response], isLoading: false, isSuccess: true }]
 * - error:   [deleteMany, { error: [error from response], isLoading: false, isError: true }]
 *
 * The deleteMany() function must be called with a resource and a parameter object: deleteMany(resource, { ids, meta }, options)
 *
 * This hook uses react-query useMutation under the hood.
 * This means the state object contains mutate, isIdle, reset and other react-query methods.
 *
 * @see https://react-query.tanstack.com/reference/useMutation
 *
 * @example // set params when calling the deleteMany callback
 *
 * import { useDeleteMany } from 'react-admin';
 *
 * const BulkDeletePostsButton = ({ selectedIds }) => {
 *     const [deleteMany, { isLoading, error }] = useDeleteMany();
 *     const handleClick = () => {
 *         deleteMany('posts', { ids: selectedIds })
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={handleClick}>Delete selected posts</button>;
 * };
 *
 * @example // set params when calling the hook
 *
 * import { useDeleteMany } from 'react-admin';
 *
 * const BulkDeletePostsButton = ({ selectedIds }) => {
 *     const [deleteMany, { isLoading, error }] = useDeleteMany('posts', { ids: selectedIds });
 *     const handleClick = () => {
 *         deleteMany()
 *     }
 *     if (error) { return <p>ERROR</p>; }
 *     return <button disabled={isLoading} onClick={handleClick}>Delete selected posts</button>;
 * };
 *
 * @example // TypeScript
 * const [deleteMany, { data }] = useDeleteMany<Product>('products', { ids });
 *                        \-- data is Product
 */
declare const useDeleteMany: <RecordType extends RaRecord = any>(resource?: string, params?: Partial<DeleteManyParams<RecordType>>, options?: UseDeleteManyOptions<RecordType>) => UseDeleteManyResult<RecordType>;
interface UseDeleteManyMutateParams<RecordType extends RaRecord = any> {
    resource?: string;
    ids?: RecordType['id'][];
    meta?: any;
}
declare type UseDeleteManyOptions<RecordType extends RaRecord = any> = UseMutationOptions<RecordType['id'][], unknown, Partial<UseDeleteManyMutateParams<RecordType>>> & {
    mutationMode?: MutationMode;
};
declare type UseDeleteManyResult<RecordType extends RaRecord = any> = [
    (resource?: string, params?: Partial<DeleteManyParams<RecordType>>, options?: MutateOptions<RecordType['id'][], unknown, Partial<UseDeleteManyMutateParams<RecordType>>, unknown> & {
        mutationMode?: MutationMode;
    }) => Promise<void>,
    UseMutationResult<RecordType['id'][], unknown, Partial<DeleteManyParams<RecordType> & {
        resource?: string;
    }>, unknown>
];

declare const defaultExporter: Exporter;

declare const _default$a: (csv: any, filename: any) => void;

declare const ExporterContext: react.Context<false | Exporter>;

/**
 * Helper function for calling the dataProvider.getMany() method,
 * and getting a Promise for the records indexed by id in return.
 *
 * @example
 *     fetchRelatedRecords(dataProvider)(records, 'post_id', 'posts').then(posts =>
 *         posts.map(record => ({
 *             ...record,
 *             post_title: posts[record.post_id].title,
 *         }))
 *     );
 */
declare const fetchRelatedRecords: (dataProvider: DataProvider) => (data: any, field: any, resource: any) => Promise<any>;

declare const TestTranslationProvider: ({ translate, messages, children, }: any) => JSX.Element;

declare type I18nContextProps = I18nProvider;
declare const I18nContext: react.Context<I18nProvider>;

/**
 * Store the i18nProvider in a context, and rerender children when the locale changes
 */
declare const I18nContextProvider: ({ value, children, }: I18nContextProviderProps) => JSX.Element;
interface I18nContextProviderProps {
    value: I18nProvider;
    children: ReactNode;
}

interface StringMap {
    [key: string]: StringMap | string | undefined;
}
interface TranslationMessages extends StringMap {
    ra: {
        action: {
            [key: string]: StringMap | string;
            add_filter: string;
            add: string;
            back: string;
            bulk_actions: string;
            cancel: string;
            clear_input_value: string;
            clone: string;
            confirm: string;
            create: string;
            create_item: string;
            delete: string;
            edit: string;
            export: string;
            list: string;
            refresh: string;
            remove_filter: string;
            remove: string;
            save: string;
            search: string;
            select_all: string;
            select_row: string;
            show: string;
            sort: string;
            undo: string;
            unselect: string;
            expand: string;
            close: string;
            open_menu: string;
            close_menu: string;
            update: string;
            move_up: string;
            move_down: string;
            open: string;
            toggle_theme: string;
        };
        boolean: {
            [key: string]: StringMap | string;
            true: string;
            false: string;
            null: string;
        };
        page: {
            [key: string]: StringMap | string;
            create: string;
            dashboard: string;
            edit: string;
            error: string;
            list: string;
            loading: string;
            not_found: string;
            show: string;
            empty: string;
            invite: string;
        };
        input: {
            [key: string]: StringMap | string;
            file: {
                [key: string]: StringMap | string;
                upload_several: string;
                upload_single: string;
            };
            image: {
                [key: string]: StringMap | string;
                upload_several: string;
                upload_single: string;
            };
            references: {
                [key: string]: StringMap | string;
                all_missing: string;
                many_missing: string;
                single_missing: string;
            };
            password: {
                [key: string]: StringMap | string;
                toggle_visible: string;
                toggle_hidden: string;
            };
        };
        message: {
            [key: string]: StringMap | string;
            about: string;
            are_you_sure: string;
            bulk_delete_content: string;
            bulk_delete_title: string;
            bulk_update_content: string;
            bulk_update_title: string;
            delete_content: string;
            delete_title: string;
            details: string;
            error: string;
            invalid_form: string;
            loading: string;
            no: string;
            not_found: string;
            yes: string;
            unsaved_changes: string;
        };
        navigation: {
            [key: string]: StringMap | string;
            no_results: string;
            no_more_results: string;
            page_out_of_boundaries: string;
            page_out_from_end: string;
            page_out_from_begin: string;
            page_range_info: string;
            partial_page_range_info: string;
            page_rows_per_page: string;
            current_page: string;
            page: string;
            first: string;
            last: string;
            next: string;
            previous: string;
            skip_nav: string;
        };
        sort: {
            sort_by: string;
            ASC: string;
            DESC: string;
        };
        auth: {
            [key: string]: StringMap | string;
            auth_check_error: string;
            user_menu: string;
            username: string;
            password: string;
            sign_in: string;
            sign_in_error: string;
            logout: string;
        };
        notification: {
            [key: string]: StringMap | string;
            updated: string;
            created: string;
            deleted: string;
            bad_item: string;
            item_doesnt_exist: string;
            http_error: string;
            data_provider_error: string;
            i18n_error: string;
            canceled: string;
            logged_out: string;
            not_authorized: string;
        };
        validation: {
            [key: string]: StringMap | string;
            required: string;
            minLength: string;
            maxLength: string;
            minValue: string;
            maxValue: string;
            number: string;
            email: string;
            oneOf: string;
            regex: string;
        };
        saved_queries: {
            label: string;
            query_name: string;
            new_label: string;
            new_dialog_title: string;
            remove_label: string;
            remove_label_with_name: string;
            remove_dialog_title: string;
            remove_message: string;
            help: string;
        };
    };
}

declare const TranslatableContext: react.Context<TranslatableContextValue>;
interface TranslatableContextValue {
    getLabel: GetTranslatableLabel;
    getSource: GetTranslatableSource;
    locales: string[];
    selectedLocale: string;
    selectLocale: SelectTranslatableLocale;
}
declare type GetTranslatableSource = (field: string, locale?: string) => string;
declare type GetTranslatableLabel = (field: string, label?: string) => string;
declare type SelectTranslatableLocale = (locale: string) => void;

declare const TranslatableContextProvider: ({ children, value, }: {
    children: ReactNode;
    value: TranslatableContextValue;
}) => ReactElement;

/**
 * Resolve the browser locale according to the value of the global window.navigator
 *
 * Use it to determine the <Admin> locale at runtime.
 *
 * @example
 *    import * as React from "react";
 *    import { Admin, Resource, resolveBrowserLocale } from 'react-admin';
 *    import polyglotI18nProvider from 'ra-i18n-polyglot';
 *    import englishMessages from 'ra-language-english';
 *    import frenchMessages from 'ra-language-french';
 *
 *    const messages = {
 *        fr: frenchMessages,
 *        en: englishMessages,
 *    };
 *    const i18nProvider = polyglotI18nProvider(
 *        locale => messages[locale] ? messages[locale] : messages.en,
 *        resolveBrowserLocale()
 *    );
 *
 *    const App = () => (
 *        <Admin i18nProvider={i18nProvider}>
 *            ...
 *        </Admin>
 *    );
 *
 * @param {string} defaultLocale Defaults to 'en'
 * @param options
 * @param {boolean} options.fullLocale Defaults to false
 */
declare const resolveBrowserLocale: (defaultLocale?: string, options?: {
    fullLocale?: boolean;
}) => string;
/**
 * Compose translations from multiple packages for a single language (eg: 'english').
 *
 * Use it to merge translations from addons with the main react-admin translations.
 *
 * @example
 *     import * as React from "react";
 *     import { Admin, Resource, mergeTranslations } from 'react-admin';
 *     import polyglotI18nProvider from 'ra-i18n-polyglot';
 *     import englishMessages from 'ra-language-english';
 *     import englishTreeMessages from 'ra-tree-language-english';
 *
 *     const messages = {
 *        en: mergeTranslations(englishMessages, englishTreeMessages),
 *     };
 *     const i18nProvider = polyglotI18nProvider(
 *        locale => messages[locale] ? messages[locale] : messages.en
 *    );
 *
 *    const App = () => (
 *        <Admin i18nProvider={i18nProvider}>
 *            ...
 *        </Admin>
 *    );
 */
declare const mergeTranslations: (...translationsModules: object[]) => any;

/**
 * Get the current locale and the ability to change it
 *
 * @example
 *
 * import { useLocaleState } from 'react-admin';
 *
 * const availableLanguages = {
 *     en: 'English',
 *     fr: 'Français',
 * }
 * const LocaleSwitcher = () => {
 *     const [locale, setLocale] = useLocaleState();
 *     return (
 *         <div>
 *             <div>Language</div>
 *             <Button disabled={locale === 'fr'} onClick={() => setLocale('fr')}>
 *                 English
 *             </Button>
 *             <Button disabled={locale === 'en'} onClick={() => setLocale('en')}>
 *                 French
 *             </Button>
 *         </div>
 *     );
 * };
 */
declare const useLocaleState: () => useStoreResult<string>;

/**
 * Get the current locale
 *
 * @example
 *
 * import { useLocale } from 'react-admin';
 *
 * const availableLanguages = {
 *     en: 'English',
 *     fr: 'Français',
 * }
 * const CurrentLanguage = () => {
 *     const locale = useLocale();
 *     return <span>{availableLanguages[locale]}</span>;
 * }
 *
 * @deprecated use useLocaleState instead
 */
declare const useLocale: () => string;

/**
 * Set the current locale in the I18nContext and re-render the app when the locale changes.
 *
 * @example
 *
 * import { useSetLocale } from 'react-admin';
 *
 * const availableLanguages = {
 *     en: 'English',
 *     fr: 'Français',
 * }
 * const LanguageSwitcher = () => {
 *     const setLocale = useSetLocale();
 *     return (
 *         <ul>{
 *             Object.keys(availableLanguages).map(locale => {
 *                  <li key={locale} onClick={() => setLocale(locale)}>
 *                      {availableLanguages[locale]}
 *                  </li>
 *              })
 *         }</ul>
 *     );
 * }
 *
 * @deprecated use useLocaleState instead
 */
declare const useSetLocale: () => (value: string | ((value: string) => void), defaultValue?: string) => void;

/**
 * Hook supplying the logic to translate a field value in multiple languages.
 *
 * @param options The hook options
 * @param {string} options.defaultLocale The locale of the default selected locale. Defaults to 'en'.
 * @param {string[]} options.locales An array of the supported locales. Each is an object with a locale and a name property. For example { locale: 'en', name: 'English' }.
 *
 * @returns
 * An object with following properties and methods:
 * - selectedLocale: The locale of the currently selected locale
 * - locales: An array of the supported locales
 * - getLabel: A function which returns the translated label for the given field
 * - getSource: A function which returns the source for the given field
 * - selectLocale: A function which set the selected locale
 */
declare const useTranslatable: (options: UseTranslatableOptions) => TranslatableContextValue;
declare type UseTranslatableOptions = {
    defaultLocale?: string;
    locales: string[];
};

/**
 * Gives access to the current TranslatableContext.
 *
 * @example
 * <TranslatableFields
 *     selector={<MyLanguageSelector />}
 *     locales={['en', 'fr']}
 * >
 *     <TextField source={getSource('title')} />
 * <TranslatableFields>
 *
 * const MyLanguageSelector = () => {
 *     const {
 *         locales,
 *         selectedLocale,
 *         selectLocale,
 *     } = useTranslatableContext();
 *
 *     return (
 *         <select onChange={selectLocale}>
 *             {locales.map((locale) => (
 *                 <option selected={locale.locale === selectedLocale}>
 *                     {locale.name}
 *                 </option>
 *             ))}
 *        </select>
 *     );
 * }
 */
declare const useTranslatableContext: () => TranslatableContextValue;

/**
 * Translate a string using the current locale and the translations from the i18nProvider
 *
 * @see Polyglot.t()
 * @link https://airbnb.io/polyglot.js/#polyglotprototypetkey-interpolationoptions
 *
 * @return {Function} A translation function, accepting two arguments
 *   - a string used as key in the translations
 *   - an interpolationOptions object
 *
 * @example
 *
 * import { useTranslate } from 'react-admin';
 *
 * const SettingsMenu = () => {
 *     const translate = useTranslate();
 *     return <MenuItem>{translate('settings')}</MenuItem>;
 * }
 */
declare const useTranslate: () => Translate;

/**
 * Get the i18nProvider instance declared in the <Admin> component
 *
 * @example
 *
 * const CurrentLanguage = () => {
 *    const i18nProvider = useI18nProvider();
 *    const locale = i18nProvider.getLocale();
 *    return <span>{locale}</span>;
 * };
 */
declare const useI18nProvider: () => I18nProvider;

declare const DEFAULT_LOCALE = "en";

interface InferredType {
    type?: ComponentType;
    component?: ComponentType;
    representation?: (props: any, children: any) => string;
}
interface InferredTypeMap {
    [key: string]: InferredType | undefined;
}

declare const _default$9: (records: any[], types: InferredTypeMap) => any[];

declare class InferredElement {
    private type?;
    private props?;
    private children?;
    constructor(type?: InferredType, props?: any, children?: any);
    getElement(props?: {}): react.ReactElement<{}, string | react.JSXElementConstructor<any>>;
    getProps(): any;
    isDefined(): boolean;
    getRepresentation(): string;
}

declare const _default$8: (records: any[]) => any;

declare const InferenceTypes: readonly ["array", "boolean", "date", "email", "id", "image", "number", "reference", "referenceChild", "referenceArray", "referenceArrayChild", "richText", "string", "url", "object"];
declare type PossibleInferredElementTypes = typeof InferenceTypes[number];
interface InferredElementDescription {
    type: PossibleInferredElementTypes;
    props?: any;
    children?: InferredElementDescription | InferredElementDescription[];
}
/**
 * Guesses an element type based on an array of values
 *
 * @example
 *     inferElementFromValues(
 *         'address',
 *         ['2 Baker Street', '1 Downing street'],
 *     );
 *     // { type: 'string', props: { source: 'address' } }
 *
 * @param {string} name Property name, e.g. 'date_of_birth'
 * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]
 */
declare const inferTypeFromValues: (name: any, values?: any[]) => InferredElementDescription;

declare const _default$7: (url: any) => any;

interface FieldTitleProps {
    isRequired?: boolean;
    resource?: string;
    source?: string;
    label?: string | ReactElement | false;
}
declare const _default$6: react.MemoExoticComponent<{
    (props: FieldTitleProps): JSX.Element;
    displayName: string;
}>;

interface Args {
    label?: string;
    parentSource?: string;
    resource?: string;
    source?: string;
}
declare type TranslationArguments = [string, any?];
declare const _default$5: (options?: Args) => TranslationArguments;

declare const _default$4: (props: any, propName: any, componentName: any) => Error;

declare const removeEmpty: (object: any) => {};

declare const deepRemoveKey: (target: any, path: any) => any;

declare const _default$3: () => JSX.Element;

declare const _default$2: (condition: any, message: string) => void;

/**
 * Debug hook showing which props updated between two renders
 * @example
 *
 * const MyComponent = React.memo(props => {
 *   useWhyDidYouUpdate('MyComponent', props);
 *   return <div...;
 * });
 *
 * @link https://usehooks.com/useWhyDidYouUpdate/
 */
declare function useWhyDidYouUpdate(name: any, props: any): void;

declare const getMutationMode: (mutationMode: any, undoable: any) => any;

declare function mergeRefs<T = any>(refs: Array<MutableRefObject<T> | LegacyRef<T>>): RefCallback<T>;

/**
 * Alternative to useCallback that doesn't update the callback when dependencies change
 *
 * @see https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback
 * @see https://github.com/facebook/react/issues/14099#issuecomment-440013892
 */
declare const useEventCallback: <Args extends unknown[], Return>(fn: (...args: Args) => Return, dependencies: any[]) => (...args: Args) => Return;

declare function useSafeSetState<T>(initialState?: T | (() => T)): [T, react.Dispatch<react.SetStateAction<T>>];
declare function usePrevious(value: any): undefined;
declare function useDeepCompareEffect(callback: any, inputs: any): void;
/**
 * A hook that returns true once a delay has expired.
 * @param ms The delay in milliseconds
 * @param key A key that can be used to reset the timer
 * @returns true if the delay has expired, false otherwise
 */
declare function useTimeout(ms?: number, key?: string): boolean;
declare function useIsMounted(): react.MutableRefObject<boolean>;

declare const shallowEqual: (objA: any, objB: any) => boolean;

interface UseFilterStateOptions {
    filterToQuery?: (v: string) => FilterPayload;
    permanentFilter?: FilterPayload;
    debounceTime?: number;
}
/**
 * @typedef UseFilterStateProps
 * @property {Object} filter: The filter object.
 * @property {setFilter} setFilter: Update the filter with the given string
 */
interface UseFilterStateProps {
    filter: FilterPayload;
    setFilter: (v: string) => void;
}
declare const _default$1: ({ filterToQuery, permanentFilter, debounceTime, }: UseFilterStateOptions) => UseFilterStateProps;

interface SortProps {
    setSortField: (field: SortPayload['field']) => void;
    setSortOrder: (order: SortPayload['order']) => void;
    setSort: (sort: SortPayload) => void;
    sort: SortPayload;
}
/**
 * Set the sort { field, order }
 * @name setSort
 * @function
 * @param {SortPayload} sort the sort object
 */
/**
 * Set the sort field, swap the order if the field is the same
 * @name setSortField
 * @function
 * @param {string} field the sort field
 */
/**
 * Set the sort order
 * @name setSortOrder
 * @function
 * @param {string} order The sort order, either ASC or DESC
 */
/**
 * @typedef SortProps
 * @type {Object}
 * @property {Object} sort: the sort object.
 * @property {string} sort.field: the sort object.
 * @property {'ASC' | 'DESC'} sort.order: the sort object.
 * @property {setSort} setSort
 * @property {setSortField} setSortField
 * @property {setSortOrder} setSortOrder
 */
/**
 * Hooks to provide sort state
 *
 * @example
 *
 * const { sort, setSort, setSortField, setSortOrder } = useSort({
 *      field: 'name',
 *      order: 'ASC',
 * });
 *
 * setSort({ field: 'name', order: 'ASC' });
 * // is the same as
 * setSortField('name');
 * setSortOrder('ASC');
 *
 * @param {Object} initialSort
 * @param {string} initialSort.field The initial sort field
 * @param {string} initialSort.order The initial sort order
 * @returns {SortProps} The sort props
 */
declare const useSortState: (initialSort?: SortPayload) => SortProps;

/**
 * @typedef PaginationProps
 * @type {Object}
 * @property {number} page: The page number.
 * @property {number} perPage: The number of item per page.
 * @property {Function} setPage: Set the page number
 * @property {Function} setPerPage: Set the per page number
 * @property {Function} setPagination: Set page and perPage pagination numbers
 */
interface PaginationHookResult {
    page: number;
    perPage: number;
    pagination: PaginationPayload;
    setPage: (page: number) => void;
    setPerPage: (perPage: number) => void;
    setPagination: (pagination: PaginationPayload) => void;
}
declare const _default: (initialPagination?: {
    perPage?: number;
    page?: number;
}) => PaginationHookResult;

declare const useCheckMinimumRequiredProps: (displayName: string, requiredProps: string[], props: any) => void;

/**
 * Creates a react-router Router unless the app is already inside existing router.
 * Also creates a BasenameContext with the basename prop
 */
declare const AdminRouter: ({ history, basename, children, }: AdminRouterProps) => JSX.Element;
interface AdminRouterProps {
    history?: History;
    basename?: string;
    children: react.ReactNode;
}

/**
 * Set the string to append to all links to the admin app.
 *
 * Useful when the app is mounted on a sub path, e.g. '/admin'.
 * Used internally by the `<Admin>` component.
 *
 * @see useBasename
 */
declare const BasenameContextProvider: ({ children, basename }: {
    children: any;
    basename: any;
}) => JSX.Element;

/**
 * @deprecated use useCreatePath instead
 */
declare const linkToRecord: (resource: any, id: any, linkType?: string) => string;

/**
 * @deprecated use useCreatePath instead
 */
declare const resolveRedirectTo: (redirectTo: any, resource: string, id?: any, data?: any, basename?: string) => To;

/**
 * Get the string to append to all links to the admin app.
 *
 * Useful when the app is mounted on a sub path, e.g. '/admin'.
 *
 * This hook is used internally by all react-admin components that
 * contain a link, and requires that the basename is set via the
 * `<BasenameContextProvider>` component (or via the `<Admin>` component,
 * which calls BasenameContextProvider internally).
 *
 * @see BasenameContextProvider
 *
 * @example
 * import { useBasename } from 'react-admin';
 *
 * const ArticleLink = ({ title, id }) => {
 *    const basename = useBasename();
 *    return <a href={`${basename}/articles/${id}`}>{title}</a>;
 * };
 */
declare const useBasename: () => string;

/**
 * Get a callback to create a link to a given page in the admin app.
 *
 * The callback expects an object as parameter, containing the following properties:
 *   - type: 'list', 'edit', 'show' or 'create'
 *   - resource
 *   - id (optional), for 'edit' or 'show' pages
 *
 * This is used internally by react-admin to allow default components to work
 * in applications that are mounted on a sub path, e.g. '/admin'. If your app
 * is mounted in the root path, you don't need it, and you can create links by
 * hand, e.g. '/articles/1/show'.
 *
 * @example
 * import { useCreatePath, useRecordContext } from 'react-admin';
 * import { useNavigate } from 'react-router-dom';
 *
 * const PostEditButton = () => {
 *     const createPath = useCreatePath();
 *     const record = useRecordContext();
 *     const navigate = useNavigate();
 *
 *     const handleClick = () => {
 *         const link = createPath({
 *            type: 'edit',
 *            resource: 'posts',
 *            id: record.id
 *         });
 *         navigate(link);
 *     };
 *
 *    return <button onClick={handleClick}>Edit Post</button>;
 * };
 */
declare const useCreatePath: () => ({ resource, id, type }: CreatePathParams) => string;
interface CreatePathParams {
    type: string;
    resource: string;
    id?: Identifier;
}
declare const removeDoubleSlashes: (path: string) => string;

declare type RedirectToFunction = (resource?: string, id?: Identifier, data?: Partial<RaRecord>, state?: object) => To;
declare type RedirectionSideEffect = string | false | RedirectToFunction;
/**
 * Hook for Redirection Side Effect
 *
 * @example
 *
 * const redirect = useRedirect();
 * // redirect to list view
 * redirect('list', 'posts');
 * // redirect to edit view
 * redirect('edit', 'posts', 123);
 * // redirect to edit view with state data
 * redirect('edit', 'comments', 123, {}, { record: { post_id: record.id } });
 * // do not redirect
 * redirect(false);
 * // redirect to the result of a function
 * redirect((resource, id, data) => ...)
 */
declare const useRedirect: () => (redirectTo: RedirectionSideEffect, resource?: string, id?: Identifier, data?: Partial<RaRecord>, state?: object) => void;

/**
 * Scroll the window to top when the target location contains the _scrollToTop state
 *
 * @see CoreAdminRouter where it's enabled by default
 *
 * @example // usage in buttons
 * import { Link } from 'react-router-dom';
 * import { Button } from '@mui/material';
 *
 * const FooButton = () => (
 *     <Button
 *         component={Link}
 *         to={{
 *             pathname: '/foo',
 *             state: { _scrollToTop: true },
 *         }}
 *     >
 *         Go to foo
 *     </Button>
 * );
 */
declare const useScrollToTop: () => void;

declare type LinkToFunctionType = (record: RaRecord, reference: string) => string;
declare type LinkToType = string | false | LinkToFunctionType;

/**
 * Prepare callback for a Delete button with undo support
 *
 * @example
 *
 * import React from 'react';
 * import ActionDelete from '@mui/icons-material/Delete';
 * import { Button, useDeleteWithUndoController } from 'react-admin';
 *
 * const DeleteButton = ({
 *     resource,
 *     record,
 *     redirect,
 *     onClick,
 *     ...rest
 * }) => {
 *     const { isLoading, handleDelete } = useDeleteWithUndoController({
 *         resource,
 *         record,
 *         redirect,
 *         onClick,
 *     });
 *
 *     return (
 *         <Button
 *             onClick={handleDelete}
 *             disabled={isLoading}
 *             label="ra.action.delete"
 *             {...rest}
 *         >
 *             <ActionDelete />
 *         </Button>
 *     );
 * };
 */
declare const useDeleteWithUndoController: <RecordType extends RaRecord = any>(props: UseDeleteWithUndoControllerParams<RecordType>) => UseDeleteWithUndoControllerReturn;
interface UseDeleteWithUndoControllerParams<RecordType extends RaRecord = any> {
    record?: RecordType;
    redirect?: RedirectionSideEffect;
    resource?: string;
    onClick?: ReactEventHandler<any>;
    mutationOptions?: UseMutationOptions<RecordType, unknown, DeleteParams<RecordType>>;
}
interface UseDeleteWithUndoControllerReturn {
    isLoading: boolean;
    handleDelete: ReactEventHandler<any>;
}

/**
 * Prepare a set of callbacks for a delete button guarded by confirmation dialog
 *
 * @example
 *
 * const DeleteButton = ({
 *     resource,
 *     record,
 *     redirect,
 *     onClick,
 *     ...rest
 * }) => {
 *     const {
 *         open,
 *         isLoading,
 *         handleDialogOpen,
 *         handleDialogClose,
 *         handleDelete,
 *     } = useDeleteWithConfirmController({
 *         resource,
 *         record,
 *         redirect,
 *         onClick,
 *     });
 *
 *     return (
 *         <Fragment>
 *             <Button
 *                 onClick={handleDialogOpen}
 *                 label="ra.action.delete"
 *                 {...rest}
 *             >
 *                 {icon}
 *             </Button>
 *             <Confirm
 *                 isOpen={open}
 *                 loading={isLoading}
 *                 title="ra.message.delete_title"
 *                 content="ra.message.delete_content"
 *                 translateOptions={{
 *                     name: resource,
 *                     id: record.id,
 *                 }}
 *                 onConfirm={handleDelete}
 *                 onClose={handleDialogClose}
 *             />
 *         </Fragment>
 *     );
 * };
 */
declare const useDeleteWithConfirmController: <RecordType extends RaRecord = any>(props: UseDeleteWithConfirmControllerParams<RecordType>) => UseDeleteWithConfirmControllerReturn;
interface UseDeleteWithConfirmControllerParams<RecordType extends RaRecord = any> {
    mutationMode?: MutationMode;
    record?: RecordType;
    redirect?: RedirectionSideEffect;
    resource?: string;
    onClick?: ReactEventHandler<any>;
    mutationOptions?: UseMutationOptions<RecordType, unknown, DeleteParams<RecordType>>;
}
interface UseDeleteWithConfirmControllerReturn {
    open: boolean;
    isLoading: boolean;
    handleDialogOpen: (e: SyntheticEvent) => void;
    handleDialogClose: (e: SyntheticEvent) => void;
    handleDelete: ReactEventHandler<any>;
}

interface SaveContextValue<RecordType extends RaRecord = any> {
    save?: SaveHandler<RecordType>;
    saving?: boolean;
    mutationMode?: MutationMode;
}
declare type SaveHandler<RecordType> = (record: Partial<RecordType>, callbacks?: {
    onSuccess?: OnSuccess;
    onError?: onError;
    transform?: TransformData;
}) => Promise<void | RecordType> | Record<string, string>;
declare const SaveContext: react.Context<SaveContextValue<any>>;

declare const SaveContextProvider: ({ children, value }: {
    children: any;
    value: any;
}) => JSX.Element;

/**
 * This hook extracts the `save`, `saving` and mutationMode properties from either the `CreateContext` or `EditContext`. This ensures the `SaveContext` doesn't rerender when those two contexts have other properties changes.
 */
declare const usePickSaveContext: <ContextType extends SaveContextValue<any> = SaveContextValue<any>>(context: ContextType) => SaveContextValue;

/**
 * Get the save() function and its status
 *
 * Used in forms.
 *
 * @example
 *
 * const {
 *     save,
 *     saving
 * } = useSaveContext();
 */
declare const useSaveContext: <PropsType extends SaveContextValue<any> = SaveContextValue<any>>(props?: PropsType) => SaveContextValue;

/**
 * Prepare data for the Create view
 *
 * @param {Object} props The props passed to the Create component.
 *
 * @return {Object} controllerProps Fetched data and callbacks for the Create view
 *
 * @example
 *
 * import { useCreateController } from 'react-admin';
 * import CreateView from './CreateView';
 *
 * const MyCreate = props => {
 *     const controllerProps = useCreateController(props);
 *     return <CreateView {...controllerProps} {...props} />;
 * }
 */
declare const useCreateController: <RecordType extends RaRecord = RaRecord>(props?: CreateControllerProps<RecordType>) => CreateControllerResult<RecordType>;
interface CreateControllerProps<RecordType extends RaRecord = RaRecord> {
    disableAuthentication?: boolean;
    record?: Partial<RecordType>;
    redirect?: RedirectionSideEffect;
    resource?: string;
    mutationOptions?: UseMutationOptions<RecordType, unknown, CreateParams<RecordType>>;
    transform?: TransformData;
}
interface CreateControllerResult<RecordType extends RaRecord = RaRecord> {
    data?: RecordType;
    defaultTitle: string;
    isFetching: boolean;
    isLoading: boolean;
    save: SaveHandler<RecordType>;
    saving: boolean;
    record?: Partial<RecordType>;
    redirect: RedirectionSideEffect;
    resource: string;
}
/**
 * Get the initial record from the location, whether it comes from the location
 * state or is serialized in the url search part.
 */
declare const getRecordFromLocation: ({ state, search }: Location$1) => any;

/**
 * Call useCreateController and put the value in a CreateContext
 *
 * Base class for <Create> components, without UI.
 *
 * Accepts any props accepted by useCreateController:
 * - id: The record identifier
 * - resource: The resource
 *
 * @example // Custom edit layout
 *
 * const PostCreate = props => (
 *     <CreateBase {...props}>
 *         <Grid container>
 *             <Grid item xs={8}>
 *                 <SimpleForm>
 *                     ...
 *                 </SimpleForm>
 *             </Grid>
 *             <Grid item xs={4}>
 *                 Create instructions...
 *             </Grid>
 *         </Grid>
 *         <div>
 *             Post related links...
 *         </div>
 *     </CreateBase>
 * );
 */
declare const CreateBase: <RecordType extends RaRecord = any>({ children, ...props }: CreateControllerProps<RecordType> & {
    children: ReactNode;
}) => JSX.Element;

/**
 * Context to store the result of the useCreateController() hook.
 *
 * Use the useCreateContext() hook to read the context. That's what the Create components do in react-admin.
 *
 * @example
 *
 * import { useCreateController, CreateContextProvider } from 'ra-core';
 *
 * const Create = props => {
 *     const controllerProps = useCreateController(props);
 *     return (
 *         <CreateContextProvider value={controllerProps}>
 *             ...
 *         </CreateContextProvider>
 *     );
 * };
 */
declare const CreateContext: react.Context<CreateControllerResult<RaRecord>>;

/**
 * Create a Create Context.
 *
 * @example
 *
 * const MyCreate = (props) => {
 *     const controllerProps = useCreateController(props);
 *     return (
 *         <CreateContextProvider value={controllerProps}>
 *             <MyCreateView>
 *         </CreateContextProvider>
 *     );
 * };
 *
 * const MyCreateView = () => {
 *     const record = useRecordContext();
 *     // or, to rerender only when the save operation change but not data
 *     const { saving } = useCreateContext();
 * }
 *
 * @see CreateContext
 * @see RecordContext
 */
declare const CreateContextProvider: ({ children, value, }: {
    children: ReactNode;
    value: CreateControllerResult;
}) => JSX.Element;

/**
 * Render prop version of the useCreateController hook
 *
 * @see useCreateController
 * @example
 *
 * const CreateView = () => <div>...</div>
 * const MyCreate = props => (
 *     <CreateController {...props}>
 *         {controllerProps => <CreateView {...controllerProps} {...props} />}
 *     </CreateController>
 * );
 */
declare const CreateController: ({ children, ...props }: {
    children: (params: CreateControllerResult) => JSX.Element;
} & CreateControllerProps<RaRecord>) => JSX.Element;

/**
 * Hook to read the create controller props from the CreateContext.
 *
 * Mostly used within a <CreateContext.Provider> (e.g. as a descendent of <Create>).
 *
 * But you can also use it without a <CreateContext.Provider>. In this case, it is up to you
 * to pass all the necessary props.
 *
 * The given props will take precedence over context values.
 *
 * @typedef {Object} CreateControllerProps
 *
 * @returns {CreateControllerResult} create controller props
 *
 * @see useCreateController for how it is filled
 *
 */
declare const useCreateContext: <RecordType extends RaRecord = RaRecord>(props?: Partial<CreateControllerResult<RecordType>>) => Partial<CreateControllerResult<RecordType>>;

/**
 * Prepare data for the Edit view.
 *
 * useEditController does a few things:
 * - it grabs the id from the URL and the resource name from the ResourceContext,
 * - it fetches the record via useGetOne,
 * - it prepares the page title.
 *
 * @param {Object} props The props passed to the Edit component.
 *
 * @return {Object} controllerProps Fetched data and callbacks for the Edit view
 *
 * @example
 *
 * import { useEditController } from 'react-admin';
 * import EditView from './EditView';
 *
 * const MyEdit = () => {
 *     const controllerProps = useEditController({ resource: 'posts', id: 123 });
 *     return <EditView {...controllerProps} {...props} />;
 * }
 */
declare const useEditController: <RecordType extends RaRecord = any>(props?: EditControllerProps<RecordType>) => EditControllerResult<RecordType>;
interface EditControllerProps<RecordType extends RaRecord = any> {
    disableAuthentication?: boolean;
    id?: RecordType['id'];
    mutationMode?: MutationMode;
    mutationOptions?: UseMutationOptions<RecordType, unknown, UpdateParams<RecordType>>;
    queryOptions?: UseQueryOptions<RecordType>;
    redirect?: RedirectionSideEffect;
    resource?: string;
    transform?: TransformData;
    [key: string]: any;
}
interface EditControllerResult<RecordType extends RaRecord = any> {
    data?: RecordType;
    error?: any;
    defaultTitle: string;
    isFetching: boolean;
    isLoading: boolean;
    mutationMode?: MutationMode;
    save: SaveHandler<RecordType>;
    saving: boolean;
    record?: RecordType;
    refetch: UseGetOneHookValue<RecordType>['refetch'];
    redirect: RedirectionSideEffect;
    resource: string;
}

/**
 * Call useEditController and put the value in a EditContext
 *
 * Base class for <Edit> components, without UI.
 *
 * Accepts any props accepted by useEditController:
 * - id: The record identifier
 * - resource: The resource
 *
 * @example // Custom edit layout
 *
 * const PostEdit = () => (
 *     <EditBase resource="posts">
 *         <Grid container>
 *             <Grid item xs={8}>
 *                 <SimpleForm>
 *                     ...
 *                 </SimpleForm>
 *             </Grid>
 *             <Grid item xs={4}>
 *                 Edit instructions...
 *             </Grid>
 *         </Grid>
 *         <div>
 *             Post related links...
 *         </div>
 *     </EditBase>
 * );
 */
declare const EditBase: <RecordType extends RaRecord = any>({ children, ...props }: {
    children: ReactNode;
} & EditControllerProps<RecordType>) => JSX.Element;

/**
 * Context to store the result of the useEditController() hook.
 *
 * Use the useEditContext() hook to read the context. That's what the Edit components do in react-admin.
 *
 * @example
 *
 * import { useEditController, EditContextProvider } from 'ra-core';
 *
 * const Edit = props => {
 *     const controllerProps = useEditController(props);
 *     return (
 *         <EditContextProvider value={controllerProps}>
 *             ...
 *         </EditContextProvider>
 *     );
 * };
 */
declare const EditContext: react.Context<EditControllerResult<any>>;

/**
 * Create an Edit Context.
 *
 * @example
 *
 * const MyEdit = (props) => {
 *     const controllerProps = useEditController(props);
 *     return (
 *         <EditContextProvider value={controllerProps}>
 *             <MyEditView>
 *         </EditContextProvider>
 *     );
 * };
 *
 * const MyEditView = () => {
 *     const record = useRecordContext();
 *     // or, to rerender only when the save operation change but not data
 *     const { saving } = useEditContext();
 * }
 *
 * @see EditContext
 * @see RecordContext
 */
declare const EditContextProvider: ({ children, value, }: {
    children: ReactNode;
    value: EditControllerResult;
}) => JSX.Element;

/**
 * Render prop version of the useEditController hook
 *
 * @see useEditController
 * @example
 *
 * const EditView = () => <div>...</div>
 * const MyEdit = props => (
 *     <EditController {...props}>
 *         {controllerProps => <EditView {...controllerProps} {...props} />}
 *     </EditController>
 * );
 */
declare const EditController: ({ children, ...props }: {
    children: (params: EditControllerResult) => JSX.Element;
} & EditControllerProps<any>) => JSX.Element;

/**
 * Hook to read the edit controller props from the CreateContext.
 *
 * Mostly used within a <EditContext.Provider> (e.g. as a descendent of <Edit>).
 *
 * But you can also use it without a <EditContext.Provider>. In this case, it is up to you
 * to pass all the necessary props.
 *
 * The given props will take precedence over context values.
 *
 * @typedef {Object} EditControllerProps
 *
 * @returns {EditControllerResult} edit controller props
 *
 * @see useEditController for how it is filled
 *
 */
declare const useEditContext: <RecordType extends RaRecord = any>(props?: Partial<EditControllerResult<RecordType>>) => Partial<EditControllerResult<RecordType>>;

/**
 * Prepare data for the List view
 *
 * @param {Object} props The props passed to the List component.
 *
 * @return {Object} controllerProps Fetched and computed data for the List view
 *
 * @example
 *
 * import { useListController } from 'react-admin';
 * import ListView from './ListView';
 *
 * const MyList = props => {
 *     const controllerProps = useListController(props);
 *     return <ListView {...controllerProps} {...props} />;
 * }
 */
declare const useListController: <RecordType extends RaRecord = any>(props?: ListControllerProps<RecordType>) => ListControllerResult<RecordType>;
interface ListControllerProps<RecordType extends RaRecord = any> {
    debounce?: number;
    disableAuthentication?: boolean;
    /**
     * Whether to disable the synchronization of the list parameters with the current location (URL search parameters)
     */
    disableSyncWithLocation?: boolean;
    exporter?: Exporter | false;
    filter?: FilterPayload;
    filterDefaultValues?: object;
    perPage?: number;
    queryOptions?: UseQueryOptions<{
        data: RecordType[];
        total?: number;
        pageInfo?: {
            hasNextPage?: boolean;
            hasPreviousPage?: boolean;
        };
    }>;
    resource?: string;
    sort?: SortPayload;
}
interface ListControllerResult<RecordType extends RaRecord = any> {
    sort: SortPayload;
    data: RecordType[];
    defaultTitle?: string;
    displayedFilters: any;
    error?: any;
    exporter?: Exporter | false;
    filter?: FilterPayload;
    filterValues: any;
    hideFilter: (filterName: string) => void;
    isFetching: boolean;
    isLoading: boolean;
    onSelect: (ids: RecordType['id'][]) => void;
    onToggleItem: (id: RecordType['id']) => void;
    onUnselectItems: () => void;
    page: number;
    perPage: number;
    refetch: UseGetListHookValue<RecordType>['refetch'];
    resource: string;
    selectedIds: RecordType['id'][];
    setFilters: (filters: any, displayedFilters: any, debounce?: boolean) => void;
    setPage: (page: number) => void;
    setPerPage: (page: number) => void;
    setSort: (sort: SortPayload) => void;
    showFilter: (filterName: string, defaultValue: any) => void;
    total: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
}
declare const injectedProps: string[];
/**
 * Select the props injected by the useListController hook
 * to be passed to the List children need
 * This is an implementation of pick()
 */
declare const getListControllerProps: (props: any) => {};
/**
 * Select the props not injected by the useListController hook
 * to be used inside the List children to sanitize props injected by List
 * This is an implementation of omit()
 */
declare const sanitizeListRestProps: (props: any) => {};

/**
 * Call useListController and put the value in a ListContext
 *
 * Base class for <List> components, without UI.
 *
 * Accepts any props accepted by useListController:
 * - filter: permanent filter applied to the list
 * - filters: Filter element, to display the filters
 * - filterDefaultValues: object;
 * - perPage: Number of results per page
 * - sort: Default sort
 * - exporter: exported function
 *
 * @example // Custom list layout
 *
 * const PostList = props => (
 *     <ListBase {...props} perPage={10}>
 *         <div>
 *              List metrics...
 *         </div>
 *         <Grid container>
 *             <Grid item xs={8}>
 *                 <SimpleList primaryText={record => record.title} />
 *             </Grid>
 *             <Grid item xs={4}>
 *                 List instructions...
 *             </Grid>
 *         </Grid>
 *         <div>
 *             Post related links...
 *         </div>
 *     </ListBase>
 * );
 */
declare const ListBase: <RecordType extends RaRecord = any>({ children, ...props }: ListControllerProps<RecordType> & {
    children: ReactNode;
}) => JSX.Element;

/**
 * Context to store the result of the useListController() hook.
 *
 * Use the useListContext() hook to read the context. That's what many
 * List components do in react-admin (e.g. <Datagrid>, <FilterForm>, <Pagination>).
 *
 * @typedef {Object} ListControllerProps
 * @prop {Array}    data an array of the list records, e.g. [{ id: 123, title: 'hello world' }, { ... }]
 * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23
 * @prop {boolean}  isFetching boolean that is true on mount, and false once the data was fetched
 * @prop {boolean}  isLoading boolean that is false until the data is available
 * @prop {integer}  page the current page. Starts at 1
 * @prop {Function} setPage a callback to change the page, e.g. setPage(3)
 * @prop {integer}  perPage the number of results per page. Defaults to 25
 * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)
 * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }
 * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field: 'name', order: 'ASC' })
 * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }
 * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)
 * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }
 * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)
 * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')
 * @prop {Array}    selectedIds an array listing the ids of the selected rows, e.g. [123, 456]
 * @prop {Function} onSelect callback to change the list of selected rows, e.g. onSelect([456, 789])
 * @prop {Function} onToggleItem callback to toggle the selection of a given record based on its id, e.g. onToggleItem(456)
 * @prop {Function} onUnselectItems callback to clear the selection, e.g. onUnselectItems();
 * @prop {string}   defaultTitle the translated title based on the resource, e.g. 'Posts'
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 * @prop {Function} refetch a function for triggering a refetch of the list data
 *
 * @typedef Props
 * @prop {ListControllerResult} value
 *
 * @param {Props}
 *
 * @see useListController
 * @see useListContext
 *
 * @example
 *
 * import { useListController, ListContext } from 'ra-core';
 *
 * const List = props => {
 *     const controllerProps = useListController(props);
 *     return (
 *         <ListContext.Provider value={controllerProps}>
 *             ...
 *         </ListContext.Provider>
 *     );
 * };
 */
declare const ListContext: react.Context<ListControllerResult<any>>;

/**
 * Create a List Context and several thematic List subcontext.
 *
 * Allows children to subscribe to part of the ListContext, and bail out of
 * rendering when some parts of the context that they don't depend on change
 * (because unfortunately React doesn't allow to use context selectors yet).
 *
 * @example
 *
 * const MyList = (props) => {
 *     const controllerProps = useListController(props);
 *     return (
 *         <ListContextProvider value={controllerProps}>
 *             <MyListView>
 *         </ListContextProvider>
 *     );
 * };
 *
 * const MyListView = () => {
 *     const { data, filterValues, setFilters } = useListContext();
 *     // or, to rerender only when filters change but not data
 *     const { filterValues, setFilters } = useListFilterContext();
 * }
 *
 * @see ListContext
 * @see ListFilterContext
 */
declare const ListContextProvider: ({ value, children }: {
    value: any;
    children: any;
}) => JSX.Element;

/**
 * Render prop version of the useListController hook.
 *
 * @see useListController
 * @example
 *
 * const ListView = () => <div>...</div>;
 * const List = props => (
 *     <ListController {...props}>
 *        {controllerProps => <ListView {...controllerProps} {...props} />}
 *     </ListController>
 * )
 */
declare const ListController: ({ children, ...props }: {
    children: (params: ListControllerResult) => JSX.Element;
} & ListControllerProps<any>) => JSX.Element;

/**
 * Context to store the filter part of the useListController() result.
 *
 * Use the useListFilterContext() hook to read the context. That's what many
 * List components do in react-admin (e.g. <FilterForm>, <FilterListItem>).
 *
 * @typedef {Object} ListFilterContextValue
 * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }
 * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)
 * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }
 * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)
 * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @typedef Props
 * @prop {ListFilterContextValue} value
 *
 * @param {Props}
 *
 * @see useListController
 * @see useListFilterContext
 *
 * @example
 *
 * import { useListController, usePickFilterContext, ListFilterContext } from 'ra-core';
 *
 * const List = props => {
 *     const controllerProps = useListController(props);
 *     return (
 *         <ListFilterContext.Provider value={usePickFilterContext(controllerProps)}>
 *             ...
 *         </ListFilterContext.Provider>
 *     );
 * };
 */
declare const ListFilterContext: react.Context<ListFilterContextValue>;
declare type ListFilterContextValue = Pick<ListControllerResult, 'displayedFilters' | 'filterValues' | 'hideFilter' | 'setFilters' | 'showFilter' | 'resource'>;
declare const usePickFilterContext: (context: ListControllerResult) => ListFilterContextValue;

/**
 * Context to store the pagination part of the useListController() result.
 *
 * Use the useListPaginationContext() hook to read the pagination information.
 * That's what List components do in react-admin (e.g. <Pagination>).
 *
 * @typedef {Object} ListPaginationContextValue
 * @prop {boolean}  isLoading boolean that is false until the data is available
 * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23
 * @prop {integer}  page the current page. Starts at 1
 * @prop {Function} setPage a callback to change the page, e.g. setPage(3)
 * @prop {integer}  perPage the number of results per page. Defaults to 25
 * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)
 * @prop {Boolean}  hasPreviousPage true if the current page is not the first one
 * @prop {Boolean}  hasNextPage true if the current page is not the last one

 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @typedef Props
 * @prop {ListPaginationContextValue} value
 *
 * @param {Props}
 *
 * @see useListController
 * @see useListContext
 *
 * @example
 *
 * import { useListController, ListPaginationContext } from 'ra-core';
 *
 * const List = props => {
 *     const controllerProps = useListController(props);
 *     return (
 *         <ListPaginationContext.Provider value={controllerProps}>
 *             ...
 *         </ListPaginationContext.Provider>
 *     );
 * };
 */
declare const ListPaginationContext: react.Context<ListPaginationContextValue>;
declare type ListPaginationContextValue = Pick<ListControllerResult, 'isLoading' | 'hasPreviousPage' | 'hasNextPage' | 'page' | 'perPage' | 'setPage' | 'setPerPage' | 'total' | 'resource'>;
declare const usePickPaginationContext: (context: ListControllerResult) => ListPaginationContextValue;

/**
 * Context to store the sort part of the useListController() result.
 *
 * Use the useListSortContext() hook to read the context. That's what many
 * List components do in react-admin (e.g. <SortButton>).
 *
 * @typedef {Object} ListSortContextValue
 * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }
 * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field: 'name', order: 'ASC' })
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @typedef Props
 * @prop {ListSortContextValue} value
 *
 * @param {Props}
 *
 * @see useListController
 * @see useListSortContext
 *
 * @example
 *
 * import { useListController, usePickSortContext, ListSortContext } from 'ra-core';
 *
 * const List = props => {
 *     const controllerProps = useListController(props);
 *     return (
 *         <ListSortContext.Provider value={usePickSortContext(controllerProps)}>
 *             ...
 *         </ListSortContext.Provider>
 *     );
 * };
 */
declare const ListSortContext: react.Context<ListSortContextValue>;
declare type ListSortContextValue = Pick<ListControllerResult, 'sort' | 'setSort' | 'resource'>;
declare const usePickSortContext: (context: ListControllerResult) => ListSortContextValue;

/**
 * Handle filtering, sorting and pagination on local data.
 *
 * Returns the data and callbacks expected by <ListContext>.
 *
 * @example
 * const data = [
 *     { id: 1, name: 'Arnold' },
 *     { id: 2, name: 'Sylvester' },
 *     { id: 3, name: 'Jean-Claude' },
 * ]
 *
 * const MyComponent = () => {
 *     const listContext = useList({ data });
 *     return (
 *         <ListContextProvider value={listContext}>
 *             <Datagrid>
 *                 <TextField source="id" />
 *                 <TextField source="name" />
 *             </Datagrid>
 *         </ListContextProvider>
 *     );
 * };
 *
 * @param {UseListOptions} props
 * @param {RaRecord[]} props.data An array of records
 * @param {Boolean} props.isFetching: Optional. A boolean indicating whether the data is being loaded
 * @param {Boolean} props.isLoading: Optional. A boolean indicating whether the data has been loaded at least once
 * @param {Error | String} props.error: Optional. The error if any occurred while loading the data
 * @param {Object} props.filter: Optional. An object containing the filters applied on the data
 * @param {Number} props.page: Optional. The initial page index
 * @param {Number} props.perPage: Optional. The initial page size
 * @param {SortPayload} props.sort: Optional. The initial sort (field and order)
 */
declare const useList: <RecordType extends RaRecord = any>(props: UseListOptions<RecordType>) => UseListValue<RecordType>;
interface UseListOptions<RecordType extends RaRecord = any> {
    data?: RecordType[];
    error?: any;
    filter?: FilterPayload;
    isFetching?: boolean;
    isLoading?: boolean;
    page?: number;
    perPage?: number;
    sort?: SortPayload;
    resource?: string;
}
declare type UseListValue<RecordType extends RaRecord = any> = ListControllerResult<RecordType>;

/**
 * Hook to read the list controller props from the ListContext.
 *
 * Mostly used within a <ListContext.Provider> (e.g. as a descendent of <List>
 * or <ListBase>).
 *
 * But you can also use it without a <ListContext.Provider>. In this case, it is up to you
 * to pass all the necessary props (see the list below).
 *
 * The given props will take precedence over context values.
 *
 * @typedef {Object} ListControllerProps
 * @prop {Object}   data an array of the list records, e.g. [{ id: 123, title: 'hello world' }, { ... }]
 * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23
 * @prop {boolean}  isFetching boolean that is true on mount, and false once the data was fetched
 * @prop {boolean}  isLoading boolean that is false until the data is available
 * @prop {integer}  page the current page. Starts at 1
 * @prop {Function} setPage a callback to change the page, e.g. setPage(3)
 * @prop {integer}  perPage the number of results per page. Defaults to 25
 * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)
 * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }
 * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field : 'name', order: 'ASC' })
 * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }
 * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)
 * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }
 * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)
 * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')
 * @prop {Array}    selectedIds an array listing the ids of the selected rows, e.g. [123, 456]
 * @prop {Function} onSelect callback to change the list of selected rows, e.g. onSelect([456, 789])
 * @prop {Function} onToggleItem callback to toggle the selection of a given record based on its id, e.g. onToggleItem(456)
 * @prop {Function} onUnselectItems callback to clear the selection, e.g. onUnselectItems();
 * @prop {string}   defaultTitle the translated title based on the resource, e.g. 'Posts'
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @returns {ListControllerResult} list controller props
 *
 * @see useListController for how it is filled
 *
 * @example // custom list view
 *
 * import { useListContext } from 'react-admin';
 *
 * const MyList = () => {
 *     const { data, isLoading } = useListContext();
 *     if (isLoading) {
 *         return <>Loading...</>;
 *     }
 *     return (
 *         <ul>
 *             {data.map(record => (
 *                 <li key={record.id}>{record.name}</li>
 *             ))}
 *         </ul>
 *     );
 * }
 *
 * @example // custom pagination
 *
 * import { useListContext } from 'react-admin';
 * import { Button, Toolbar } from '@mui/material';
 * import ChevronLeft from '@mui/icons-material/ChevronLeft';
 * import ChevronRight from '@mui/icons-material/ChevronRight';
 *
 * const PrevNextPagination = () => {
 *     const { page, perPage, total, setPage } = useListContext();
 *     const nbPages = Math.ceil(total / perPage) || 1;
 *     return (
 *         nbPages > 1 &&
 *             <Toolbar>
 *                 {page > 1 &&
 *                     <Button color="primary" key="prev" onClick={() => setPage(page - 1)}>
 *                         <ChevronLeft />
 *                         Prev
 *                     </Button>
 *                 }
 *                 {page !== nbPages &&
 *                     <Button color="primary" key="next" onClick={() => setPage(page + 1)}>
 *                         Next
 *                         <ChevronRight />
 *                     </Button>
 *                 }
 *             </Toolbar>
 *     );
 * }
 */
declare const useListContext: <RecordType extends RaRecord = any>(props?: any) => ListControllerResult<RecordType>;

/**
 * Hook to read the list controller props from the ListContext.
 *
 * Must be used within a <ListContextProvider> (e.g. as a descendent of <List>
 * or <ListBase>).
 *
 * @typedef {Object} ListFilterContextValue
 * @prop {Object}   filterValues a dictionary of filter values, e.g. { title: 'lorem', nationality: 'fr' }
 * @prop {Function} setFilters a callback to update the filters, e.g. setFilters(filters, displayedFilters)
 * @prop {Object}   displayedFilters a dictionary of the displayed filters, e.g. { title: true, nationality: true }
 * @prop {Function} showFilter a callback to show one of the filters, e.g. showFilter('title', defaultValue)
 * @prop {Function} hideFilter a callback to hide one of the filters, e.g. hideFilter('title')
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @returns {ListFilterContextValue} list controller props
 *
 * @see useListController for how it is filled
 */
declare const useListFilterContext: (props?: any) => ListFilterContextValue;

/**
 * Hook to read the list controller props from the ListContext.
 *
 * Must be used within a <ListContextProvider> (e.g. as a descendent of <List>
 * or <ListBase>).
 *
 * @typedef {Object} ListPaginationContextValue
 * @prop {integer}  total the total number of results for the current filters, excluding pagination. Useful to build the pagination controls. e.g. 23
 * @prop {integer}  page the current page. Starts at 1
 * @prop {Function} setPage a callback to change the page, e.g. setPage(3)
 * @prop {integer}  perPage the number of results per page. Defaults to 25
 * @prop {Function} setPerPage a callback to change the number of results per page, e.g. setPerPage(25)
 * @prop {Boolean}  hasPreviousPage true if the current page is not the first one
 * @prop {Boolean}  hasNextPage true if the current page is not the last one
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @returns {ListPaginationContextValue} list controller props
 *
 * @see useListController for how it is filled
 */
declare const useListPaginationContext: (props?: any) => ListPaginationContextValue;

interface ListParams {
    sort: string;
    order: string;
    page: number;
    perPage: number;
    filter: any;
    displayedFilters: any;
}
/**
 * Get the list parameters (page, sort, filters) and modifiers.
 *
 * These parameters are merged from 3 sources:
 *   - the query string from the URL
 *   - the params stored in the state (from previous navigation)
 *   - the options passed to the hook (including the filter defaultValues)
 *
 * @returns {Array} A tuple [parameters, modifiers].
 * Destructure as [
 *    { page, perPage, sort, order, filter, filterValues, displayedFilters, requestSignature },
 *    { setFilters, hideFilter, showFilter, setPage, setPerPage, setSort }
 * ]
 *
 * @example
 *
 * const [listParams, listParamsActions] = useListParams({
 *      resource: 'posts',
 *      location: location // From react-router. Injected to your component by react-admin inside a List
 *      filterDefaultValues: {
 *          published: true
 *      },
 *      sort: {
 *          field: 'published_at',
 *          order: 'DESC'
 *      },
 *      perPage: 25
 * });
 *
 * const {
 *      page,
 *      perPage,
 *      sort,
 *      order,
 *      filter,
 *      filterValues,
 *      displayedFilters,
 *      requestSignature
 * } = listParams;
 *
 * const {
 *      setFilters,
 *      hideFilter,
 *      showFilter,
 *      setPage,
 *      setPerPage,
 *      setSort,
 * } = listParamsActions;
 */
declare const useListParams: ({ resource, filterDefaultValues, sort, perPage, debounce, disableSyncWithLocation, }: ListParamsOptions) => [Parameters, Modifiers];
declare const validQueryParams: string[];
declare const parseQueryFromLocation: ({ search }: {
    search: any;
}) => Partial<ListParams>;
/**
 * Check if user has already set custom sort, page, or filters for this list
 *
 * User params come from the store as the params props. By default,
 * this object is:
 *
 * { filter: {}, order: null, page: 1, perPage: null, sort: null }
 *
 * To check if the user has custom params, we must compare the params
 * to these initial values.
 *
 * @param {Object} params
 */
declare const hasCustomParams: (params: ListParams) => boolean;
/**
 * Merge list params from 3 different sources:
 *   - the query string
 *   - the params stored in the state (from previous navigation)
 *   - the props passed to the List component (including the filter defaultValues)
 */
declare const getQuery: ({ queryFromLocation, params, filterDefaultValues, sort, perPage, }: {
    queryFromLocation: any;
    params: any;
    filterDefaultValues: any;
    sort: any;
    perPage: any;
}) => ListParams;
declare const getNumberOrDefault: (possibleNumber: string | number | undefined, defaultValue: number) => number;
interface ListParamsOptions {
    resource: string;
    perPage?: number;
    sort?: SortPayload;
    filterDefaultValues?: FilterPayload;
    debounce?: number;
    disableSyncWithLocation?: boolean;
}
interface Parameters extends ListParams {
    filterValues: object;
    displayedFilters: {
        [key: string]: boolean;
    };
    requestSignature: any[];
}
interface Modifiers {
    changeParams: (action: any) => void;
    setPage: (page: number) => void;
    setPerPage: (pageSize: number) => void;
    setSort: (sort: SortPayload) => void;
    setFilters: (filters: any, displayedFilters: any) => void;
    hideFilter: (filterName: string) => void;
    showFilter: (filterName: string, defaultValue: any) => void;
}

/**
 * Hook to read the list controller props from the ListContext.
 *
 * Must be used within a <ListContextProvider> (e.g. as a descendent of <List>
 * or <ListBase>).
 *
 * @typedef {Object} ListSortContextValue
 * @prop {Object}   sort a sort object { field, order }, e.g. { field: 'date', order: 'DESC' }
 * @prop {Function} setSort a callback to change the sort, e.g. setSort({ field: 'name', order: 'ASC' })
 * @prop {string}   resource the resource name, deduced from the location. e.g. 'posts'
 *
 * @returns {ListSortContextValue} list controller props
 *
 * @see useListController for how it is filled
 */
declare const useListSortContext: (props?: any) => ListSortContextValue;

declare const SET_SORT = "SET_SORT";
declare const SORT_ASC = "ASC";
declare const SORT_DESC = "DESC";
declare const SET_PAGE = "SET_PAGE";
declare const SET_PER_PAGE = "SET_PER_PAGE";
declare const SET_FILTER = "SET_FILTER";
declare const SHOW_FILTER = "SHOW_FILTER";
declare const HIDE_FILTER = "HIDE_FILTER";
declare type ActionTypes = {
    type: typeof SET_SORT;
    payload: {
        field: string;
        order?: typeof SORT_ASC | typeof SORT_DESC;
    };
} | {
    type: typeof SET_PAGE;
    payload: number;
} | {
    type: typeof SET_PER_PAGE;
    payload: number;
} | {
    type: typeof SET_FILTER;
    payload: {
        filter: any;
        displayedFilters?: {
            [key: string]: boolean;
        };
    };
} | {
    type: typeof SHOW_FILTER;
    payload: {
        filterName: string;
        defaultValue?: any;
    };
} | {
    type: typeof HIDE_FILTER;
    payload: string;
};
/**
 * This reducer is for the react-router query string.
 */
declare const queryReducer: Reducer<ListParams, ActionTypes>;

/**
 * Get the list of selected items for a resource, and callbacks to change the selection
 *
 * @param resource The resource name, e.g. 'posts'
 *
 * @returns {Object} Destructure as [selectedIds, { select, toggle, clearSelection }].
 */
declare const useRecordSelection: (resource: string) => [Identifier[], {
    select: (ids: Identifier[]) => void;
    unselect: (ids: Identifier[]) => void;
    toggle: (id: Identifier) => void;
    clearSelection: () => void;
}];

/**
 * Hook to Unselect the rows of a datagrid
 *
 * @example
 *
 * const unselect = useUnselect('posts');
 * unselect([123, 456]);
 */
declare const useUnselect: (resource: string) => (ids: Identifier[]) => void;

/**
 * Hook to unselect all row of a datagrid
 *
 * @example
 *
 * const unselectAll = useUnselectAll('posts');
 * unselectAll();
 */
declare const useUnselectAll: (resource: string) => () => void;

/**
 * State-like hook for controlling the expanded state of a list item
 *
 * @param {string} resource The resource name, e.g. 'posts'
 * @param {string|integer} id The record identifier, e.g. 123
 * @param {boolean} single Forces only one id to be expanded at a time
 * @returns {Object} Destructure as [expanded, toggleExpanded].
 *
 * @example
 *
 * const [expanded, toggleExpanded] = useExpanded('posts', 123);
 * const expandIcon = expanded ? ExpandLess : ExpandMore;
 * const onExpandClick = () => toggleExpanded();
 */
declare const useExpanded: (resource: string, id: Identifier, single?: boolean) => [boolean, () => void];

interface UseReferenceArrayFieldControllerParams {
    filter?: any;
    page?: number;
    perPage?: number;
    record?: RaRecord;
    reference: string;
    resource: string;
    sort?: SortPayload;
    source: string;
}
/**
 * Hook that fetches records from another resource specified
 * by an array of *ids* in current record.
 *
 * @example
 *
 * const { data, error, isFetching, isLoading } = useReferenceArrayFieldController({
 *      record: { referenceIds: ['id1', 'id2']};
 *      reference: 'reference';
 *      resource: 'resource';
 *      source: 'referenceIds';
 * });
 *
 * @param {Object} props
 * @param {Object} props.record The current resource record
 * @param {string} props.reference The linked resource name
 * @param {string} props.resource The current resource name
 * @param {string} props.source The key of the linked resource identifier
 *
 * @param {Props} props
 *
 * @returns {ListControllerResult} The reference props
 */
declare const useReferenceArrayFieldController: (props: UseReferenceArrayFieldControllerParams) => ListControllerResult;

interface UseReferenceManyFieldControllerParams {
    filter?: any;
    page?: number;
    perPage?: number;
    record?: RaRecord;
    reference: string;
    resource: string;
    sort?: SortPayload;
    source?: string;
    target: string;
}
/**
 * Fetch reference records, and return them when available
 *
 * The reference prop should be the name of one of the <Resource> components
 * added as <Admin> child.
 *
 * @example
 *
 * const { isLoading, data } = useReferenceManyFieldController({
 *     resource
 *     reference: 'users',
 *     record: {
 *         userId: 7
 *     }
 *     target: 'comments',
 *     source: 'userId',
 *     page: 1,
 *     perPage: 25,
 * });
 *
 * @param {Object} props
 * @param {string} props.resource The current resource name
 * @param {string} props.reference The linked resource name
 * @param {Object} props.record The current resource record
 * @param {string} props.target The target resource key
 * @param {Object} props.filter The filter applied on the recorded records list
 * @param {string} props.source The key of the linked resource identifier
 * @param {number} props.page the page number
 * @param {number} props.perPage the number of item per page
 * @param {Object} props.sort the sort to apply to the referenced records
 *
 * @returns {ListControllerResult} The reference many props
 */
declare const useReferenceManyFieldController: (props: UseReferenceManyFieldControllerParams) => ListControllerResult;

interface UseReferenceProps {
    id: Identifier;
    reference: string;
}
interface UseReferenceResult<RecordType extends RaRecord = any> {
    isLoading: boolean;
    isFetching: boolean;
    referenceRecord?: RecordType;
    error?: any;
    refetch: UseGetManyHookValue<RecordType>['refetch'];
}
/**
 * @typedef UseReferenceResult
 * @type {Object}
 * @property {boolean} isFetching: boolean indicating if the reference is loading
 * @property {boolean} isLoading: boolean indicating if the reference has loaded at least once
 * @property {Object} referenceRecord: the referenced record.
 */
/**
 * Fetch reference record, and return it when available
 *
 * The reference prop should be the name of one of the <Resource> components
 * added as <Admin> child.
 *
 * @example
 *
 * const { isLoading, referenceRecord } = useReference({
 *     id: 7,
 *     reference: 'users',
 * });
 *
 * @param {Object} option
 * @param {string} option.reference The linked resource name
 * @param {string} option.id The id of the reference
 *
 * @returns {UseReferenceResult} The reference record
 */
declare const useReference: <RecordType extends RaRecord = any>({ reference, id, }: UseReferenceProps) => UseReferenceResult<RecordType>;

interface UseReferenceOneFieldControllerParams {
    record?: RaRecord;
    reference: string;
    source?: string;
    target: string;
}
/**
 * Fetch a reference record in a one-to-one relationship, and return it when available
 *
 * The reference prop should be the name of one of the <Resource> components
 * added as <Admin> child.
 *
 * @example
 *
 * const { data, isLoading, error } = useReferenceOneFieldController({
 *     record: { id: 7, name: 'James Joyce'}
 *     reference: 'bios',
 *     target: 'author_id',
 * });
 *
 * @typedef {Object} UseReferenceOneFieldControllerParams
 * @prop {Object} props.record The current resource record
 * @prop {string} props.reference The linked resource name
 * @prop {string} props.target The target resource key
 * @prop {string} props.source The key current record identifier ('id' by default)
 *
 * @returns {UseReferenceResult} The request state. Destructure as { referenceRecord, isLoading, error }.
 */
declare const useReferenceOneFieldController: (props: UseReferenceOneFieldControllerParams) => UseReferenceResult;

interface MatchingReferencesError {
    error: string;
}

interface GetStatusForInputParams<RecordType extends RaRecord = RaRecord> {
    field: Pick<ControllerRenderProps, 'value'>;
    matchingReferences: RecordType[] | MatchingReferencesError;
    referenceRecord: RecordType;
    translate: Translate;
}
declare const getStatusForInput: <RecordType extends RaRecord = RaRecord>({ field, matchingReferences, referenceRecord, translate, }: GetStatusForInputParams<RecordType>) => {
    waiting: boolean;
    error: string;
    warning: string;
    choices: RecordType[];
};
declare const getSelectedReferencesStatus: <RecordType extends RaRecord = any>(field: Pick<ControllerRenderProps, 'value'>, referenceRecords: RecordType[]) => "REFERENCES_STATUS_READY" | "REFERENCES_STATUS_INCOMPLETE" | "REFERENCES_STATUS_EMPTY";
interface GetStatusForArrayInputParams<RecordType extends RaRecord = any> {
    field: ControllerRenderProps;
    matchingReferences: RecordType[] | MatchingReferencesError;
    referenceRecords: RecordType[];
    translate: Translate;
}
declare const getStatusForArrayInput: <RecordType extends RaRecord = any>({ field, matchingReferences, referenceRecords, translate, }: GetStatusForArrayInputParams<RecordType>) => {
    waiting: boolean;
    error: string;
    warning: string;
    choices: RecordType[];
};

/**
 * Get the current (edited) value of the record from the form and pass it
 * to a child function
 *
 * @example
 *
 * const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <BooleanInput source="hasEmail" />
 *             <FormDataConsumer>
 *                 {({ formData, ...rest }) => formData.hasEmail &&
 *                      <TextInput source="email" {...rest} />
 *                 }
 *             </FormDataConsumer>
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * @example
 *
 * const OrderEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <SelectInput source="country" choices={countries} />
 *             <FormDataConsumer>
 *                 {({ formData, ...rest }) =>
 *                      <SelectInput
 *                          source="city"
 *                          choices={getCitiesFor(formData.country)}
 *                          {...rest}
 *                      />
 *                 }
 *             </FormDataConsumer>
 *         </SimpleForm>
 *     </Edit>
 * );
 */
declare const FormDataConsumer: (props: ConnectedProps) => JSX.Element;
interface FormDataConsumerRenderParams {
    formData: any;
    scopedFormData?: any;
    getSource?: (source: string) => string;
}
declare type FormDataConsumerRender = (params: FormDataConsumerRenderParams) => ReactNode;
interface ConnectedProps {
    children: FormDataConsumerRender;
    form?: string;
    record?: any;
    source?: string;
    [key: string]: any;
}

declare const FormGroupsContext: react.Context<FormGroupsContextValue>;
declare type FormGroupSubscriber = () => void;
declare type FormGroupsContextValue = {
    registerGroup: (name: string) => void;
    unregisterGroup: (name: string) => void;
    registerField: (source: string, group?: string) => void;
    unregisterField: (source: string, group?: string) => void;
    getGroupFields: (name: string) => string[];
    /**
     * Subscribe to any changes of the group content (fields added or removed).
     * Subscribers can get the current fields of the group by calling getGroupFields.
     * Returns a function to unsubscribe.
     */
    subscribe: (name: string, subscriber: FormGroupSubscriber) => () => void;
};

interface ValidationErrorMessageWithArgs {
    message: string;
    args: {
        [key: string]: ValidationErrorMessageWithArgs | any;
    };
}
declare type ValidationErrorMessage = string | ValidationErrorMessageWithArgs;
declare type Validator = (value: any, values: any, props: any) => ValidationErrorMessage | null | undefined | Promise<ValidationErrorMessage | null | undefined>;
declare const combine2Validators: (validator1: Validator, validator2: Validator) => Validator;
declare const composeValidators: (...validators: any[]) => Validator;
declare const composeSyncValidators: (...validators: any[]) => (value: any, values: any, meta: any) => ValidationErrorMessage | Promise<ValidationErrorMessage>;
/**
 * Required validator
 *
 * Returns an error if the value is null, undefined, or empty
 *
 * @param {string|Function} message
 *
 * @example
 *
 * const titleValidators = [required('The title is required')];
 * <TextInput name="title" validate={titleValidators} />
 */
declare const required: (message?: any) => ((value: any, values: any) => string | {
    message: string;
    args: any;
}) & {
    isRequired: boolean;
};
/**
 * Minimum length validator
 *
 * Returns an error if the value has a length less than the parameter
 *
 * @param {integer} min
 * @param {string|Function} message
 *
 * @example
 *
 * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];
 * <TextInput type="password" name="password" validate={passwordValidators} />
 */
declare const minLength: (min: any, message?: any) => (value: any, values: any) => string | {
    message: string;
    args: any;
};
/**
 * Maximum length validator
 *
 * Returns an error if the value has a length higher than the parameter
 *
 * @param {integer} max
 * @param {string|Function} message
 *
 * @example
 *
 * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];
 * <TextInput name="name" validate={nameValidators} />
 */
declare const maxLength: (max: any, message?: any) => (value: any, values: any) => string | {
    message: string;
    args: any;
};
/**
 * Minimum validator
 *
 * Returns an error if the value is less than the parameter
 *
 * @param {integer} min
 * @param {string|Function} message
 *
 * @example
 *
 * const fooValidators = [minValue(5, 'Should be more than 5')];
 * <NumberInput name="foo" validate={fooValidators} />
 */
declare const minValue: (min: any, message?: any) => (value: any, values: any) => string | {
    message: string;
    args: any;
};
/**
 * Maximum validator
 *
 * Returns an error if the value is higher than the parameter
 *
 * @param {integer} max
 * @param {string|Function} message
 *
 * @example
 *
 * const fooValidators = [maxValue(10, 'Should be less than 10')];
 * <NumberInput name="foo" validate={fooValidators} />
 */
declare const maxValue: (max: any, message?: any) => (value: any, values: any) => string | {
    message: string;
    args: any;
};
/**
 * Number validator
 *
 * Returns an error if the value is not a number
 *
 * @param {string|Function} message
 *
 * @example
 *
 * const ageValidators = [number('Must be a number')];
 * <TextInput name="age" validate={ageValidators} />
 */
declare const number: (message?: any) => (value: any, values: any) => string | {
    message: string;
    args: any;
};
/**
 * Regular expression validator
 *
 * Returns an error if the value does not match the pattern given as parameter
 *
 * @param {RegExp} pattern
 * @param {string|Function} message
 *
 * @example
 *
 * const zipValidators = [regex(/^\d{5}(?:[-\s]\d{4})?$/, 'Must be a zip code')];
 * <TextInput name="zip" validate={zipValidators} />
 */
declare const regex: ((pattern: any, message?: any) => (value: any, values?: any) => string | {
    message: string;
    args: any;
}) & lodash.MemoizedFunction;
/**
 * Email validator
 *
 * Returns an error if the value is not a valid email
 *
 * @param {string|Function} message
 *
 * @example
 *
 * const emailValidators = [email('Must be an email')];
 * <TextInput name="email" validate={emailValidators} />
 */
declare const email: (message?: any) => (value: any, values?: any) => string | {
    message: string;
    args: any;
};
/**
 * Choices validator
 *
 * Returns an error if the value is not among the list passed as parameter
 *
 * @param {array} list
 * @param {string|Function} message
 *
 * @example
 *
 * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];
 * <TextInput name="gender" validate={genderValidators} />
 */
declare const choices: (list: any, message?: any) => (value: any, values: any) => string | {
    message: string;
    args: any;
};
/**
 * Given a validator, returns a boolean indicating whether the field is required or not.
 */
declare const isRequired: (validate: any) => boolean;

interface ValidationErrorProps {
    error: ValidationErrorMessage;
}
declare const ValidationError: (props: ValidationErrorProps) => JSX.Element;

/**
 * Convert a simple validation function that returns an object matching the form shape with errors
 * to a validation resolver compatible with react-hook-form.
 *
 * @example
 * const validate = (values: any) => {
 *     if (values.username == null || values.username.trim() === '') {
 *         return { username: 'Required' };
 *     }
 * }
 *
 * const validationResolver = getSimpleValidationResolver(validate);
 *
 * const UserForm = () => (
 *     <Form
 *         defaultValues={{ username: 'John' }}
 *         validationResolver={validationResolver}
 *     >
 *         <TextField source="username" />
 *     </Form>
 * );
 */
declare const getSimpleValidationResolver: (validate: ValidateForm) => (data: FieldValues) => Promise<{
    values: FieldValues;
    errors: {};
} | {
    values: {};
    errors: FieldValues;
}>;
declare type ValidateForm = (data: FieldValues) => FieldValues | Promise<FieldValues>;

/**
 * Context to store choices and functions to retrieve them.
 *
 * Use the useChoicesContext() hook to read the context.
 */
declare const ChoicesContext: react.Context<ChoicesContextValue<any>>;
declare type ChoicesContextValue<RecordType extends RaRecord = any> = {
    allChoices: RecordType[];
    availableChoices: RecordType[];
    displayedFilters: any;
    error?: any;
    filter?: FilterPayload;
    filterValues: any;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    hideFilter: (filterName: string) => void;
    isFetching: boolean;
    isLoading: boolean;
    page: number;
    perPage: number;
    refetch: () => void;
    resource: string;
    selectedChoices: RecordType[];
    setFilters: (filters: any, displayedFilters: any, debounce?: boolean) => void;
    setPage: (page: number) => void;
    setPerPage: (page: number) => void;
    setSort: (sort: SortPayload) => void;
    showFilter: (filterName: string, defaultValue: any) => void;
    sort: SortPayload;
    source: string;
    total: number;
};

declare const ChoicesContextProvider: ({ children, value, }: {
    children: ReactNode;
    value: ChoicesContextValue;
}) => JSX.Element;

declare const useChoicesContext: <ChoicesType extends RaRecord = RaRecord>(options?: Partial<ChoicesContextValue<any>> & {
    choices?: ChoicesType[];
}) => ChoicesContextValue;

/**
 * Creates a form element, initialized with the current record, calling the saveContext on submit
 *
 * Wrapper around react-hook-form's useForm, FormContextProvider, and <form>.
 * Also sets up a FormGroupContext, and handles submission validation.
 *
 * @example
 *
 * const MyForm = ({ record, defaultValues, validate }) => (
 *    <Form record={record} defaultValues={defaultValues} validate={validate}>
 *        <Stack>
 *            <TextInput source="title" />
 *            <SaveButton />
 *        </Stack>
 *    </Form>
 * );
 *
 * @typedef {Object} Props the props you can use
 * @prop {Object} defaultValues
 * @prop {Function} validate
 * @prop {Function} save
 *
 * @see useForm
 * @see FormGroupContext
 *
 * @link https://react-hook-form.com/api/useformcontext
 */
declare const Form: (props: FormProps) => JSX.Element;
declare type FormProps = FormOwnProps & Omit<UseFormProps, 'onSubmit'> & {
    validate?: ValidateForm;
    noValidate?: boolean;
};
interface FormOwnProps {
    children: ReactNode;
    className?: string;
    defaultValues?: any;
    formRootPathname?: string;
    id?: string;
    record?: Partial<RaRecord>;
    onSubmit?: (data: FieldValues) => any | Promise<any>;
    warnWhenUnsavedChanges?: boolean;
}

/**
 * Context allowing inputs to register to a specific group.
 * This enables other components in the group to access group properties such as its
 * validation (valid/invalid) or whether its inputs have been updated (dirty/pristine).
 *
 * This should only be used through a FormGroupContextProvider.
 */
declare const FormGroupContext: react.Context<string>;
declare type FormGroupContextValue = string;

/**
 * This provider allows its input children to register to a specific group.
 * This enables other components in the group to access group properties such as its
 * validation (valid/invalid) or whether its inputs have been updated (dirty/pristine).
 *
 * @example
 * import { Edit, SimpleForm, TextInput, FormGroupContextProvider, useFormGroup } from 'react-admin';
 * import { Accordion, AccordionDetails, AccordionSummary, Typography } from '@mui/material';
 *
 * const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <TextInput source="title" />
 *             <FormGroupContextProvider name="options">
 *                 <Accordion>
 *                     <AccordionSummary
 *                         expandIcon={<ExpandMoreIcon />}
 *                         aria-controls="options-content"
 *                         id="options-header"
 *                     >
 *                         <AccordionSectionTitle name="options">Options</AccordionSectionTitle>
 *                     </AccordionSummary>
 *                     <AccordionDetails id="options-content" aria-labelledby="options-header">
 *                         <TextInput source="teaser" validate={minLength(20)} />
 *                     </AccordionDetails>
 *                 </Accordion>
 *             </FormGroupContextProvider>
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * const AccordionSectionTitle = ({ children, name }) => {
 *     const formGroupState = useFormGroup(name);
 *     return (
 *         <Typography color={formGroupState.invalid && formGroupState.dirty ? 'error' : 'inherit'}>
 *             {children}
 *         </Typography>
 *     );
 * }
 *
 * @param props The component props
 * @param {ReactNode} props.children The form group content
 * @param {String} props.name The form group name
 */
declare const FormGroupContextProvider: ({ children, name, }: {
    children: ReactNode;
    name: string;
}) => JSX.Element;

/**
 * This component provides functions through context to manage form groups,
 * allowing to link or unlink an input to a group.
 * @see FormGroupContextProvider
 * @see useFormGroup
 * @see useFormGroups
 */
declare const FormGroupsProvider: ({ children }: {
    children: ReactNode;
}) => JSX.Element;

/**
 * This internal function is used to convert an object matching the form shape with errors to a
 * format compatible with react-hook-form. It's used to handle submission errors. Only useful when
 * you are implementing a custom form without leveraging our Form component.
 *
 * @example
 * const MyForm = () => {
 *     const { register, handleSubmit, setError } = useForm();
 *     const onSubmit = data => {
 *         return saveAsync(data).catch(error => setSubmissionErrors(error.body.details));
 *     };
 *
 *     return (
 *         <form onSubmit={handleSubmit(onSubmit)}>
 *             ...
 *         </form>
 *     );
 * };
 */
declare const setSubmissionErrors: (errors: FieldValues, setError: UseFormSetError<FieldValues>) => void;

declare const useInput: (props: InputProps) => UseInputValue;
declare type InputProps<ValueType = any> = Omit<UseControllerProps, 'name' | 'defaultValue' | 'rules'> & Partial<UseControllerReturn> & {
    alwaysOn?: any;
    defaultValue?: any;
    format?: (value: ValueType) => any;
    id?: string;
    isRequired?: boolean;
    label?: string | ReactElement | false;
    helperText?: string | ReactElement | false;
    name?: string;
    onBlur?: (...event: any[]) => void;
    onChange?: (...event: any[]) => void;
    parse?: (value: any) => ValueType;
    resource?: string;
    source: string;
    validate?: Validator | Validator[];
};
declare type UseInputValue = {
    id: string;
    isRequired: boolean;
    field: ControllerRenderProps;
    formState: UseFormStateReturn<Record<string, string>>;
    fieldState: ControllerFieldState;
};

declare const useApplyInputDefaultValues: (props: Partial<InputProps>) => void;

declare type OptionTextElement = ReactElement<{
    record: RaRecord;
}>;
declare type OptionTextFunc = (choice: any) => string | OptionTextElement;
declare type OptionText = OptionTextElement | OptionTextFunc | string;
interface ChoicesProps {
    choices?: any[];
    isFetching?: boolean;
    isLoading?: boolean;
    optionValue?: string;
    optionText?: OptionText;
    translateChoice?: boolean;
}
interface UseChoicesOptions {
    optionValue?: string;
    optionText?: OptionText;
    disableValue?: string;
    translateChoice?: boolean;
}
declare const useChoices: ({ optionText, optionValue, disableValue, translateChoice, }: UseChoicesOptions) => {
    getChoiceText: (choice: any) => string | JSX.Element;
    getChoiceValue: (choice: any) => any;
    getDisableValue: (choice: any) => any;
};

declare type FieldState = {
    name: string;
    error?: any;
    isDirty: boolean;
    isTouched: boolean;
    isValid: boolean;
};
declare type FormGroupState = {
    errors: object;
    isDirty: boolean;
    isTouched: boolean;
    isValid: boolean;
};
/**
 * Retrieve a specific form group data such as its validation status (valid/invalid) or
 * or whether its inputs have been updated (dirty/pristine)
 *
 * @example
 * import { Edit, SimpleForm, TextInput, FormGroupContextProvider, useFormGroup, minLength } from 'react-admin';
 * import { Accordion, AccordionDetails, AccordionSummary, Typography } from '@mui/material';
 * import ExpandMoreIcon from '@mui/icons-material/ExpandMoreIcon';
 *
 * const PostEdit = (props) => (
 *     <Edit {...props}>
 *         <SimpleForm>
 *             <TextInput source="title" />
 *             <FormGroupContextProvider name="options">
 *                 <Accordion>
 *                     <AccordionSummary
 *                         expandIcon={<ExpandMoreIcon />}
 *                         aria-controls="options-content"
 *                         id="options-header"
 *                     >
 *                         <AccordionSectionTitle name="options">Options</AccordionSectionTitle>
 *                     </AccordionSummary>
 *                     <AccordionDetails id="options-content" aria-labelledby="options-header">
 *                         <TextInput source="teaser" validate={minLength(20)} />
 *                     </AccordionDetails>
 *                 </Accordion>
 *             </FormGroupContextProvider>
 *         </SimpleForm>
 *     </Edit>
 * );
 *
 * const AccordionSectionTitle = ({ children, name }) => {
 *     const formGroupState = useFormGroup(name);
 *     return (
 *         <Typography color={!formGroupState.isValid && formGroupState.isDirty ? 'error' : 'inherit'}>
 *             {children}
 *         </Typography>
 *     );
 * }
 *
 * @param {string} name The form group name
 * @returns {FormGroupState} The form group state
 */
declare const useFormGroup: (name: string) => FormGroupState;
/**
 * Get the state of a form group
 *
 * @param {FieldState[]} fieldStates A map of field states from react-hook-form where the key is the field name.
 * @returns {FormGroupState} The state of the group.
 */
declare const getFormGroupState: (fieldStates: FieldState[]) => FormGroupState;

/**
 * Retrieve the name of the form group the consumer belongs to. May be undefined if the consumer is not inside a form group.
 */
declare const useFormGroupContext: () => string;

/**
 * This internal hook returns a function that can translate an error message.
 * It handles simple string errors and those which have a message and args.
 * Only useful if you are implementing custom inputs without leveraging our useInput hook.
 *
 * @example
 * const MyInput = props => {
 *      const { field, fieldState } = useController(props);
 *      useEffect(() => {
 *          if (fieldState.error) {
 *              const errorMessage = useGetValidationErrorMessage(fieldState.error);
 *              alert(errorMessage);
 *          }
 *      }, [fieldState.error]);
 *
 *      return (
 *          <input {...field} />
 *      );
 * }
 *
 * @see ValidationErrorMessage
 * @see ValidationErrorMessageWithArgs
 */
declare const useGetValidationErrorMessage: () => (error: ValidationErrorMessage) => string;

/**
 * Restore the record values which should override any default values specified on the form.
 */
declare const useInitializeFormWithRecord: (defaultValues: any, record: any) => void;

/**
 * This hook returns a boolean indicating whether the form is invalid.
 * We use this to display an error message on submit in Form and SaveButton.
 *
 * We can't do the form validity check in the form submit handler
 * as the form state may not have been updated yet when onSubmit validation mode is enabled
 * or when the form hasn't been touched at all.
 */
declare const useIsFormInvalid: (control?: Control) => boolean;

/**
 * Wrapper around react-hook-form's useForm
 *
 * This hook adds the following features to react-hook-form's useForm:
 *
 * - form initialization based on RecordContext
 * - validation based on a validate function
 * - notification on invalid form
 * - stop form submission event propagation
 */
declare const useAugmentedForm: (props: UseAugmentedFormProps) => {
    form: react_hook_form.UseFormReturn<any, any>;
    handleSubmit: (values: any) => Promise<void>;
    formHandleSubmit: (event: BaseSyntheticEvent) => void;
    isInvalid: boolean;
};
declare type UseAugmentedFormProps = UseFormOwnProps & Omit<UseFormProps, 'onSubmit'> & {
    validate?: ValidateForm;
};
interface UseFormOwnProps {
    defaultValues?: any;
    formRootPathname?: string;
    record?: Partial<RaRecord>;
    onSubmit?: (data: FieldValues) => any | Promise<any>;
    warnWhenUnsavedChanges?: boolean;
}

declare const useSuggestions: ({ allowCreate, choices, createText, createValue, emptyText, emptyValue, limitChoicesToValue, matchSuggestion, optionText, optionValue, selectedItem, suggestionLimit, translateChoice, }: UseSuggestionsOptions) => {
    getChoiceText: (choice: any) => string | JSX.Element;
    getChoiceValue: (choice: any) => any;
    getSuggestions: (filter: any) => any[];
};
interface UseSuggestionsOptions extends UseChoicesOptions {
    allowCreate?: boolean;
    allowDuplicates?: boolean;
    choices: any[];
    createText?: string;
    createValue?: any;
    emptyText?: string;
    emptyValue?: any;
    limitChoicesToValue?: boolean;
    matchSuggestion?: (filter: string, suggestion: any, exact?: boolean) => boolean;
    suggestionLimit?: number;
    selectedItem?: any | any[];
}
/**
 * Get the suggestions to display after applying a fuzzy search on the available choices
 *
 * @example
 *
 * getSuggestions({
 *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],
 *   optionText: 'name',
 *   optionValue: 'id',
 *   getSuggestionText: choice => choice[optionText],
 * })('pub')
 *
 * // Will return [{ id: 2, name: 'publisher' }]
 * getSuggestions({
 *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],
 *   optionText: 'name',
 *   optionValue: 'id',
 *   getSuggestionText: choice => choice[optionText],
 * })('pub')
 *
 * // Will return [{ id: 2, name: 'publisher' }]
 */
declare const getSuggestionsFactory: ({ allowCreate, choices, createText, createValue, emptyText, emptyValue, optionText, optionValue, getChoiceText, getChoiceValue, limitChoicesToValue, matchSuggestion, selectedItem, suggestionLimit, }: UseSuggestionsOptions & {
    getChoiceText: (choice: any) => string | ReactElement;
    getChoiceValue: (choice: any) => string;
}) => (filter: any) => any[];

/**
 * Display a confirmation dialog if the form has unsaved changes.
 * - If the user confirms, the navigation continues and the changes are lost.
 * - If the user cancels, the navigation is cancelled and the changes are kept.
 */
declare const useWarnWhenUnsavedChanges: (enable: boolean, formRootPathname?: string, control?: Control) => void;

/**
 * Prepare data for the ReferenceArrayInput components
 *
 * @example
 *
 * const { allChoices, availableChoices, selectedChoices, error, isFetching, isLoading } = useReferenceArrayInputController({
 *      record: { referenceIds: ['id1', 'id2']};
 *      reference: 'reference';
 *      resource: 'resource';
 *      source: 'referenceIds';
 * });
 *
 * @param {Object} props
 * @param {Object} props.record The current resource record
 * @param {string} props.reference The linked resource name
 * @param {string} props.resource The current resource name
 * @param {string} props.source The key of the linked resource identifier
 *
 * @param {Props} props
 *
 * @return {Object} controllerProps Fetched data and callbacks for the ReferenceArrayInput components
 */
declare const useReferenceArrayInputController: <RecordType extends RaRecord = any>(props: UseReferenceArrayInputParams<RecordType>) => ChoicesContextValue<RecordType>;
interface UseReferenceArrayInputParams<RecordType extends RaRecord = any> {
    debounce?: number;
    filter?: FilterPayload;
    queryOptions?: UseQueryOptions<{
        data: RecordType[];
        total?: number;
        pageInfo?: {
            hasNextPage?: boolean;
            hasPreviousPage?: boolean;
        };
    }>;
    page?: number;
    perPage?: number;
    record?: RecordType;
    reference: string;
    resource?: string;
    sort?: SortPayload;
    source: string;
    enableGetChoices?: (filters: any) => boolean;
}

declare const defaultReferenceSource: (resource: string, source: string) => string;
/**
 * A hook for choosing a reference record. Useful for foreign keys.
 *
 * This hook fetches the possible values in the reference resource
 * (using `dataProvider.getList()`), it returns the possible choices
 * as the `choices` attribute.
 *
 * @example
 * const {
 *      choices, // the available reference resource
 * } = useReferenceInputController({
 *      input, // the input props
 *      resource: 'comments',
 *      reference: 'posts',
 *      source: 'post_id',
 * });
 *
 * The hook also allow to filter results. It returns a `setFilters`
 * function. It uses the value to create a filter for the query.
 * You can also add a permanentFilter to further filter the result:
 *
 * @example
 * const {
 *      choices, // the available reference resource
 *      setFilter,
 * } = useReferenceInputController({
 *      input, // the input props
 *      resource: 'comments',
 *      reference: 'posts',
 *      source: 'post_id',
 *      permanentFilter: {
 *          author: 'john'
 *      },
 * });
 */
declare const useReferenceInputController: <RecordType extends RaRecord = any>(props: UseReferenceInputControllerParams) => ChoicesContextValue<RecordType>;
interface UseReferenceInputControllerParams<RecordType extends RaRecord = any> {
    debounce?: number;
    filter?: FilterPayload;
    queryOptions?: UseQueryOptions<{
        data: RecordType[];
        total?: number;
        pageInfo?: {
            hasNextPage?: boolean;
            hasPreviousPage?: boolean;
        };
    }>;
    page?: number;
    perPage?: number;
    record?: RaRecord;
    reference: string;
    referenceSource?: typeof defaultReferenceSource;
    resource?: string;
    sort?: SortPayload;
    source: string;
    enableGetChoices?: (filters: any) => boolean;
}

/**
 * Context to store a record.
 *
 * @see RecordContextProvider
 * @see useRecordContext
 */
declare const RecordContext: react.Context<RaRecord | Omit<RaRecord, "id">>;
/**
 * Provider for the Record Context, to store a record.
 *
 * Use the useRecordContext() hook to read the context.
 * That's what the Edit and Show components do in react-admin.
 *
 * Many react-admin components read the RecordContext, including all Field
 * components.
 *
 * @example
 *
 * import { useGetOne, RecordContextProvider } from 'ra-core';
 *
 * const Show = ({ resource, id }) => {
 *     const { data } = useGetOne(resource, { id });
 *     return (
 *         <RecordContextProvider value={data}>
 *             ...
 *         </RecordContextProvider>
 *     );
 * };
 */
declare const RecordContextProvider: <RecordType extends RaRecord | Omit<RaRecord, "id"> = RaRecord>({ children, value, }: RecordContextProviderProps<RecordType>) => JSX.Element;
interface RecordContextProviderProps<RecordType> {
    children: ReactNode;
    value?: RecordType;
}

/**
 * Hook to read the record from a RecordContext.
 *
 * Must be used within a <RecordContext> such as provided by the <EditContextProvider>
 * (e.g. as a descendent of <Edit> or <EditBase>) or within a <ShowContextProvider>
 * (e.g. as a descendent of <Show> or <ShowBase>)
 *
 * @example // basic usage
 *
 * import { useRecordContext } from 'ra-core';
 *
 * const TitleField = () => {
 *     const record = useRecordContext();
 *     return <span>{record && record.title}</span>;
 * };
 *
 * @example // allow record override via props
 *
 * import { useRecordContext } from 'ra-core';
 *
 * const TitleField = (props) => {
 *     const record = useRecordContext(props);
 *     return <span>{record && record.title}</span>;
 * };
 * render(<TextField record={record} />);
 *
 * @returns {RaRecord} A record object
 */
declare const useRecordContext: <RecordType extends RaRecord | Omit<RaRecord, "id"> = RaRecord>(props?: UseRecordContextParams<RecordType>) => RecordType;
interface UseRecordContextParams<RecordType extends RaRecord | Omit<RaRecord, 'id'> = RaRecord> {
    record?: RecordType;
    [key: string]: any;
}

/**
 * Render prop version of useRecordContext
 *
 * @example
 * const BookShow = () => (
 *    <Show>
 *       <SimpleShowLayout>
 *          <WithRecord render={record => <span>{record.title}</span>} />
 *      </SimpleShowLayout>
 *   </Show>
 * );
 */
declare const WithRecord: <RecordType extends RaRecord>({ render, }: WithRecordProps<RecordType>) => ReactElement<any, string | react.JSXElementConstructor<any>>;
interface WithRecordProps<RecordType extends RaRecord> {
    render: (record: RecordType) => ReactElement;
    label?: string;
}

/**
 * Wrap children with a RecordContext provider only if the value is defined.
 *
 * Allows a component to work outside of a record context.
 *
 * @example
 *
 * import { OptionalRecordContextProvider, TextField } from 'react-admin';
 *
 * const RecordTitle = ({ record }) => (
 *     <OptionalRecordContextProvider value={record}>
 *         <TextField source="title" />
 *     </OptionalRecordContextProvider>
 * );
 */
declare const OptionalRecordContextProvider: <RecordType extends RaRecord | Omit<RaRecord, "id"> = RaRecord>({ value, children, }: {
    children: ReactElement;
    value?: RecordType;
}) => JSX.Element;

/**
 * Prepare data for the Show view.
 *
 * useShowController does a few things:
 * - it grabs the id from the URL and the resource name from the ResourceContext,
 * - it fetches the record via useGetOne,
 * - it prepares the page title.
 *
 * @param {Object} props The props passed to the Show component.
 *
 * @return {Object} controllerProps Fetched data and callbacks for the Show view
 *
 * @example
 *
 * import { useShowController } from 'react-admin';
 * import ShowView from './ShowView';
 *
 * const MyShow = () => {
 *     const controllerProps = useShowController();
 *     return <ShowView {...controllerProps} />;
 * };
 *
 * @example // useShowController can also take its parameters from props
 *
 * import { useShowController } from 'react-admin';
 * import ShowView from './ShowView';
 *
 * const MyShow = () => {
 *     const controllerProps = useShowController({ resource: 'posts', id: 1234 });
 *     return <ShowView {...controllerProps} />;
 * };
 */
declare const useShowController: <RecordType extends RaRecord = any>(props?: ShowControllerProps<RecordType>) => ShowControllerResult<RecordType>;
interface ShowControllerProps<RecordType extends RaRecord = any> {
    disableAuthentication?: boolean;
    id?: RecordType['id'];
    queryOptions?: UseQueryOptions<RecordType>;
    resource?: string;
}
interface ShowControllerResult<RecordType extends RaRecord = any> {
    defaultTitle: string;
    data?: RecordType;
    error?: any;
    isFetching: boolean;
    isLoading: boolean;
    resource: string;
    record?: RecordType;
    refetch: UseGetOneHookValue<RecordType>['refetch'];
}

/**
 * Call useShowController and put the value in a ShowContext
 *
 * Base class for <Show> components, without UI.
 *
 * Accepts any props accepted by useShowController:
 * - id: The record identifier
 * - resource: The resource
 *
 * @example // Custom show layout
 *
 * const PostShow = () => (
 *     <ShowBase resource="posts">
 *         <Grid container>
 *             <Grid item xs={8}>
 *                 <SimpleForm>
 *                     ...
 *                 </SimpleForm>
 *             </Grid>
 *             <Grid item xs={4}>
 *                 Show instructions...
 *             </Grid>
 *         </Grid>
 *         <div>
 *             Post related links...
 *         </div>
 *     </ShowBase>
 * );
 */
declare const ShowBase: <RecordType extends RaRecord = any>({ children, ...props }: {
    children: ReactElement;
} & ShowControllerProps<RecordType>) => JSX.Element;

/**
 * Context to store the result of the useShowController() hook.
 *
 * Use the useShowContext() hook to read the context. That's what the Show components do in react-admin.
 *
 * @example
 *
 * import { useShowController, ShowContextProvider } from 'ra-core';
 *
 * const Show = props => {
 *     const controllerProps = useShowController(props);
 *     return (
 *         <ShowContextProvider value={controllerProps}>
 *             ...
 *         </ShowContextProvider>
 *     );
 * };
 */
declare const ShowContext: react.Context<ShowControllerResult<any>>;

/**
 * Create a Show Context.
 *
 * @example
 *
 * const MyShow = (props) => {
 *     const controllerProps = useShowController(props);
 *     return (
 *         <ShowContextProvider value={controllerProps}>
 *             <MyShowView>
 *         </ShowContextProvider>
 *     );
 * };
 *
 * const MyShowView = () => {
 *     const record = useRecordContext();
 * }
 *
 * @see ShowContext
 * @see RecordContext
 */
declare const ShowContextProvider: ({ children, value, }: {
    children: ReactNode;
    value: ShowControllerResult;
}) => JSX.Element;

/**
 * Render prop version of the useShowController hook
 *
 * @see useShowController
 * @example
 *
 * const ShowView = () => <div>...</div>
 * const MyShow = () => (
 *     <ShowController>
 *         {controllerProps => <ShowView {...controllerProps} {...props} />}
 *     </ShowController>
 * );
 */
declare const ShowController: ({ children, ...props }: {
    children: (params: ShowControllerResult) => JSX.Element;
} & ShowControllerProps<any>) => JSX.Element;

/**
 * Hook to read the show controller props from the ShowContext.
 *
 * Mostly used within a <ShowContext.Provider> (e.g. as a descendent of <Show>).
 *
 * But you can also use it without a <ShowContext.Provider>. In this case, it is up to you
 * to pass all the necessary props.
 *
 * The given props will take precedence over context values.
 *
 * @typedef {Object} ShowControllerResult
 *
 * @returns {ShowControllerResult} create controller props
 *
 * @see useShowController for how it is filled
 *
 */
declare const useShowContext: <RecordType extends RaRecord = any>(props?: Partial<ShowControllerResult<RecordType>>) => Partial<ShowControllerResult<RecordType>>;

declare type NotificationType = 'success' | 'info' | 'warning' | 'error';
interface NotificationOptions {
    autoHideDuration?: number;
    messageArgs?: any;
    multiLine?: boolean;
    undoable?: boolean;
}
interface NotificationPayload {
    readonly message: string;
    readonly type: NotificationType;
    readonly notificationOptions?: NotificationOptions;
}

/**
 * Hook for Notification Side Effect
 *
 * @example
 *
 * const notify = useNotify();
 * // simple message (info level)
 * notify('Level complete');
 * // specify level
 * notify('A problem occurred', { type: 'warning' })
 * // pass arguments to the translation function
 * notify('Deleted %{count} elements', { type: 'info', messageArgs: { smart_count: 23 } })
 * // show the action as undoable in the notification
 * notify('Post renamed', { type: 'info', undoable: true })
 */
declare const useNotify: () => (message: string, options?: NotificationOptions & {
    type?: NotificationType;
}) => void;

declare type NotificationContextType = {
    notifications: NotificationPayload[];
    addNotification: (notification: NotificationPayload) => void;
    takeNotification: () => NotificationPayload | void;
    resetNotifications: () => void;
};
/**
 * Context for the notification state and modifiers
 *
 * @example // display notifications
 * import { useNotificationContext } from 'react-admin';
 *
 * const App = () => {
 *    const { notifications } = useNotificationContext();
 *    return (
 *        <ul>
 *            {notifications.map(({ message }) => (
 *                <li key={index}>{ message }</li>
 *            ))}
 *        </ul>
 *    );
 * };
 *
 * @example // reset notifications
 * import { useNotificationContext } from 'react-admin';
 *
 * const ResetNotificationsButton = () => {
 *    const { resetNotifications } = useNotificationContext();
 *    return (
 *        <button onClick={() => resetNotifications()}>Reset notifications</button>
 *    );
 * };
 */
declare const NotificationContext: react.Context<NotificationContextType>;

declare const NotificationContextProvider: ({ children }: {
    children: any;
}) => JSX.Element;

declare const useNotificationContext: () => NotificationContextType;

export { AUTH_CHECK, AUTH_ERROR, AUTH_GET_PERMISSIONS, AUTH_LOGIN, AUTH_LOGOUT, AdminChildren, AdminRouter, AdminRouterProps, AuthActionType, AuthContext, AuthProvider, Authenticated, AuthenticatedProps, BasenameContextProvider, CREATE, CatchAllComponent, CheckAuth, ChildrenFunction, ChoicesContext, ChoicesContextProvider, ChoicesContextValue, ChoicesProps, _default$4 as ComponentPropType, CoreAdmin, CoreAdminContext, CoreAdminContextProps, CoreAdminProps, CoreAdminRoutes, CoreAdminRoutesProps, CoreAdminUI, CoreAdminUIProps, CoreLayoutProps, CreateBase, CreateContext, CreateContextProvider, CreateController, CreateControllerProps, CreateControllerResult, CreateParams, CreatePathParams, CreateResult, CustomRoutes, CustomRoutesProps, DEFAULT_LOCALE, DELETE, DELETE_MANY, DashboardComponent, DataProvider, DataProviderContext, DataProviderMatcher, DataProviderResult, DeleteManyParams, DeleteManyResult, DeleteParams, DeleteResult, Dispatch, EditBase, EditContext, EditContextProvider, EditController, EditControllerProps, EditControllerResult, Exporter, ExporterContext, _default$6 as FieldTitle, FieldTitleProps, FilterPayload, Form, FormDataConsumer, FormDataConsumerRender, FormDataConsumerRenderParams, FormFunctions, FormGroupContext, FormGroupContextProvider, FormGroupContextValue, FormGroupSubscriber, FormGroupsContext, FormGroupsContextValue, FormGroupsProvider, FormOwnProps, FormProps, GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE, GetListParams, GetListResult, GetManyParams, GetManyReferenceParams, GetManyReferenceResult, GetManyResult, GetOneParams, GetOneResult, GetResourceLabel, GetTranslatableLabel, GetTranslatableSource, HIDE_FILTER, HttpError, I18N_CHANGE_LOCALE, I18N_TRANSLATE, I18nContext, I18nContextProps, I18nContextProvider, I18nContextProviderProps, I18nProvider, Identifier, InferenceTypes, InferredElement, InferredElementDescription, InferredType, InferredTypeMap, InputProps, LayoutComponent, LegacyAuthProvider, LegacyDataProvider, LinkToFunctionType, LinkToType, ListBase, ListContext, ListContextProvider, ListController, ListControllerProps, ListControllerResult, ListFilterContext, ListFilterContextValue, ListPaginationContext, ListPaginationContextValue, ListParams, ListParamsOptions, ListSortContext, ListSortContextValue, LoadingComponent, LoginComponent, MutationMode, NotificationContext, NotificationContextProvider, NotificationContextType, NotificationOptions, NotificationPayload, NotificationType, OnSuccess, OptionText, OptionTextElement, OptionTextFunc, OptionalRecordContextProvider, Options, PaginationHookResult, PaginationPayload, PossibleInferredElementTypes, RaRecord, _default$3 as Ready, RecordContext, RecordContextProvider, RecordContextProviderProps, RedirectionSideEffect, RenderResourcesFunction, Resource, ResourceComponentInjectedProps, ResourceContext, ResourceContextProvider, ResourceContextValue, ResourceDefinition, ResourceDefinitionContext, ResourceDefinitionContextProvider, ResourceDefinitionContextValue, ResourceDefinitions, ResourceElement, ResourceOptions, ResourceProps, SET_FILTER, SET_PAGE, SET_PER_PAGE, SET_SORT, SHOW_FILTER, SORT_ASC, SORT_DESC, SaveContext, SaveContextProvider, SaveContextValue, SaveHandler, SelectTranslatableLocale, SetOnSave, ShowBase, ShowContext, ShowContextProvider, ShowController, ShowControllerProps, ShowControllerResult, SortPayload, SortProps, Store, StoreContext, StoreContextProvider, StoreContextProviderProps, StoreSetter, StoreSetterProps, StringMap, TestTranslationProvider, TitleComponent, TransformData, TranslatableContext, TranslatableContextProvider, TranslatableContextValue, Translate, TranslationMessages, UPDATE, UPDATE_MANY, UpdateManyParams, UpdateManyResult, UpdateParams, UpdateResult, UseAugmentedFormProps, UseAuthenticatedOptions, UseChoicesOptions, UseCreateMutateParams, UseCreateOptions, UseCreateResult, UseDataProviderOptions, UseDeleteManyMutateParams, UseDeleteManyOptions, UseDeleteManyResult, UseDeleteMutateParams, UseDeleteOptions, UseDeleteResult, UseFormOwnProps, UseGetListHookValue, UseGetManyHookValue, UseGetManyReferenceHookValue, UseGetOneHookValue, UseInputValue, UseListOptions, UseListValue, UseRecordContextParams, UseReferenceArrayFieldControllerParams, UseReferenceArrayInputParams, UseReferenceInputControllerParams, UseReferenceManyFieldControllerParams, UseReferenceOneFieldControllerParams, UseReferenceResult, UseResourceDefinitionOptions, UseSuggestionsOptions, UseTranslatableOptions, UseUpdateManyMutateParams, UseUpdateManyOptions, UseUpdateManyResult, UseUpdateMutateParams, UseUpdateOptions, UseUpdateResult, UserCheck, UserIdentity, ValidUntil, ValidateForm, ValidationError, ValidationErrorMessage, ValidationErrorMessageWithArgs, ValidationErrorProps, Validator, _default$d as WithPermissions, WithPermissionsProps, WithRecord, WithRecordProps, choices, combine2Validators, combineDataProviders, composeSyncValidators, composeValidators, _default$c as convertLegacyAuthProvider, convertLegacyDataProvider, defaultDataProvider, defaultExporter, _default$a as downloadCSV, email, _default$7 as escapePath, fetchActionsWithArrayOfIdentifiedRecordsResponse, fetchActionsWithArrayOfRecordsResponse, fetchActionsWithRecordResponse, fetchActionsWithTotalResponse, fetchRelatedRecords, fetch as fetchUtils, _default$9 as getElementsFromRecords, _default$5 as getFieldLabelTranslationArgs, getFormGroupState, getListControllerProps, getMutationMode, getNumberOrDefault, getQuery, getRecordFromLocation, getSelectedReferencesStatus, getSimpleValidationResolver, getStatusForArrayInput, getStatusForInput, getStorage, getSuggestionsFactory, _default$8 as getValuesFromRecords, hasCustomParams, inferTypeFromValues, injectedProps, isRequired, linkToRecord, localStorageStore, maxLength, maxValue, memoryStore, mergeRefs, mergeTranslations, minLength, minValue, number, onError, parseQueryFromLocation, queryReducer, regex, removeDoubleSlashes, removeEmpty, deepRemoveKey as removeKey, required, resolveBrowserLocale, resolveRedirectTo, sanitizeFetchType, sanitizeListRestProps, setSubmissionErrors, shallowEqual, testDataProvider, _default$b as undoableEventEmitter, useApplyInputDefaultValues, useAugmentedForm, useAuthProvider, useAuthState, useAuthenticated, useBasename, useCheckAuth, useCheckMinimumRequiredProps, useChoices, useChoicesContext, useCreate, useCreateContext, useCreateController, useCreatePath, useDataProvider, useDeepCompareEffect, useDelete, useDeleteMany, useDeleteWithConfirmController, useDeleteWithUndoController, useEditContext, useEditController, useEventCallback, useExpanded, _default$1 as useFilterState, useFormGroup, useFormGroupContext, useGetIdentity, useGetList, useGetMany, useGetManyAggregate, useGetManyReference, useGetOne, useGetPermissions, useGetResourceLabel, useGetValidationErrorMessage, useI18nProvider, useInitializeFormWithRecord, useInput, useIsDataLoaded, useIsFormInvalid, useIsMounted, useList, useListContext, useListController, useListFilterContext, useListPaginationContext, useListParams, useListSortContext, useLoading, useLocale, useLocaleState, useLogin, useLogout, useLogoutIfAccessDenied, useNotificationContext, useNotify, _default as usePaginationState, usePermissions, usePermissionsOptimized, usePickFilterContext, usePickPaginationContext, usePickSaveContext, usePickSortContext, usePrevious, useRecordContext, useRecordSelection, useRedirect, useReference, useReferenceArrayFieldController, useReferenceArrayInputController, useReferenceInputController, useReferenceManyFieldController, useReferenceOneFieldController, useRefresh, useRemoveFromStore, useResetStore, useResourceContext, useResourceDefinition, useResourceDefinitionContext, useResourceDefinitions, useSafeSetState, useSaveContext, useScrollToTop, useSetLocale, useShowContext, useShowController, useSortState, useStore, useStoreContext, useStoreResult, useSuggestions, useTimeout, useTranslatable, useTranslatableContext, useTranslate, useUnselect, useUnselectAll, useUpdate, useUpdateMany, useWarnWhenUnsavedChanges, useWhyDidYouUpdate, validQueryParams, _default$2 as warning };
